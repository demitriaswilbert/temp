[@file: .gitignore]
.pio
.vscode/.browse.c_cpp.db*
.vscode/c_cpp_properties.json
.vscode/launch.json
.vscode/ipch

[@file: file.c]
/*
  Keyboard.h

  Copyright (c) 2015, Arduino LLC
  Original code (pre-library): Copyright (c) 2011, Peter Barrett

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#pragma once
#include <stdint.h>

typedef union {
    struct {
            uint8_t numlock:1;
            uint8_t capslock:1;
            uint8_t scrolllock:1;
            uint8_t compose:1;
            uint8_t kana:1;
            uint8_t reserved:3;
    };
    uint8_t leds;
} arduino_usb_hid_keyboard_event_data_t;

// Power Control
#define CONSUMER_CONTROL_POWER                             0x0030
#define CONSUMER_CONTROL_RESET                             0x0031
#define CONSUMER_CONTROL_SLEEP                             0x0032

// Screen Brightness
#define CONSUMER_CONTROL_BRIGHTNESS_INCREMENT              0x006F
#define CONSUMER_CONTROL_BRIGHTNESS_DECREMENT              0x0070

// These HID usages operate only on mobile systems (battery powered) and
// require Windows 8 (build 8302 or greater).
#define CONSUMER_CONTROL_WIRELESS_RADIO_CONTROLS           0x000C
#define CONSUMER_CONTROL_WIRELESS_RADIO_BUTTONS            0x00C6
#define CONSUMER_CONTROL_WIRELESS_RADIO_LED                0x00C7
#define CONSUMER_CONTROL_WIRELESS_RADIO_SLIDER_SWITCH      0x00C8

// Media Control
#define CONSUMER_CONTROL_PLAY_PAUSE                        0x00CD
#define CONSUMER_CONTROL_SCAN_NEXT                         0x00B5
#define CONSUMER_CONTROL_SCAN_PREVIOUS                     0x00B6
#define CONSUMER_CONTROL_STOP                              0x00B7
#define CONSUMER_CONTROL_VOLUME                            0x00E0
#define CONSUMER_CONTROL_MUTE                              0x00E2
#define CONSUMER_CONTROL_BASS                              0x00E3
#define CONSUMER_CONTROL_TREBLE                            0x00E4
#define CONSUMER_CONTROL_BASS_BOOST                        0x00E5
#define CONSUMER_CONTROL_VOLUME_INCREMENT                  0x00E9
#define CONSUMER_CONTROL_VOLUME_DECREMENT                  0x00EA
#define CONSUMER_CONTROL_BASS_INCREMENT                    0x0152
#define CONSUMER_CONTROL_BASS_DECREMENT                    0x0153
#define CONSUMER_CONTROL_TREBLE_INCREMENT                  0x0154
#define CONSUMER_CONTROL_TREBLE_DECREMENT                  0x0155

// Application Launcher
#define CONSUMER_CONTROL_CONFIGURATION                     0x0183
#define CONSUMER_CONTROL_EMAIL_READER                      0x018A
#define CONSUMER_CONTROL_CALCULATOR                        0x0192
#define CONSUMER_CONTROL_LOCAL_BROWSER                     0x0194

// Browser/Explorer Specific
#define CONSUMER_CONTROL_SEARCH                            0x0221
#define CONSUMER_CONTROL_HOME                              0x0223
#define CONSUMER_CONTROL_BACK                              0x0224
#define CONSUMER_CONTROL_FORWARD                           0x0225
#define CONSUMER_CONTROL_BR_STOP                           0x0226
#define CONSUMER_CONTROL_REFRESH                           0x0227
#define CONSUMER_CONTROL_BOOKMARKS                         0x022A

// Mouse Horizontal scroll
#define CONSUMER_CONTROL_PAN                               0x0238

#define CC_BIT_0 CONSUMER_CONTROL_SCAN_NEXT
#define CC_BIT_1 CONSUMER_CONTROL_SCAN_PREVIOUS
#define CC_BIT_2 CONSUMER_CONTROL_STOP
#define CC_BIT_3 CONSUMER_CONTROL_PLAY_PAUSE
#define CC_BIT_4 CONSUMER_CONTROL_MUTE
#define CC_BIT_5 CONSUMER_CONTROL_VOLUME_INCREMENT
#define CC_BIT_6 CONSUMER_CONTROL_VOLUME_DECREMENT
#define CC_BIT_7 CONSUMER_CONTROL_HOME
#define CC_BIT_8 CONSUMER_CONTROL_LOCAL_BROWSER
#define CC_BIT_9 CONSUMER_CONTROL_CALCULATOR
#define CC_BIT_A CONSUMER_CONTROL_BRIGHTNESS_DECREMENT
#define CC_BIT_B CONSUMER_CONTROL_BRIGHTNESS_INCREMENT
#define CC_BIT_C CONSUMER_CONTROL_BR_STOP
#define CC_BIT_D CONSUMER_CONTROL_BACK
#define CC_BIT_E CONSUMER_CONTROL_CONFIGURATION
#define CC_BIT_F CONSUMER_CONTROL_EMAIL_READER

#define M_KEY_TYPE_MASK        ((uint32_t)0xffff0000UL)
#define M_KEY_TARGET_MASK      ((uint32_t)0xC0000000UL)

#define M_KEY_TARGET_KB       ((uint32_t)0x40000000UL)
#define M_KEY_TARGET_CC       ((uint32_t)0x80000000UL)

#define M_KEY_TYPE_MODIF      (M_KEY_TARGET_KB | (uint32_t)0x01000000UL)
#define M_KEY_TYPE_NONPRINT   (M_KEY_TARGET_KB | (uint32_t)0x02000000UL)
#define M_KEY_TYPE_KEYPAD     (M_KEY_TARGET_KB | (uint32_t)0x04000000UL)
#define SHIFT               (M_KEY_TARGET_KB | (uint32_t)0x08000000UL)

#define M_KEY_LEFT_CTRL       (M_KEY_TYPE_MODIF | (uint32_t)0x01UL)
#define M_KEY_LEFT_SHIFT      (M_KEY_TYPE_MODIF | (uint32_t)0x02UL)
#define M_KEY_LEFT_ALT        (M_KEY_TYPE_MODIF | (uint32_t)0x04UL)
#define M_KEY_LEFT_GUI        (M_KEY_TYPE_MODIF | (uint32_t)0x08UL)
#define M_KEY_RIGHT_CTRL      (M_KEY_TYPE_MODIF | (uint32_t)0x10UL)
#define M_KEY_RIGHT_SHIFT     (M_KEY_TYPE_MODIF | (uint32_t)0x20UL)
#define M_KEY_RIGHT_ALT       (M_KEY_TYPE_MODIF | (uint32_t)0x40UL)
#define M_KEY_RIGHT_GUI       (M_KEY_TYPE_MODIF | (uint32_t)0x80UL)

#define M_KEY_UP_ARROW        (M_KEY_TYPE_NONPRINT | (uint32_t)0x0052UL)
#define M_KEY_DOWN_ARROW      (M_KEY_TYPE_NONPRINT | (uint32_t)0x0051UL)
#define M_KEY_LEFT_ARROW      (M_KEY_TYPE_NONPRINT | (uint32_t)0x0050UL)
#define M_KEY_RIGHT_ARROW     (M_KEY_TYPE_NONPRINT | (uint32_t)0x004fUL)
#define M_KEY_BACKSPACE       (M_KEY_TYPE_NONPRINT | (uint32_t)0x002aUL)
#define M_KEY_TAB             (M_KEY_TYPE_NONPRINT | (uint32_t)0x002bUL)
#define M_KEY_RETURN          (M_KEY_TYPE_NONPRINT | (uint32_t)0x0028UL)
#define M_KEY_ESC             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0029UL)
#define M_KEY_INSERT          (M_KEY_TYPE_NONPRINT | (uint32_t)0x0049UL)
#define M_KEY_PRTSC           (M_KEY_TYPE_NONPRINT | (uint32_t)0x0046UL)
#define M_KEY_DELETE          (M_KEY_TYPE_NONPRINT | (uint32_t)0x004cUL)
#define M_KEY_PAGE_UP         (M_KEY_TYPE_NONPRINT | (uint32_t)0x004bUL)
#define M_KEY_PAGE_DOWN       (M_KEY_TYPE_NONPRINT | (uint32_t)0x004eUL)
#define M_KEY_HOME            (M_KEY_TYPE_NONPRINT | (uint32_t)0x004aUL)
#define M_KEY_END             (M_KEY_TYPE_NONPRINT | (uint32_t)0x004dUL)
#define M_KEY_CAPS_LOCK       (M_KEY_TYPE_NONPRINT | (uint32_t)0x0039UL)
#define M_KEY_NUM_LOCK        (M_KEY_TYPE_NONPRINT | (uint32_t)0x0053UL)

#define M_KEY_F1              (M_KEY_TYPE_NONPRINT | (uint32_t)0x003aUL)
#define M_KEY_F2              (M_KEY_TYPE_NONPRINT | (uint32_t)0x003bUL)
#define M_KEY_F3              (M_KEY_TYPE_NONPRINT | (uint32_t)0x003cUL)
#define M_KEY_F4              (M_KEY_TYPE_NONPRINT | (uint32_t)0x003dUL)
#define M_KEY_F5              (M_KEY_TYPE_NONPRINT | (uint32_t)0x003eUL)
#define M_KEY_F6              (M_KEY_TYPE_NONPRINT | (uint32_t)0x003fUL)
#define M_KEY_F7              (M_KEY_TYPE_NONPRINT | (uint32_t)0x0040UL)
#define M_KEY_F8              (M_KEY_TYPE_NONPRINT | (uint32_t)0x0041UL)
#define M_KEY_F9              (M_KEY_TYPE_NONPRINT | (uint32_t)0x0042UL)
#define M_KEY_F10             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0043UL)
#define M_KEY_F11             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0044UL)
#define M_KEY_F12             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0045UL)
#define M_KEY_PRTSC           (M_KEY_TYPE_NONPRINT | (uint32_t)0x0046UL)
#define M_KEY_F13             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0068UL)
#define M_KEY_F14             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0069UL)
#define M_KEY_F15             (M_KEY_TYPE_NONPRINT | (uint32_t)0x006aUL)
#define M_KEY_F16             (M_KEY_TYPE_NONPRINT | (uint32_t)0x006bUL)
#define M_KEY_F17             (M_KEY_TYPE_NONPRINT | (uint32_t)0x006cUL)
#define M_KEY_F18             (M_KEY_TYPE_NONPRINT | (uint32_t)0x006dUL)
#define M_KEY_F19             (M_KEY_TYPE_NONPRINT | (uint32_t)0x006eUL)
#define M_KEY_F20             (M_KEY_TYPE_NONPRINT | (uint32_t)0x006fUL)
#define M_KEY_F21             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0070UL)
#define M_KEY_F22             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0071UL)
#define M_KEY_F23             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0072UL)
#define M_KEY_F24             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0073UL)

#define M_KEY_NUM_0           (M_KEY_TYPE_KEYPAD | (uint32_t)0x0062UL)
#define M_KEY_NUM_1           (M_KEY_TYPE_KEYPAD | (uint32_t)0x0059UL)
#define M_KEY_NUM_2           (M_KEY_TYPE_KEYPAD | (uint32_t)0x005aUL)
#define M_KEY_NUM_3           (M_KEY_TYPE_KEYPAD | (uint32_t)0x005bUL)
#define M_KEY_NUM_4           (M_KEY_TYPE_KEYPAD | (uint32_t)0x005cUL)
#define M_KEY_NUM_5           (M_KEY_TYPE_KEYPAD | (uint32_t)0x005dUL)
#define M_KEY_NUM_6           (M_KEY_TYPE_KEYPAD | (uint32_t)0x005eUL)
#define M_KEY_NUM_7           (M_KEY_TYPE_KEYPAD | (uint32_t)0x005fUL)
#define M_KEY_NUM_8           (M_KEY_TYPE_KEYPAD | (uint32_t)0x0060UL)
#define M_KEY_NUM_9           (M_KEY_TYPE_KEYPAD | (uint32_t)0x0061UL)
#define M_KEY_NUM_SLASH       (M_KEY_TYPE_KEYPAD | (uint32_t)0x0054UL)
#define M_KEY_NUM_ASTERISK    (M_KEY_TYPE_KEYPAD | (uint32_t)0x0055UL)
#define M_KEY_NUM_MINUS       (M_KEY_TYPE_KEYPAD | (uint32_t)0x0056UL)
#define M_KEY_NUM_PLUS        (M_KEY_TYPE_KEYPAD | (uint32_t)0x0057UL)
#define M_KEY_NUM_ENTER       (M_KEY_TYPE_KEYPAD | (uint32_t)0x0058UL)
#define M_KEY_NUM_PERIOD      (M_KEY_TYPE_KEYPAD | (uint32_t)0x0063UL)
#define M_KEY_NUM_EQUAL       (M_KEY_TYPE_KEYPAD | (uint32_t)0x0067UL)


typedef uint32_t MediaKeyReport;

#define M_KEY_MEDIA_NEXT              (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x0U))
#define M_KEY_MEDIA_PREV              (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x1U))
#define M_KEY_MEDIA_STOP              (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x2U))
#define M_KEY_MEDIA_PAUSE             (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x3U))
#define M_KEY_MEDIA_MUTE              (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x4U))
#define M_KEY_MEDIA_VOLUP             (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x5U))
#define M_KEY_MEDIA_VOLDN             (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x6U))
#define M_KEY_MEDIA_WWW_HOME          (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x7U))

#define M_KEY_FILE_EXPLORER           (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x8U))
#define M_KEY_MEDIA_CALC              (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x9U))
#define M_KEY_MEDIA_BRIGHTNESS_D      (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0xAU))
#define M_KEY_MEDIA_BRIGHTNESS_I      (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0xBU))
#define M_KEY_MEDIA_WWW_STOP          (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0xCU))
#define M_KEY_MEDIA_WWW_BACK          (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0xDU))
#define M_KEY_CONSUMER_CTL            (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0xEU))
#define M_KEY_MEDIA_EMAIL             (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0xFU))

#define STR_LEFT_CTRL "\x80"
#define STR_LEFT_SHIFT "\x81"
#define STR_LEFT_ALT "\x82"
#define STR_LEFT_GUI "\x83"
#define STR_RIGHT_CTRL "\x84"
#define STR_RIGHT_SHIFT "\x85"
#define STR_RIGHT_ALT "\x86"
#define STR_RIGHT_GUI "\x87"
#define STR_UP_ARROW "\x88"
#define STR_DOWN_ARROW "\x89"
#define STR_LEFT_ARROW "\x8a"
#define STR_RIGHT_ARROW "\x8b"
#define STR_BACKSPACE "\x8c"
#define STR_TAB "\x8d"
#define STR_RETURN "\x8e"
#define STR_ESC "\x8f"
#define STR_INSERT "\x90"
#define STR_PRTSC "\x91"
#define STR_DELETE "\x92"
#define STR_PAGE_UP "\x93"
#define STR_PAGE_DOWN "\x94"
#define STR_HOME "\x95"
#define STR_END "\x96"
#define STR_CAPS_LOCK "\x97"
#define STR_NUM_LOCK "\x98"
#define STR_F1 "\x99"
#define STR_F2 "\x9a"
#define STR_F3 "\x9b"
#define STR_F4 "\x9c"
#define STR_F5 "\x9d"
#define STR_F6 "\x9e"
#define STR_F7 "\x9f"
#define STR_F8 "\xa0"
#define STR_F9 "\xa1"
#define STR_F10 "\xa2"
#define STR_F11 "\xa3"
#define STR_F12 "\xa4"
#define STR_F13 "\xa5"
#define STR_F14 "\xa6"
#define STR_F15 "\xa7"
#define STR_F16 "\xa8"
#define STR_F17 "\xa9"
#define STR_F18 "\xaa"
#define STR_F19 "\xab"
#define STR_F20 "\xac"
#define STR_F21 "\xad"
#define STR_F22 "\xae"
#define STR_F23 "\xaf"
#define STR_F24 "\xb0"
#define STR_NUM_0 "\xb1"
#define STR_NUM_1 "\xb2"
#define STR_NUM_2 "\xb3"
#define STR_NUM_3 "\xb4"
#define STR_NUM_4 "\xb5"
#define STR_NUM_5 "\xb6"
#define STR_NUM_6 "\xb7"
#define STR_NUM_7 "\xb8"
#define STR_NUM_8 "\xb9"
#define STR_NUM_9 "\xba"
#define STR_NUM_SLASH "\xbb"
#define STR_NUM_ASTERISK "\xbc"
#define STR_NUM_MINUS "\xbd"
#define STR_NUM_PLUS "\xbe"
#define STR_NUM_ENTER "\xbf"
#define STR_NUM_PERIOD "\xc0"
#define STR_NUM_EQUAL "\xc1"
#define STR_MEDIA_NEXT "\xc2"
#define STR_MEDIA_PREV "\xc3"
#define STR_MEDIA_STOP "\xc4"
#define STR_MEDIA_PAUSE "\xc5"
#define STR_MEDIA_MUTE "\xc6"
#define STR_MEDIA_VOLUP "\xc7"
#define STR_MEDIA_VOLDN "\xc8"
#define STR_MEDIA_WWW_HOME "\xc9"
#define STR_FILE_EXPLORER "\xca"
#define STR_MEDIA_CALC "\xcb"
#define STR_MEDIA_BRIGHTNESS_D "\xcc"
#define STR_MEDIA_BRIGHTNESS_I "\xcd"
#define STR_MEDIA_WWW_STOP "\xce"
#define STR_MEDIA_WWW_BACK "\xcf"
#define STR_CONSUMER_CTL "\xd0"
#define STR_MEDIA_EMAIL "\xd1"

#define LED_NUMLOCK     0x01
#define LED_CAPSLOCK    0x02
#define LED_SCROLLLOCK  0x04
#define LED_COMPOSE     0x08
#define LED_KANA        0x10

//  Low level key report: up to 6 keys and shift, ctrl etc at once
typedef struct
{
  uint8_t modifiers;
  uint8_t reserved;
  uint8_t keys[62];
} KeyReport;

const uint32_t _asciimap[] =
{
    0x00U, // NUL
    0x00U, // SOH
    0x00U, // STX
    0x00U, // ETX
    0x00U, // EOT
    0x00U, // ENQ
    0x00U, // ACK
    0x00U, // BEL
    0x2aU, // BS    Backspace
    0x2bU, // TAB   Tab
    0x28U, // LF    Enter
    0x00U, // VT
    0x00U, // FF
    0x00U, // CR
    0x00U, // SO
    0x00U, // SI
    0x00U, // DEL
    0x00U, // DC1
    0x00U, // DC2
    0x00U, // DC3
    0x00U, // DC4
    0x00U, // NAK
    0x00U, // SYN
    0x00U, // ETB
    0x00U, // CAN
    0x00U, // EM
    0x00U, // SUB
    0x00U, // ESC
    0x00U, // FS
    0x00U, // GS
    0x00U, // RS
    0x00U, // US
    0x2cU,         //  ' '
    0x1eU | SHIFT, // !
    0x34U | SHIFT, // "
    0x20U | SHIFT, // #
    0x21U | SHIFT, // $
    0x22U | SHIFT, // %
    0x24U | SHIFT, // &
    0x34U,         // '
    0x26U | SHIFT, // (
    0x27U | SHIFT, // )
    0x25U | SHIFT, // *
    0x2eU | SHIFT, // +
    0x36U,         // ,
    0x2dU,         // -
    0x37U,         // .
    0x38U,         // /
    0x27U,         // 0
    0x1eU,         // 1
    0x1fU,         // 2
    0x20U,         // 3
    0x21U,         // 4
    0x22U,         // 5
    0x23U,         // 6
    0x24U,         // 7
    0x25U,         // 8
    0x26U,         // 9
    0x33U | SHIFT, // :
    0x33U,         // ;
    0x36U | SHIFT, // <
    0x2eU,         // =
    0x37U | SHIFT, // >
    0x38U | SHIFT, // ?
    0x1fU | SHIFT, // @
    0x04U | SHIFT, // A
    0x05U | SHIFT, // B
    0x06U | SHIFT, // C
    0x07U | SHIFT, // D
    0x08U | SHIFT, // E
    0x09U | SHIFT, // F
    0x0aU | SHIFT, // G
    0x0bU | SHIFT, // H
    0x0cU | SHIFT, // I
    0x0dU | SHIFT, // J
    0x0eU | SHIFT, // K
    0x0fU | SHIFT, // L
    0x10U | SHIFT, // M
    0x11U | SHIFT, // N
    0x12U | SHIFT, // O
    0x13U | SHIFT, // P
    0x14U | SHIFT, // Q
    0x15U | SHIFT, // R
    0x16U | SHIFT, // S
    0x17U | SHIFT, // T
    0x18U | SHIFT, // U
    0x19U | SHIFT, // V
    0x1aU | SHIFT, // W
    0x1bU | SHIFT, // X
    0x1cU | SHIFT, // Y
    0x1dU | SHIFT, // Z
    0x2fU,         // [
    0x31U,         // bslash
    0x30U,         // ]
    0x23U | SHIFT, // ^
    0x2dU | SHIFT, // _
    0x35U,         // `
    0x04U,         // a
    0x05U,         // b
    0x06U,         // c
    0x07U,         // d
    0x08U,         // e
    0x09U,         // f
    0x0aU,         // g
    0x0bU,         // h
    0x0cU,         // i
    0x0dU,         // j
    0x0eU,         // k
    0x0fU,         // l
    0x10U,         // m
    0x11U,         // n
    0x12U,         // o
    0x13U,         // p
    0x14U,         // q
    0x15U,         // r
    0x16U,         // s
    0x17U,         // t
    0x18U,         // u
    0x19U,         // v
    0x1aU,         // w
    0x1bU,         // x
    0x1cU,         // y
    0x1dU,         // z
    0x2fU | SHIFT, // {
    0x31U | SHIFT, // |
    0x30U | SHIFT, // }
    0x35U | SHIFT, // ~
    0x00U,         // DEL
    // MODIFIER
    M_KEY_LEFT_CTRL,
    M_KEY_LEFT_SHIFT,
    M_KEY_LEFT_ALT, 
    M_KEY_LEFT_GUI, 
    M_KEY_RIGHT_CTRL, 
    M_KEY_RIGHT_SHIFT, 
    M_KEY_RIGHT_ALT, 
    M_KEY_RIGHT_GUI, 
    // NONPRINT
    M_KEY_UP_ARROW,
    M_KEY_DOWN_ARROW,
    M_KEY_LEFT_ARROW,
    M_KEY_RIGHT_ARROW,
    M_KEY_BACKSPACE,
    M_KEY_TAB,
    M_KEY_RETURN,
    M_KEY_ESC,
    M_KEY_INSERT,
    M_KEY_PRTSC,
    M_KEY_DELETE,
    M_KEY_PAGE_UP,
    M_KEY_PAGE_DOWN,
    M_KEY_HOME,
    M_KEY_END,
    M_KEY_CAPS_LOCK,
    M_KEY_NUM_LOCK,

    // F Keys
    M_KEY_F1, 
    M_KEY_F2, 
    M_KEY_F3, 
    M_KEY_F4, 
    M_KEY_F5, 
    M_KEY_F6, 
    M_KEY_F7, 
    M_KEY_F8, 
    M_KEY_F9, 
    M_KEY_F10, 
    M_KEY_F11, 
    M_KEY_F12, 
    M_KEY_F13, 
    M_KEY_F14, 
    M_KEY_F15, 
    M_KEY_F16, 
    M_KEY_F17, 
    M_KEY_F18, 
    M_KEY_F19, 
    M_KEY_F20, 
    M_KEY_F21, 
    M_KEY_F22, 
    M_KEY_F23, 
    M_KEY_F24, 

    // KEYPAD
    M_KEY_NUM_0,
    M_KEY_NUM_1,
    M_KEY_NUM_2,
    M_KEY_NUM_3,
    M_KEY_NUM_4,
    M_KEY_NUM_5,
    M_KEY_NUM_6,
    M_KEY_NUM_7,
    M_KEY_NUM_8,
    M_KEY_NUM_9,
    M_KEY_NUM_SLASH,
    M_KEY_NUM_ASTERISK,
    M_KEY_NUM_MINUS,
    M_KEY_NUM_PLUS,
    M_KEY_NUM_ENTER,
    M_KEY_NUM_PERIOD,
    M_KEY_NUM_EQUAL,

    // // MEDIA 1
    // M_KEY_MEDIA_NEXT,
    // M_KEY_MEDIA_PREV, 
    // M_KEY_MEDIA_STOP, 
    // M_KEY_MEDIA_PAUSE, 
    // M_KEY_MEDIA_MUTE, 
    // M_KEY_MEDIA_VOLUP, 
    // M_KEY_MEDIA_VOLDN, 
    // M_KEY_MEDIA_WWW_HOME, 
    
    // // MEDIA 2
    // M_KEY_FILE_EXPLORER, 
    // M_KEY_MEDIA_CALC, 
    // M_KEY_MEDIA_BRIGHTNESS_D, 
    // M_KEY_MEDIA_BRIGHTNESS_I, 
    // M_KEY_MEDIA_WWW_STOP, 
    // M_KEY_MEDIA_WWW_BACK, 
    // M_KEY_CONSUMER_CTL, 
    // M_KEY_MEDIA_EMAIL, 
};

#include <stdio.h>

int main() {
    // char ch[] = STR_F5 STR_F6 STR_F7 STR_F10 STR_F11 STR_F12 "aezakmi" "hesoyam" "cvwkxam" "uzumymw" "vkypqcf" "worshipme" "helloladies" "toodamnhot" "fullclip" STR_ESC;
    char ch[] = \
    "KB ram 0" STR_ESC\
    "KB ram test" STR_ESC\
    "KB ram 1" STR_ESC\
    "KB ram test" STR_ESC\
    "KB ram 2" STR_ESC\
    "KB ram test" STR_ESC\
    "KB ram 3" STR_ESC\
    "KB ram test" STR_ESC\
    "KB ram 4" STR_ESC\
    "KB ram test" STR_ESC\
    "KB ram 5" STR_ESC\
    "KB ram test" STR_ESC\
    "KB ram 6" STR_ESC\
    "KB ram test" STR_ESC\
    "KB ram 7" STR_ESC\
    "KB ram test" STR_ESC;
    FILE* fp = fopen("new.txt", "wb");
    fwrite(ch, sizeof(ch), 1, fp);
}
[@file: file.py]
a = 480
frqs = [
    720,
    664,
    508,
    454
]
res = []
for _ in frqs: res.append([])
for i in range(18, 19):
    for j in range(12, 36):
        tmp = a*i/j
        for k in range(len(frqs)):
            if tmp >= round(frqs[k]) and tmp <= (round(frqs[k]) + 1):
                res[k].append((tmp, i, j))

sd = [
("(7UL << 29UL) | (0UL << 8UL)", "49.5 MHz"),
("(6UL << 29UL) | (0UL << 8UL)", "56.57143 MHz"),
("(5UL << 29UL) | (0UL << 8UL)", "66.0 MHz"),
("(7UL << 29UL) | (3UL << 8UL)", "66.0 MHz"),
("(6UL << 29UL) | (3UL << 8UL)", "75.428574 MHz"),
("(4UL << 29UL) | (0UL << 8UL)", "79.199997 MHz"),
("(7UL << 29UL) | (2UL << 8UL)", "83.077499 MHz"),
("(5UL << 29UL) | (3UL << 8UL)", "88.0 MHz"),
("(7UL << 29UL) | (1UL << 8UL)", "90.0 MHz"),
("(6UL << 29UL) | (2UL << 8UL)", "94.945717 MHz"),
("(3UL << 29UL) | (0UL << 8UL)", "99.0 MHz"),
("(6UL << 29UL) | (1UL << 8UL)", "102.85714 MHz"),
("(4UL << 29UL) | (3UL << 8UL)", "105.599998 MHz"),
("(5UL << 29UL) | (2UL << 8UL)", "110.769997 MHz"),
("(5UL << 29UL) | (1UL << 8UL)", "120.0 MHz"),
("(2UL << 29UL) | (0UL << 8UL)", "132.0 MHz"),
("(3UL << 29UL) | (3UL << 8UL)", "132.0 MHz"),
("(4UL << 29UL) | (2UL << 8UL)", "132.923996 MHz"),
("(4UL << 29UL) | (1UL << 8UL)", "144.0 MHz"),
("(3UL << 29UL) | (2UL << 8UL)", "166.154999 MHz"),
("(2UL << 29UL) | (3UL << 8UL)", "176.0 MHz"),
("(3UL << 29UL) | (1UL << 8UL)", "180.0 MHz (MAX for ESP-PSRAM64H)"),
("(1UL << 29UL) | (0UL << 8UL)", "198.0 MHz"),
("(2UL << 29UL) | (2UL << 8UL)", "221.539993 MHz"),
("(2UL << 29UL) | (1UL << 8UL)", "240.0 MHz"),
("(1UL << 29UL) | (3UL << 8UL)", "264.0 MHz"),
("(1UL << 29UL) | (2UL << 8UL)", "332.309998 MHz"),
("(1UL << 29UL) | (1UL << 8UL)", "360.0 MHz"),
("(0UL << 29UL) | (0UL << 8UL)", "396.0 MHz"),
("(0UL << 29UL) | (3UL << 8UL)", "528.0 MHz"),
("(0UL << 29UL) | (2UL << 8UL)", "664.619995 MHz"),
("(0UL << 29UL) | (1UL << 8UL)", "720.0 MHz")
]

for i in range(len(sd)):
    print(sd[i][0], f"// {i}. {sd[i][1]}")
[@file: file1.txt]
(7UL << 29UL) | (0UL << 8UL) // 0. 49.5 MHz
(6UL << 29UL) | (0UL << 8UL) // 1. 56.57143 MHz
(5UL << 29UL) | (0UL << 8UL) // 2. 66.0 MHz
(7UL << 29UL) | (3UL << 8UL) // 3. 66.0 MHz
(6UL << 29UL) | (3UL << 8UL) // 4. 75.428574 MHz
(4UL << 29UL) | (0UL << 8UL) // 5. 79.199997 MHz
(7UL << 29UL) | (2UL << 8UL) // 6. 83.077499 MHz
(5UL << 29UL) | (3UL << 8UL) // 7. 88.0 MHz
(7UL << 29UL) | (1UL << 8UL) // 8. 90.0 MHz
(6UL << 29UL) | (2UL << 8UL) // 9. 94.945717 MHz
(3UL << 29UL) | (0UL << 8UL) // 10. 99.0 MHz
(6UL << 29UL) | (1UL << 8UL) // 11. 102.85714 MHz
(4UL << 29UL) | (3UL << 8UL) // 12. 105.599998 MHz
(5UL << 29UL) | (2UL << 8UL) // 13. 110.769997 MHz
(5UL << 29UL) | (1UL << 8UL) // 14. 120.0 MHz
(2UL << 29UL) | (0UL << 8UL) // 15. 132.0 MHz
(3UL << 29UL) | (3UL << 8UL) // 16. 132.0 MHz
(4UL << 29UL) | (2UL << 8UL) // 17. 132.923996 MHz
(4UL << 29UL) | (1UL << 8UL) // 18. 144.0 MHz
(3UL << 29UL) | (2UL << 8UL) // 19. 166.154999 MHz
(2UL << 29UL) | (3UL << 8UL) // 20. 176.0 MHz
(3UL << 29UL) | (1UL << 8UL) // 21. 180.0 MHz (MAX for ESP-PSRAM64H)
(1UL << 29UL) | (0UL << 8UL) // 22. 198.0 MHz
(2UL << 29UL) | (2UL << 8UL) // 23. 221.539993 MHz
(2UL << 29UL) | (1UL << 8UL) // 24. 240.0 MHz
(1UL << 29UL) | (3UL << 8UL) // 25. 264.0 MHz
(1UL << 29UL) | (2UL << 8UL) // 26. 332.309998 MHz
(1UL << 29UL) | (1UL << 8UL) // 27. 360.0 MHz
(0UL << 29UL) | (0UL << 8UL) // 28. 396.0 MHz
(0UL << 29UL) | (3UL << 8UL) // 29. 528.0 MHz
(0UL << 29UL) | (2UL << 8UL) // 30. 664.619995 MHz
(0UL << 29UL) | (1UL << 8UL) // 31. 720.0 MHz

KB ram 0:	(30.8  MHz),	per_bytes: 60.976564, MB/s: 9.839846
KB ram 1:	(33.9  MHz),	per_bytes: 56.189805, MB/s: 10.678094
KB ram 2:	(35.2  MHz),	per_bytes: 54.088964, MB/s: 11.092836
KB ram 3:	(36.0  MHz),	per_bytes: 52.985105, MB/s: 11.323937
KB ram 4:	(38.7  MHz),	per_bytes: 49.185309, MB/s: 12.198764
KB ram 5:	(41.1  MHz),	per_bytes: 46.392587, MB/s: 12.933101
KB ram 6:	(41.1  MHz),	per_bytes: 46.392558, MB/s: 12.933109
KB ram 7:	(45.2  MHz),	per_bytes: 42.419322, MB/s: 14.144498
KB ram 0:	(49.5  MHz),    per_bytes: 39.623991, MB/s: 15.142341
KB ram 1:	(56.6  MHz),    per_bytes: 34.643385, MB/s: 17.319324
KB ram 2:	(66.0  MHz),    per_bytes: 30.009388, MB/s: 19.993743
KB ram 3:	(66.0  MHz),    per_bytes: 29.973628, MB/s: 20.017597
KB ram 4:	(75.4  MHz),    per_bytes: 26.348697, MB/s: 22.771524
KB ram 5:	(79.2  MHz),    per_bytes: 25.339239, MB/s: 23.678690
KB ram 6:	(83.1  MHz),    per_bytes: 24.286850, MB/s: 24.704727
KB ram 7:	(88.0  MHz),    per_bytes: 22.944839, MB/s: 26.149671
KB ram 8:	(90.0  MHz),    per_bytes: 22.438235, MB/s: 26.740071
KB ram 9:	(94.9  MHz),    per_bytes: 21.422368, MB/s: 28.008109
KB ram 10:	(99.0  MHz),    per_bytes: 20.747738, MB/s: 28.918815
KB ram 11:	(102.9 MHz),	per_bytes: 19.989192, MB/s: 30.016221
KB ram 12:	(105.6 MHz),	per_bytes: 19.605323, MB/s: 30.603934
KB ram 13:	(110.8 MHz),	per_bytes: 18.717328, MB/s: 32.055858
KB ram 14:	(120.0 MHz),	per_bytes: 17.439951, MB/s: 34.403766
KB ram 15:	(132.0 MHz),	per_bytes: 15.980623, MB/s: 37.545470
KB ram 16:	(132.0 MHz),	per_bytes: 15.991285, MB/s: 37.520437
KB ram 17:	(132.9 MHz),	per_bytes: 15.818480, MB/s: 37.930321
KB ram 18:	(144.0 MHz),	per_bytes: 14.504858, MB/s: 41.365451
KB ram 19:	(166.2 MHz),	per_bytes: 12.592710, MB/s: 47.646616
KB ram 20:	(176.0 MHz),	per_bytes: 11.848444, MB/s: 50.639563
KB ram 21:	(180.0 MHz),	per_bytes: 11.531907, MB/s: 52.029558
KB ram 22:	(198.0 MHz),	per_bytes: 10.701723, MB/s: 56.065738
KB ram 23:	(221.5 MHz),	per_bytes: 9.762527 , MB/s: 61.459500
KB ram 24:	(240.0 MHz),	per_bytes: 8.925637 , MB/s: 67.222091
KB ram 25:	(264.0 MHz),	per_bytes: 8.352914 , MB/s: 71.831217
KB ram 26:	(332.3 MHz),	per_bytes: 6.858916 , MB/s: 87.477382
KB ram 27:	(360.0 MHz),	per_bytes: 5.950275 , MB/s: 100.835669
KB ram 28:	(396.0 MHz),	per_bytes: 5.663282 , MB/s: 105.945626
KB ram 29:	(528.0 MHz),	per_bytes: 4.753071 , MB/s: 126.234180
KB ram 30:	(664.6 MHz),	per_bytes: 4.187002 , MB/s: 143.300618
KB ram 31:	(720.0 MHz),	per_bytes: 4.062057 , MB/s: 147.708397

[@file: new.txt]

[@file: platformio.ini]
; PlatformIO Project Configuration File
;
;   Build options: build flags, source filter
;   Upload options: custom upload port, speed and extra flags
;   Library options: dependencies, extra library storages
;   Advanced options: extra scripting
;
; Please visit documentation for the other options and examples
; https://docs.platformio.org/page/projectconf.html

[env:teensy41]
platform = teensy
board = teensy41
framework = arduino
build_flags = 
    -O3
    -D USB_SERIAL_HID

[@file: .pio/build/project.checksum]
f6ae28ca02834611307e7df3eb32df9c47e1ff41
[@file: .vscode/c_cpp_properties.json]
//
// !!! WARNING !!! AUTO-GENERATED FILE!
// PLEASE DO NOT MODIFY IT AND USE "platformio.ini":
// https://docs.platformio.org/page/projectconf/section_env_build.html#build-flags
//
{
    "configurations": [
        {
            "name": "PlatformIO",
            "includePath": [
                "c:/Users/User/Documents/PlatformIO/Projects/Test Keyboard/include",
                "c:/Users/User/Documents/PlatformIO/Projects/Test Keyboard/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/LittleFS/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/SPI",
                "c:/Users/User/Documents/PlatformIO/Projects/Test Keyboard/lib/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/cores/teensy4",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/ADC",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/AccelStepper/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Adafruit_NeoPixel",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Adafruit_STMPE610",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Adafruit_VS1053",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Adafruit_nRF8001",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Adafruit_nRF8001/utility",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/AltSoftSerial",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Artnet",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Audio",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Audio/utility",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Bounce",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Bounce2/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/CapacitiveSensor",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/CryptoAccel/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/DS1307RTC",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/DmxSimple",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/DogLcd",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/EEPROM",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/EasyTransfer",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/EasyTransferI2C",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Encoder",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Encoder/utility",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Entropy",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Ethernet/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FNET/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FastCRC",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FastLED/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FlexCAN",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FlexCAN_T4",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FlexIO_t4/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FlexiTimer2",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FreqCount",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FreqMeasure",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FreqMeasureMulti",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FrequencyTimer2",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/ILI9341_t3",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/ILI9488_t3/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/IRremote/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Keypad/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/LedControl/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/LedDisplay",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/LiquidCrystal/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/LiquidCrystalFast",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/LowPower",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/MFRC522/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/MIDI/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Metro",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/MsTimer2",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/NXPMotionSense",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/NXPMotionSense/utility",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/NativeEthernet/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/OSC",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/OctoWS2811",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/OneWire",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/PS2Keyboard",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/PS2Keyboard/utility",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/PWMServo",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Ping",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/PulsePosition",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/QuadEncoder",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/RA8875",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/RadioHead",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/ResponsiveAnalogRead/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/SD/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/SPIFlash",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/ST7735_t3",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/SdFat/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/SerialFlash",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Servo",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/ShiftPWM",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Snooze/src",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/SoftPWM",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/SoftwareSerial",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/TFT_ILI9163C",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Talkie",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/TeensyThreads",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Time",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/TimeAlarms",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/TimerOne",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/TimerThree",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/TinyGPS",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Tlc5940",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/TouchScreen",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/USBHost_t36",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/USBHost_t36/utility",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/UTFT",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/VirtualWire",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/WS2812Serial",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Wire",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Wire/utility",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/XBee",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/XPT2046_Touchscreen",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/i2c_t3",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/ks0108",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/ssd1351",
                "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/x10",
                ""
            ],
            "browse": {
                "limitSymbolsToIncludedHeaders": true,
                "path": [
                    "c:/Users/User/Documents/PlatformIO/Projects/Test Keyboard/include",
                    "c:/Users/User/Documents/PlatformIO/Projects/Test Keyboard/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/LittleFS/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/SPI",
                    "c:/Users/User/Documents/PlatformIO/Projects/Test Keyboard/lib/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/cores/teensy4",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/ADC",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/AccelStepper/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Adafruit_NeoPixel",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Adafruit_STMPE610",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Adafruit_VS1053",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Adafruit_nRF8001",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Adafruit_nRF8001/utility",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/AltSoftSerial",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Artnet",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Audio",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Audio/utility",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Bounce",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Bounce2/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/CapacitiveSensor",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/CryptoAccel/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/DS1307RTC",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/DmxSimple",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/DogLcd",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/EEPROM",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/EasyTransfer",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/EasyTransferI2C",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Encoder",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Encoder/utility",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Entropy",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Ethernet/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FNET/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FastCRC",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FastLED/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FlexCAN",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FlexCAN_T4",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FlexIO_t4/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FlexiTimer2",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FreqCount",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FreqMeasure",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FreqMeasureMulti",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/FrequencyTimer2",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/ILI9341_t3",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/ILI9488_t3/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/IRremote/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Keypad/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/LedControl/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/LedDisplay",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/LiquidCrystal/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/LiquidCrystalFast",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/LowPower",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/MFRC522/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/MIDI/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Metro",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/MsTimer2",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/NXPMotionSense",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/NXPMotionSense/utility",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/NativeEthernet/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/OSC",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/OctoWS2811",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/OneWire",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/PS2Keyboard",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/PS2Keyboard/utility",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/PWMServo",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Ping",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/PulsePosition",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/QuadEncoder",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/RA8875",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/RadioHead",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/ResponsiveAnalogRead/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/SD/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/SPIFlash",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/ST7735_t3",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/SdFat/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/SerialFlash",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Servo",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/ShiftPWM",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Snooze/src",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/SoftPWM",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/SoftwareSerial",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/TFT_ILI9163C",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Talkie",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/TeensyThreads",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Time",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/TimeAlarms",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/TimerOne",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/TimerThree",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/TinyGPS",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Tlc5940",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/TouchScreen",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/USBHost_t36",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/USBHost_t36/utility",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/UTFT",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/VirtualWire",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/WS2812Serial",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Wire",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/Wire/utility",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/XBee",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/XPT2046_Touchscreen",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/i2c_t3",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/ks0108",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/ssd1351",
                    "C:/Users/User/.platformio/packages/framework-arduinoteensy/libraries/x10",
                    ""
                ]
            },
            "defines": [
                "PLATFORMIO=60111",
                "__IMXRT1062__",
                "ARDUINO_TEENSY41",
                "USB_SERIAL_HID",
                "ARDUINO=10805",
                "TEENSYDUINO=156",
                "CORE_TEENSY",
                "F_CPU=600000000",
                "LAYOUT_US_ENGLISH",
                ""
            ],
            "cppStandard": "gnu++14",
            "compilerPath": "C:/Users/User/.platformio/packages/toolchain-gccarmnoneeabi@1.50401.190816/bin/arm-none-eabi-gcc.exe",
            "compilerArgs": [
                "-mthumb",
                "-mcpu=cortex-m7",
                "-mfloat-abi=hard",
                "-mfpu=fpv5-d16",
                ""
            ]
        }
    ],
    "version": 4
}

[@file: .vscode/extensions.json]
{
    // See http://go.microsoft.com/fwlink/?LinkId=827846
    // for the documentation about the extensions.json format
    "recommendations": [
        "platformio.platformio-ide"
    ],
    "unwantedRecommendations": [
        "ms-vscode.cpptools-extension-pack"
    ]
}

[@file: .vscode/launch.json]
// AUTOMATICALLY GENERATED FILE. PLEASE DO NOT MODIFY IT MANUALLY
//
// PIO Unified Debugger
//
// Documentation: https://docs.platformio.org/page/plus/debugging.html
// Configuration: https://docs.platformio.org/page/projectconf/section_env_debug.html

{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "platformio-debug",
            "request": "launch",
            "name": "PIO Debug",
            "executable": "c:/Users/User/Documents/PlatformIO/Projects/Test Keyboard/.pio/build/teensy41/firmware.elf",
            "projectEnvName": "teensy41",
            "toolchainBinDir": "C:/Users/User/.platformio/packages/toolchain-gccarmnoneeabi@1.50401.190816/bin",
            "internalConsoleOptions": "openOnSessionStart",
            "preLaunchTask": {
                "type": "PlatformIO",
                "task": "Pre-Debug"
            }
        },
        {
            "type": "platformio-debug",
            "request": "launch",
            "name": "PIO Debug (skip Pre-Debug)",
            "executable": "c:/Users/User/Documents/PlatformIO/Projects/Test Keyboard/.pio/build/teensy41/firmware.elf",
            "projectEnvName": "teensy41",
            "toolchainBinDir": "C:/Users/User/.platformio/packages/toolchain-gccarmnoneeabi@1.50401.190816/bin",
            "internalConsoleOptions": "openOnSessionStart"
        },
        {
            "type": "platformio-debug",
            "request": "launch",
            "name": "PIO Debug (without uploading)",
            "executable": "c:/Users/User/Documents/PlatformIO/Projects/Test Keyboard/.pio/build/teensy41/firmware.elf",
            "projectEnvName": "teensy41",
            "toolchainBinDir": "C:/Users/User/.platformio/packages/toolchain-gccarmnoneeabi@1.50401.190816/bin",
            "internalConsoleOptions": "openOnSessionStart",
            "loadMode": "manual"
        }
    ]
}

[@file: include/EXTString.h]
/*
  WEXTString.h - EXTString library for Wiring & Arduino
  ...mostly rewritten by Paul Stoffregen...
  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
  Copyright 2011, Paul Stoffregen, paul@pjrc.com

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#ifndef EXTString_class_h
#define EXTString_class_h
#ifdef __cplusplus

#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "avr_functions.h"

// Not needed here, but some libs assume WEXTString.h or Print.h
// gives them PROGMEM and other AVR stuff.
#include "avr/pgmspace.h"

// When compiling programs with this class, the following gcc parameters
// dramatically increase performance and memory (RAM) efficiency, typically
// with little or no increase in code size.
//     -felide-constructors
//     -std=c++0x

// Brian Cook's "no overhead" Flash EXTString type (message on Dec 14, 2010)
// modified by Mikal Hart for his FlashEXTString library
class __FlashEXTStringHelper;
#ifndef F
#define F(EXTString_literal) ((const __FlashEXTStringHelper *)(EXTString_literal))
#endif

// An inherited class for holding the result of a concatenation.  These
// result objects are assumed to be writable by subsequent concatenations.
class EXTStringSumHelper;

// The EXTString class
class EXTString
{
public:
    // constructors
    EXTString(const char *cstr = (const char *)NULL);
    EXTString(const __FlashEXTStringHelper *pgmstr);
    EXTString(const EXTString &str);
    #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
    EXTString(EXTString &&rval);
    EXTString(EXTStringSumHelper &&rval);
    #endif
    EXTString(char c);
    EXTString(unsigned char c);
    EXTString(int, unsigned char base=10);
    EXTString(unsigned int, unsigned char base=10);
    EXTString(long, unsigned char base=10);
    EXTString(unsigned long, unsigned char base=10);
        EXTString(float num, unsigned char digits=2);
    EXTString(double num, unsigned char digits=2) : EXTString((float)num, digits) {}
    ~EXTString(void);

    // memory management
    unsigned char reserve(unsigned int size);
    inline unsigned int length(void) const {return len;}

    // copy and move
    EXTString & copy(const char *cstr, unsigned int length);
    EXTString & copy(const __FlashEXTStringHelper *s) { return copy((const char *)s, strlen((const char *)s)); }
    void move(EXTString &rhs);
    EXTString & operator = (const EXTString &rhs);
    EXTString & operator = (const char *cstr);
    EXTString & operator = (const __FlashEXTStringHelper *pgmstr);
    #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
    EXTString & operator = (EXTString &&rval);
    EXTString & operator = (EXTStringSumHelper &&rval);
    #endif
    EXTString & operator = (char c);

    // append
    EXTString & append(const EXTString &str);
    EXTString & append(const char *cstr);
    EXTString & append(const __FlashEXTStringHelper *s)    {return append((const char *)s, strlen((const char *)s)); }
    EXTString & append(char c);
    EXTString & append(unsigned char c)        {return append((int)c);}
    EXTString & append(int num);
    EXTString & append(unsigned int num);
    EXTString & append(long num);
    EXTString & append(unsigned long num);
    EXTString & append(float num);
    EXTString & append(double num)            {return append((float)num);}
    EXTString & operator += (const EXTString &rhs)    {return append(rhs);}
    EXTString & operator += (const char *cstr)        {return append(cstr);}
    EXTString & operator += (const __FlashEXTStringHelper *pgmstr) {return append(pgmstr);}
    EXTString & operator += (char c)            {return append(c);}
    EXTString & operator += (unsigned char c)        {return append((int)c);}
    EXTString & operator += (int num)            {return append(num);}
    EXTString & operator += (unsigned int num)        {return append(num);}
    EXTString & operator += (long num)            {return append(num);}
    EXTString & operator += (unsigned long num)    {return append(num);}
    EXTString & operator += (float num)        {return append(num);}
    EXTString & operator += (double num)        {return append(num);}

    // concatenate
    friend EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, const EXTString &rhs);
    friend EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, const char *cstr);
    friend EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, const __FlashEXTStringHelper *pgmstr);
    friend EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, char c);
    friend EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, unsigned char c);
    friend EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, int num);
    friend EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, unsigned int num);
    friend EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, long num);
    friend EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, unsigned long num);
    friend EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, float num);
    friend EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, double num);
    EXTString & concat(const EXTString &str)        {return append(str);}
    EXTString & concat(const char *cstr)        {return append(cstr);}
    EXTString & concat(const __FlashEXTStringHelper *pgmstr) {return append(pgmstr);}
    EXTString & concat(char c)                {return append(c);}
    EXTString & concat(unsigned char c)        {return append((int)c);}
    EXTString & concat(int num)            {return append(num);}
    EXTString & concat(unsigned int num)        {return append(num);}
    EXTString & concat(long num)            {return append(num);}
    EXTString & concat(unsigned long num)        {return append(num);}
    EXTString & concat(float num)            {return append(num);}
    EXTString & concat(double num)            {return append(num);}

    // comparison
    int compareTo(const EXTString &s) const;
    unsigned char equals(const EXTString &s) const;
    unsigned char equals(const char *cstr) const;
    //unsigned char equals(const __FlashEXTStringHelper *pgmstr) const;
    unsigned char operator == (const EXTString &rhs) const {return equals(rhs);}
    unsigned char operator == (const char *cstr) const {return equals(cstr);}
    unsigned char operator != (const EXTString &rhs) const {return !equals(rhs);}
    unsigned char operator != (const char *cstr) const {return !equals(cstr);}
    unsigned char operator <  (const EXTString &rhs) const;
    unsigned char operator >  (const EXTString &rhs) const;
    unsigned char operator <= (const EXTString &rhs) const;
    unsigned char operator >= (const EXTString &rhs) const;
    unsigned char equalsIgnoreCase(const EXTString &s) const;
    unsigned char startsWith( const EXTString &prefix) const;
    unsigned char startsWith(const EXTString &prefix, unsigned int offset) const;
    unsigned char endsWith(const EXTString &suffix) const;

    // character acccess
    char charAt(unsigned int index) const;
    void setCharAt(unsigned int index, char c);
    char operator [] (unsigned int index) const;
    char& operator [] (unsigned int index);
    void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index=0) const;
    void toCharArray(char *buf, unsigned int bufsize, unsigned int index=0) const
        {getBytes((unsigned char *)buf, bufsize, index);}
    const char * c_str() const {
        if (!buffer) return &zerotermination; // https://forum.pjrc.com/threads/63842
        return buffer;
    }
    char * begin() {
        if (!buffer) reserve(20);
        return buffer;
    }
    char * end() { return begin() + length(); }
    const char * begin() const { return c_str(); }
    const char * end() const { return c_str() + length(); }

    // search
    int indexOf( char ch ) const;
    int indexOf( char ch, unsigned int fromIndex ) const;
    int indexOf( const EXTString &str ) const;
    int indexOf( const EXTString &str, unsigned int fromIndex ) const;
    int lastIndexOf( char ch ) const;
    int lastIndexOf( char ch, unsigned int fromIndex ) const;
    int lastIndexOf( const EXTString &str ) const;
    int lastIndexOf( const EXTString &str, unsigned int fromIndex ) const;
    EXTString substring( unsigned int beginIndex ) const;
    EXTString substring( unsigned int beginIndex, unsigned int endIndex ) const;

    // modification
    EXTString & replace(char find, char replace);
    EXTString & replace(const EXTString& find, const EXTString& replace);
    EXTString & remove(unsigned int index);
    EXTString & remove(unsigned int index, unsigned int count);
    EXTString & toLowerCase(void);
    EXTString & toUpperCase(void);
    EXTString & trim(void);

    // parsing/conversion
    long toInt(void) const;
    float toFloat(void) const;

protected:
    char *buffer;            // the actual char array
    unsigned int capacity;  // the array length minus one (for the '\0')
    unsigned int len;       // the EXTString length (not counting the '\0')
    unsigned char flags;    // unused, for future features
protected:
    void init(void);
    unsigned char changeBuffer(unsigned int maxStrLen);
    EXTString & append(const char *cstr, unsigned int length);
private:
    // allow for "if (s)" without the complications of an operator bool().
    // for more information http://www.artima.com/cppsource/safebool.html
    typedef void (EXTString::*EXTStringIfHelperType)() const;
    void EXTStringIfHelper() const {}
    static const char zerotermination;
public:
    operator EXTStringIfHelperType() const { return buffer ? &EXTString::EXTStringIfHelper : 0; }
};

class EXTStringSumHelper : public EXTString
{
public:
    EXTStringSumHelper(const EXTString &s) : EXTString(s) {}
    EXTStringSumHelper(const char *p) : EXTString(p) {}
    EXTStringSumHelper(const __FlashEXTStringHelper *pgmstr) : EXTString(pgmstr) {}
    EXTStringSumHelper(char c) : EXTString(c) {}
    EXTStringSumHelper(unsigned char c) : EXTString(c) {}
    EXTStringSumHelper(int num) : EXTString(num, 10) {}
    EXTStringSumHelper(unsigned int num) : EXTString(num, 10) {}
    EXTStringSumHelper(long num) : EXTString(num, 10) {}
    EXTStringSumHelper(unsigned long num) : EXTString(num, 10) {}
};

#endif  // __cplusplus
#endif  // EXTString_class_h

[@file: include/filesystem.h]
#ifndef FILESYSTEM_H
#define FILESYSTEM_H

#include <Arduino.h>

#include <LittleFS.h>
#include "EXTString.h"

extern LittleFS_Program myfs;
extern uint32_t diskSize;

#define PROG_FLASH_SIZE                                                        \
    1024 * 1024 * 4 // Specify size to use of onboard Teensy Program Flash chip
                    // This creates a LittleFS drive in Teensy PCB FLash.

int loadFileToStr(const char* filePath, EXTString& str, LittleFS_Program& fs = myfs);
int saveStrToFile(const char* filePath, EXTString& str, LittleFS_Program& fs = myfs);
int disk_init(uint32_t size = PROG_FLASH_SIZE, LittleFS_Program& fs = myfs);


#endif // FILESYSTEM_H
[@file: include/HIDKeyboard.h]
/*
  Keyboard.h

  Copyright (c) 2015, Arduino LLC
  Original code (pre-library): Copyright (c) 2011, Peter Barrett

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#pragma once
#include <Arduino.h>

typedef union {
    struct {
            uint8_t numlock:1;
            uint8_t capslock:1;
            uint8_t scrolllock:1;
            uint8_t compose:1;
            uint8_t kana:1;
            uint8_t reserved:3;
    };
    uint8_t leds;
} arduino_usb_hid_keyboard_event_data_t;

// Power Control
#define CONSUMER_CONTROL_POWER                             0x0030
#define CONSUMER_CONTROL_RESET                             0x0031
#define CONSUMER_CONTROL_SLEEP                             0x0032

// Screen Brightness
#define CONSUMER_CONTROL_BRIGHTNESS_INCREMENT              0x006F
#define CONSUMER_CONTROL_BRIGHTNESS_DECREMENT              0x0070

// These HID usages operate only on mobile systems (battery powered) and
// require Windows 8 (build 8302 or greater).
#define CONSUMER_CONTROL_WIRELESS_RADIO_CONTROLS           0x000C
#define CONSUMER_CONTROL_WIRELESS_RADIO_BUTTONS            0x00C6
#define CONSUMER_CONTROL_WIRELESS_RADIO_LED                0x00C7
#define CONSUMER_CONTROL_WIRELESS_RADIO_SLIDER_SWITCH      0x00C8

// Media Control
#define CONSUMER_CONTROL_PLAY_PAUSE                        0x00CD
#define CONSUMER_CONTROL_SCAN_NEXT                         0x00B5
#define CONSUMER_CONTROL_SCAN_PREVIOUS                     0x00B6
#define CONSUMER_CONTROL_STOP                              0x00B7
#define CONSUMER_CONTROL_VOLUME                            0x00E0
#define CONSUMER_CONTROL_MUTE                              0x00E2
#define CONSUMER_CONTROL_BASS                              0x00E3
#define CONSUMER_CONTROL_TREBLE                            0x00E4
#define CONSUMER_CONTROL_BASS_BOOST                        0x00E5
#define CONSUMER_CONTROL_VOLUME_INCREMENT                  0x00E9
#define CONSUMER_CONTROL_VOLUME_DECREMENT                  0x00EA
#define CONSUMER_CONTROL_BASS_INCREMENT                    0x0152
#define CONSUMER_CONTROL_BASS_DECREMENT                    0x0153
#define CONSUMER_CONTROL_TREBLE_INCREMENT                  0x0154
#define CONSUMER_CONTROL_TREBLE_DECREMENT                  0x0155

// Application Launcher
#define CONSUMER_CONTROL_CONFIGURATION                     0x0183
#define CONSUMER_CONTROL_EMAIL_READER                      0x018A
#define CONSUMER_CONTROL_CALCULATOR                        0x0192
#define CONSUMER_CONTROL_LOCAL_BROWSER                     0x0194

// Browser/Explorer Specific
#define CONSUMER_CONTROL_SEARCH                            0x0221
#define CONSUMER_CONTROL_HOME                              0x0223
#define CONSUMER_CONTROL_BACK                              0x0224
#define CONSUMER_CONTROL_FORWARD                           0x0225
#define CONSUMER_CONTROL_BR_STOP                           0x0226
#define CONSUMER_CONTROL_REFRESH                           0x0227
#define CONSUMER_CONTROL_BOOKMARKS                         0x022A

// Mouse Horizontal scroll
#define CONSUMER_CONTROL_PAN                               0x0238

#define CC_BIT_0 CONSUMER_CONTROL_SCAN_NEXT
#define CC_BIT_1 CONSUMER_CONTROL_SCAN_PREVIOUS
#define CC_BIT_2 CONSUMER_CONTROL_STOP
#define CC_BIT_3 CONSUMER_CONTROL_PLAY_PAUSE
#define CC_BIT_4 CONSUMER_CONTROL_MUTE
#define CC_BIT_5 CONSUMER_CONTROL_VOLUME_INCREMENT
#define CC_BIT_6 CONSUMER_CONTROL_VOLUME_DECREMENT
#define CC_BIT_7 CONSUMER_CONTROL_HOME
#define CC_BIT_8 CONSUMER_CONTROL_LOCAL_BROWSER
#define CC_BIT_9 CONSUMER_CONTROL_CALCULATOR
#define CC_BIT_A CONSUMER_CONTROL_BRIGHTNESS_DECREMENT
#define CC_BIT_B CONSUMER_CONTROL_BRIGHTNESS_INCREMENT
#define CC_BIT_C CONSUMER_CONTROL_BR_STOP
#define CC_BIT_D CONSUMER_CONTROL_BACK
#define CC_BIT_E CONSUMER_CONTROL_CONFIGURATION
#define CC_BIT_F CONSUMER_CONTROL_EMAIL_READER

#define M_KEY_TYPE_MASK        ((uint32_t)0xffff0000UL)
#define M_KEY_TARGET_MASK      ((uint32_t)0xC0000000UL)

#define M_KEY_TARGET_KB       ((uint32_t)0x40000000UL)
#define M_KEY_TARGET_CC       ((uint32_t)0x80000000UL)

#define M_KEY_TYPE_MODIF      (M_KEY_TARGET_KB | (uint32_t)0x01000000UL)
#define M_KEY_TYPE_NONPRINT   (M_KEY_TARGET_KB | (uint32_t)0x02000000UL)
#define M_KEY_TYPE_KEYPAD     (M_KEY_TARGET_KB | (uint32_t)0x04000000UL)
#define SHIFT               (M_KEY_TARGET_KB | (uint32_t)0x08000000UL)

#define M_KEY_LEFT_CTRL       (M_KEY_TYPE_MODIF | (uint32_t)0x01UL)
#define M_KEY_LEFT_SHIFT      (M_KEY_TYPE_MODIF | (uint32_t)0x02UL)
#define M_KEY_LEFT_ALT        (M_KEY_TYPE_MODIF | (uint32_t)0x04UL)
#define M_KEY_LEFT_GUI        (M_KEY_TYPE_MODIF | (uint32_t)0x08UL)
#define M_KEY_RIGHT_CTRL      (M_KEY_TYPE_MODIF | (uint32_t)0x10UL)
#define M_KEY_RIGHT_SHIFT     (M_KEY_TYPE_MODIF | (uint32_t)0x20UL)
#define M_KEY_RIGHT_ALT       (M_KEY_TYPE_MODIF | (uint32_t)0x40UL)
#define M_KEY_RIGHT_GUI       (M_KEY_TYPE_MODIF | (uint32_t)0x80UL)

#define M_KEY_UP_ARROW        (M_KEY_TYPE_NONPRINT | (uint32_t)0x0052UL)
#define M_KEY_DOWN_ARROW      (M_KEY_TYPE_NONPRINT | (uint32_t)0x0051UL)
#define M_KEY_LEFT_ARROW      (M_KEY_TYPE_NONPRINT | (uint32_t)0x0050UL)
#define M_KEY_RIGHT_ARROW     (M_KEY_TYPE_NONPRINT | (uint32_t)0x004fUL)
#define M_KEY_BACKSPACE       (M_KEY_TYPE_NONPRINT | (uint32_t)0x002aUL)
#define M_KEY_TAB             (M_KEY_TYPE_NONPRINT | (uint32_t)0x002bUL)
#define M_KEY_RETURN          (M_KEY_TYPE_NONPRINT | (uint32_t)0x0028UL)
#define M_KEY_ESC             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0029UL)
#define M_KEY_INSERT          (M_KEY_TYPE_NONPRINT | (uint32_t)0x0049UL)
#define M_KEY_PRTSC           (M_KEY_TYPE_NONPRINT | (uint32_t)0x0046UL)
#define M_KEY_DELETE          (M_KEY_TYPE_NONPRINT | (uint32_t)0x004cUL)
#define M_KEY_PAGE_UP         (M_KEY_TYPE_NONPRINT | (uint32_t)0x004bUL)
#define M_KEY_PAGE_DOWN       (M_KEY_TYPE_NONPRINT | (uint32_t)0x004eUL)
#define M_KEY_HOME            (M_KEY_TYPE_NONPRINT | (uint32_t)0x004aUL)
#define M_KEY_END             (M_KEY_TYPE_NONPRINT | (uint32_t)0x004dUL)
#define M_KEY_CAPS_LOCK       (M_KEY_TYPE_NONPRINT | (uint32_t)0x0039UL)
#define M_KEY_NUM_LOCK        (M_KEY_TYPE_NONPRINT | (uint32_t)0x0053UL)

#define M_KEY_F1              (M_KEY_TYPE_NONPRINT | (uint32_t)0x003aUL)
#define M_KEY_F2              (M_KEY_TYPE_NONPRINT | (uint32_t)0x003bUL)
#define M_KEY_F3              (M_KEY_TYPE_NONPRINT | (uint32_t)0x003cUL)
#define M_KEY_F4              (M_KEY_TYPE_NONPRINT | (uint32_t)0x003dUL)
#define M_KEY_F5              (M_KEY_TYPE_NONPRINT | (uint32_t)0x003eUL)
#define M_KEY_F6              (M_KEY_TYPE_NONPRINT | (uint32_t)0x003fUL)
#define M_KEY_F7              (M_KEY_TYPE_NONPRINT | (uint32_t)0x0040UL)
#define M_KEY_F8              (M_KEY_TYPE_NONPRINT | (uint32_t)0x0041UL)
#define M_KEY_F9              (M_KEY_TYPE_NONPRINT | (uint32_t)0x0042UL)
#define M_KEY_F10             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0043UL)
#define M_KEY_F11             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0044UL)
#define M_KEY_F12             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0045UL)
#define M_KEY_PRTSC           (M_KEY_TYPE_NONPRINT | (uint32_t)0x0046UL)
#define M_KEY_F13             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0068UL)
#define M_KEY_F14             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0069UL)
#define M_KEY_F15             (M_KEY_TYPE_NONPRINT | (uint32_t)0x006aUL)
#define M_KEY_F16             (M_KEY_TYPE_NONPRINT | (uint32_t)0x006bUL)
#define M_KEY_F17             (M_KEY_TYPE_NONPRINT | (uint32_t)0x006cUL)
#define M_KEY_F18             (M_KEY_TYPE_NONPRINT | (uint32_t)0x006dUL)
#define M_KEY_F19             (M_KEY_TYPE_NONPRINT | (uint32_t)0x006eUL)
#define M_KEY_F20             (M_KEY_TYPE_NONPRINT | (uint32_t)0x006fUL)
#define M_KEY_F21             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0070UL)
#define M_KEY_F22             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0071UL)
#define M_KEY_F23             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0072UL)
#define M_KEY_F24             (M_KEY_TYPE_NONPRINT | (uint32_t)0x0073UL)

#define M_KEY_NUM_0           (M_KEY_TYPE_KEYPAD | (uint32_t)0x0062UL)
#define M_KEY_NUM_1           (M_KEY_TYPE_KEYPAD | (uint32_t)0x0059UL)
#define M_KEY_NUM_2           (M_KEY_TYPE_KEYPAD | (uint32_t)0x005aUL)
#define M_KEY_NUM_3           (M_KEY_TYPE_KEYPAD | (uint32_t)0x005bUL)
#define M_KEY_NUM_4           (M_KEY_TYPE_KEYPAD | (uint32_t)0x005cUL)
#define M_KEY_NUM_5           (M_KEY_TYPE_KEYPAD | (uint32_t)0x005dUL)
#define M_KEY_NUM_6           (M_KEY_TYPE_KEYPAD | (uint32_t)0x005eUL)
#define M_KEY_NUM_7           (M_KEY_TYPE_KEYPAD | (uint32_t)0x005fUL)
#define M_KEY_NUM_8           (M_KEY_TYPE_KEYPAD | (uint32_t)0x0060UL)
#define M_KEY_NUM_9           (M_KEY_TYPE_KEYPAD | (uint32_t)0x0061UL)
#define M_KEY_NUM_SLASH       (M_KEY_TYPE_KEYPAD | (uint32_t)0x0054UL)
#define M_KEY_NUM_ASTERISK    (M_KEY_TYPE_KEYPAD | (uint32_t)0x0055UL)
#define M_KEY_NUM_MINUS       (M_KEY_TYPE_KEYPAD | (uint32_t)0x0056UL)
#define M_KEY_NUM_PLUS        (M_KEY_TYPE_KEYPAD | (uint32_t)0x0057UL)
#define M_KEY_NUM_ENTER       (M_KEY_TYPE_KEYPAD | (uint32_t)0x0058UL)
#define M_KEY_NUM_PERIOD      (M_KEY_TYPE_KEYPAD | (uint32_t)0x0063UL)
#define M_KEY_NUM_EQUAL       (M_KEY_TYPE_KEYPAD | (uint32_t)0x0067UL)


typedef uint32_t MediaKeyReport;

#define M_KEY_MEDIA_NEXT              (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x0U))
#define M_KEY_MEDIA_PREV              (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x1U))
#define M_KEY_MEDIA_STOP              (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x2U))
#define M_KEY_MEDIA_PAUSE             (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x3U))
#define M_KEY_MEDIA_MUTE              (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x4U))
#define M_KEY_MEDIA_VOLUP             (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x5U))
#define M_KEY_MEDIA_VOLDN             (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x6U))
#define M_KEY_MEDIA_WWW_HOME          (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x7U))

#define M_KEY_FILE_EXPLORER           (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x8U))
#define M_KEY_MEDIA_CALC              (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0x9U))
#define M_KEY_MEDIA_BRIGHTNESS_D      (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0xAU))
#define M_KEY_MEDIA_BRIGHTNESS_I      (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0xBU))
#define M_KEY_MEDIA_WWW_STOP          (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0xCU))
#define M_KEY_MEDIA_WWW_BACK          (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0xDU))
#define M_KEY_CONSUMER_CTL            (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0xEU))
#define M_KEY_MEDIA_EMAIL             (M_KEY_TARGET_CC | (MediaKeyReport) (1UL << 0xFU))

#define STR_LEFT_CTRL "\x80"
#define STR_LEFT_SHIFT "\x81"
#define STR_LEFT_ALT "\x82"
#define STR_LEFT_GUI "\x83"
#define STR_RIGHT_CTRL "\x84"
#define STR_RIGHT_SHIFT "\x85"
#define STR_RIGHT_ALT "\x86"
#define STR_RIGHT_GUI "\x87"
#define STR_UP_ARROW "\x88"
#define STR_DOWN_ARROW "\x89"
#define STR_LEFT_ARROW "\x8a"
#define STR_RIGHT_ARROW "\x8b"
#define STR_BACKSPACE "\x8c"
#define STR_TAB "\x8d"
#define STR_RETURN "\x8e"
#define STR_ESC "\x8f"
#define STR_INSERT "\x90"
#define STR_PRTSC "\x91"
#define STR_DELETE "\x92"
#define STR_PAGE_UP "\x93"
#define STR_PAGE_DOWN "\x94"
#define STR_HOME "\x95"
#define STR_END "\x96"
#define STR_CAPS_LOCK "\x97"
#define STR_NUM_LOCK "\x98"
#define STR_F1 "\x99"
#define STR_F2 "\x9a"
#define STR_F3 "\x9b"
#define STR_F4 "\x9c"
#define STR_F5 "\x9d"
#define STR_F6 "\x9e"
#define STR_F7 "\x9f"
#define STR_F8 "\xa0"
#define STR_F9 "\xa1"
#define STR_F10 "\xa2"
#define STR_F11 "\xa3"
#define STR_F12 "\xa4"
#define STR_F13 "\xa5"
#define STR_F14 "\xa6"
#define STR_F15 "\xa7"
#define STR_F16 "\xa8"
#define STR_F17 "\xa9"
#define STR_F18 "\xaa"
#define STR_F19 "\xab"
#define STR_F20 "\xac"
#define STR_F21 "\xad"
#define STR_F22 "\xae"
#define STR_F23 "\xaf"
#define STR_F24 "\xb0"
#define STR_NUM_0 "\xb1"
#define STR_NUM_1 "\xb2"
#define STR_NUM_2 "\xb3"
#define STR_NUM_3 "\xb4"
#define STR_NUM_4 "\xb5"
#define STR_NUM_5 "\xb6"
#define STR_NUM_6 "\xb7"
#define STR_NUM_7 "\xb8"
#define STR_NUM_8 "\xb9"
#define STR_NUM_9 "\xba"
#define STR_NUM_SLASH "\xbb"
#define STR_NUM_ASTERISK "\xbc"
#define STR_NUM_MINUS "\xbd"
#define STR_NUM_PLUS "\xbe"
#define STR_NUM_ENTER "\xbf"
#define STR_NUM_PERIOD "\xc0"
#define STR_NUM_EQUAL "\xc1"
#define STR_MEDIA_NEXT "\xc2"
#define STR_MEDIA_PREV "\xc3"
#define STR_MEDIA_STOP "\xc4"
#define STR_MEDIA_PAUSE "\xc5"
#define STR_MEDIA_MUTE "\xc6"
#define STR_MEDIA_VOLUP "\xc7"
#define STR_MEDIA_VOLDN "\xc8"
#define STR_MEDIA_WWW_HOME "\xc9"
#define STR_FILE_EXPLORER "\xca"
#define STR_MEDIA_CALC "\xcb"
#define STR_MEDIA_BRIGHTNESS_D "\xcc"
#define STR_MEDIA_BRIGHTNESS_I "\xcd"
#define STR_MEDIA_WWW_STOP "\xce"
#define STR_MEDIA_WWW_BACK "\xcf"
#define STR_CONSUMER_CTL "\xd0"
#define STR_MEDIA_EMAIL "\xd1"

#define LED_NUMLOCK     0x01
#define LED_CAPSLOCK    0x02
#define LED_SCROLLLOCK  0x04
#define LED_COMPOSE     0x08
#define LED_KANA        0x10

//  Low level key report: up to 6 keys and shift, ctrl etc at once
typedef struct
{
  uint8_t modifiers;
  uint8_t reserved;
  uint8_t keys[62];
} KeyReport;

class Reports {
protected:
    KeyReport _keyReport;
    uint16_t _cc_report;
public:
    Reports() : _cc_report(0) {
        memset(&_keyReport, 0, sizeof(_keyReport));
    }
    const KeyReport& getKeyReport() const {return _keyReport;}
    const uint16_t& getCCReport() const {return _cc_report;}
    uint32_t pressRaw(uint32_t k);
    uint32_t releaseRaw(uint32_t k);
    uint32_t press(uint8_t data);
    uint32_t release(uint8_t data);
    uint32_t pressMulti(const uint8_t* data);
    uint32_t releaseMulti(const uint8_t* data);
    void sendKeyReport();
    void releaseAll();
};



[@file: include/kbcontrol.h]
#ifndef KBCONTROL_H
#define KBCONTROL_H

#include <Arduino.h>
#include "EXTString.h"
#include "filesystem.h"
#include "psramctrl.h"

extern EXTString rx_str;
extern EXTString tx_str;
extern bool tx_lock;
extern uint32_t kb_delay;
extern uint32_t type_pos;

void process_char(Stream& st, char c);
void process_char_loop(Stream& st);
void memory_test(Stream& st);

#endif
[@file: include/psramctrl.h]
#ifndef PSRAMCTRL_H
#define PSRAMCTRL_H

#include <Arduino.h>
#include "static_malloc.h"
#include <vector>
#include <algorithm>

typedef struct {
    float frq;
    uint32_t mask;
} clock_info;

// EXTMEM POOL
#define EXTMEM_SIZE 0x700000UL
extern std::vector<clock_info> ram_clock_sel_psc;

#define CBCMR_BIT_MASK ((7UL << 29U) | (3UL << 8U)) 

void print_ram_speeds(Stream& st);

float clock_source(int i);

void psram_clock_speed_set(uint16_t index);

float psram_clock_speed_get();

int psram_init();

#endif // PSRAMCTRL_H
[@file: include/README]

This directory is intended for project header files.

A header file is a file containing C declarations and macro definitions
to be shared between several project source files. You request the use of a
header file in your project source file (C, C++, etc) located in `src` folder
by including it, with the C preprocessing directive `#include'.

```src/main.c

#include "header.h"

int main (void)
{
 ...
}
```

Including a header file produces the same results as copying the header file
into each source file that needs it. Such copying would be time-consuming
and error-prone. With a header file, the related declarations appear
in only one place. If they need to be changed, they can be changed in one
place, and programs that include the header file will automatically use the
new version when next recompiled. The header file eliminates the labor of
finding and changing all the copies as well as the risk that a failure to
find one copy will result in inconsistencies within a program.

In C, the usual convention is to give header files names that end with `.h'.
It is most portable to use only letters, digits, dashes, and underscores in
header file names, and at most one dot.

Read more about using header files in official GCC documentation:

* Include Syntax
* Include Operation
* Once-Only Headers
* Computed Includes

https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html

[@file: include/text.h]
#ifndef TEXT_H
#define TEXT_H

#include <stdint.h>

extern unsigned char txt[];
extern unsigned long long size_txt;

#endif // TEXT_H
[@file: lib/README]

[@file: lib/src/static_malloc.h]
#pragma once

extern "C" {
#include "smalloc/smalloc.h"
}


[@file: lib/src/smalloc/COPYRIGHT]
Copyright © 2017 Andrey Rys.
All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

[@file: lib/src/smalloc/README]
https://github.com/luni64/static_malloc.git
[@file: lib/src/smalloc/smalloc.h]
/*
 * SMalloc -- a *static* memory allocator.
 *
 * See README for a complete description.
 *
 * SMalloc is MIT licensed.
 * Copyright (c) 2017 Andrey Rys.
 * Written during Aug2017.
 */

#ifndef _SMALLOC_H
#define _SMALLOC_H

#include <stddef.h>
#include <stdint.h>

struct smalloc_pool;

typedef size_t (*smalloc_oom_handler)(struct smalloc_pool *, size_t);

/* describes static pool, if you're going to use multiple pools at same time */
struct smalloc_pool {
    void *pool; /* pointer to your pool */
    size_t pool_size; /* it's size. Must be aligned with sm_align_pool. */
    int do_zero; /* zero pool before use and all the new allocations from it. */
    smalloc_oom_handler oomfn; /* this will be called, if non-NULL, on OOM condition in pool */
};

/* a default one which is initialised with sm_set_default_pool. */
extern struct smalloc_pool smalloc_curr_pool;

/* undefined behavior handler is called on typical malloc UB situations */
typedef void (*smalloc_ub_handler)(struct smalloc_pool *, const void *);

void sm_set_ub_handler(smalloc_ub_handler);

int sm_align_pool(struct smalloc_pool *);
int sm_set_pool(struct smalloc_pool *, void *, size_t, int, smalloc_oom_handler);
int sm_set_default_pool(void *, size_t, int, smalloc_oom_handler);
int sm_release_pool(struct smalloc_pool *);
int sm_release_default_pool(void);

/* Use these with multiple pools which you control */

void *sm_malloc_pool(struct smalloc_pool *, size_t);
void *sm_zalloc_pool(struct smalloc_pool *, size_t);
void sm_free_pool(struct smalloc_pool *, void *);

void *sm_realloc_pool(struct smalloc_pool *, void *, size_t);
void *sm_realloc_move_pool(struct smalloc_pool *, void *, size_t);
void *sm_calloc_pool(struct smalloc_pool *, size_t, size_t);

int sm_alloc_valid_pool(struct smalloc_pool *spool, const void *p);

size_t sm_szalloc_pool(struct smalloc_pool *, const void *);
int sm_malloc_stats_pool(struct smalloc_pool *, size_t *, size_t *, size_t *, int *);

/* Use these when you use just default smalloc_curr_pool pool */

void *sm_malloc(size_t);
void *sm_zalloc(size_t); /* guarantee zero memory allocation */
void sm_free(void *);

void *sm_realloc(void *, size_t);
void *sm_realloc_move(void *, size_t);
void *sm_calloc(size_t, size_t); /* calls zalloc internally */

int sm_alloc_valid(const void *p); /* verify pointer without intentional crash */

size_t sm_szalloc(const void *); /* get size of allocation */
/*
 * get stats: total used, user used, total free, nr. of allocated blocks.
 * any of pointers maybe set to NULL, but at least one must be non NULL.
 */
int sm_malloc_stats(size_t *, size_t *, size_t *, int *);

#endif

[@file: lib/src/smalloc/smalloc_i.h]
/*
 * This file is a part of SMalloc.
 * SMalloc is MIT licensed.
 * Copyright (c) 2017 Andrey Rys.
 */

#ifndef _SMALLOC_I_H
#define _SMALLOC_I_H

#include "smalloc.h"
#include <string.h>
#include <limits.h>
#include <errno.h>

struct smalloc_hdr {
    size_t rsz; /* real allocated size with overhead (if any) */
    size_t usz; /* exact user size as reported by s_szalloc */
    uintptr_t tag; /* sum of all the above, hashed value */
};

#define HEADER_SZ (sizeof(struct smalloc_hdr))
#define MIN_POOL_SZ (HEADER_SZ*20)

#define VOID_PTR(p) ((void *)p)
#define CHAR_PTR(p) ((char *)p)
#define PTR_UINT(p) ((uintptr_t)VOID_PTR(p))
#define HEADER_PTR(p) ((struct smalloc_hdr *)p)
#define USER_TO_HEADER(p) (HEADER_PTR((CHAR_PTR(p)-HEADER_SZ)))
#define HEADER_TO_USER(p) (VOID_PTR((CHAR_PTR(p)+HEADER_SZ)))

extern smalloc_ub_handler smalloc_UB;

uintptr_t smalloc_uinthash(uintptr_t x);
uintptr_t smalloc_mktag(struct smalloc_hdr *shdr);
int smalloc_verify_pool(struct smalloc_pool *spool);
int smalloc_is_alloc(struct smalloc_pool *spool, struct smalloc_hdr *shdr);

void *sm_realloc_pool_i(struct smalloc_pool *spool, void *p, size_t n, int nomove);

#endif

[@file: lib/src/smalloc/sm_alloc_valid.c]
/*
 * This file is a part of SMalloc.
 * SMalloc is MIT licensed.
 * Copyright (c) 2017 Andrey Rys.
 */

#include "smalloc_i.h"

int sm_alloc_valid_pool(struct smalloc_pool *spool, const void *p)
{
    struct smalloc_hdr *shdr;

    if (!smalloc_verify_pool(spool)) {
        errno = EINVAL;
        return 0;
    }

    if (!p) return 0;

    shdr = USER_TO_HEADER(p);
    if (smalloc_is_alloc(spool, shdr)) return 1;
    return 0;
}

int sm_alloc_valid(const void *p)
{
    return sm_alloc_valid_pool(&smalloc_curr_pool, p);
}

[@file: lib/src/smalloc/sm_calloc.c]
/*
 * This file is a part of SMalloc.
 * SMalloc is MIT licensed.
 * Copyright (c) 2017 Andrey Rys.
 */

#include "smalloc_i.h"

void *sm_calloc_pool(struct smalloc_pool *spool, size_t x, size_t y)
{
    return sm_zalloc_pool(spool, x * y);
}

void *sm_calloc(size_t x, size_t y)
{
    return sm_calloc_pool(&smalloc_curr_pool, x, y);
}

[@file: lib/src/smalloc/sm_free.c]
/*
 * This file is a part of SMalloc.
 * SMalloc is MIT licensed.
 * Copyright (c) 2017 Andrey Rys.
 */

#include "smalloc_i.h"

void sm_free_pool(struct smalloc_pool *spool, void *p)
{
    struct smalloc_hdr *shdr;
    char *s;

    if (!smalloc_verify_pool(spool)) {
        errno = EINVAL;
        return;
    }

    if (!p) return;

    shdr = USER_TO_HEADER(p);
    if (smalloc_is_alloc(spool, shdr)) {
        if (spool->do_zero) memset(p, 0, shdr->rsz);
        s = CHAR_PTR(p);
        s += shdr->usz;
        memset(s, 0, HEADER_SZ);
        if (spool->do_zero) memset(s+HEADER_SZ, 0, shdr->rsz - shdr->usz);
        memset(shdr, 0, HEADER_SZ);
        return;
    }

    smalloc_UB(spool, p);
    return;
}

void sm_free(void *p)
{
    sm_free_pool(&smalloc_curr_pool, p);
}

[@file: lib/src/smalloc/sm_hash.c]
/*
 * This file is a part of SMalloc.
 * SMalloc is MIT licensed.
 * Copyright (c) 2017 Andrey Rys.
 */

#include "smalloc_i.h"

/* An adopted Jenkins one-at-a-time hash */
#define UIHOP(x, s) do {        \
        hash += (x >> s) & 0xff;\
        hash += hash << 10;    \
        hash ^= hash >> 6;    \
    } while (0)
uintptr_t smalloc_uinthash(uintptr_t x)
{
    uintptr_t hash = 0;

    UIHOP(x, 0);
    UIHOP(x, 8);
    UIHOP(x, 16);
    UIHOP(x, 24);

    hash += hash << 3;
    hash ^= hash >> 11;
    hash += hash << 15;

    return hash;
}
#undef UIHOP

uintptr_t smalloc_mktag(struct smalloc_hdr *shdr)
{
    uintptr_t r = smalloc_uinthash(PTR_UINT(shdr));
    r += shdr->rsz;
    r = smalloc_uinthash(r);
    r += shdr->usz;
    r = smalloc_uinthash(r);
    return r;
}

[@file: lib/src/smalloc/sm_malloc.c]
/*
 * This file is a part of SMalloc.
 * SMalloc is MIT licensed.
 * Copyright (c) 2017 Andrey Rys.
 */

#include "smalloc_i.h"

void *sm_malloc_pool(struct smalloc_pool *spool, size_t n)
{
    struct smalloc_hdr *basehdr, *shdr, *dhdr;
    char *s;
    int found;
    size_t x;

again:    if (!smalloc_verify_pool(spool)) {
        errno = EINVAL;
        return NULL;
    }

    if (n == 0) n++; /* return a block successfully */
    if (n > SIZE_MAX
    || n > (spool->pool_size - HEADER_SZ)) goto oom;

    shdr = basehdr = spool->pool;
    while (CHAR_PTR(shdr)-CHAR_PTR(basehdr) < spool->pool_size) {
        /*
         * Already allocated block.
         * Skip it by jumping over it.
         */
        if (smalloc_is_alloc(spool, shdr)) {
            s = CHAR_PTR(HEADER_TO_USER(shdr));
            s += shdr->rsz + HEADER_SZ;
            shdr = HEADER_PTR(s);
            continue;
        }
        /*
         * Free blocks ahead!
         * Do a second search over them to find out if they're
         * really large enough to fit the new allocation.
         */
        else {
            dhdr = shdr; found = 0;
            while (CHAR_PTR(dhdr)-CHAR_PTR(basehdr) < spool->pool_size) {
                /* pre calculate free block size */
                x = CHAR_PTR(dhdr)-CHAR_PTR(shdr);
                /*
                 * ugh, found next allocated block.
                 * skip this candidate then.
                 */
                if (smalloc_is_alloc(spool, dhdr))
                    goto allocblock;
                /*
                 * did not see allocated block yet,
                 * but this free block is of enough size
                 * - finally, use it.
                 */
                if (n + HEADER_SZ <= x) {
                    x -= HEADER_SZ;
                    found = 1;
                    goto outfound;
                }
                dhdr++;
            }

outfound:        if (found) {
                uintptr_t tag;
                /* allocate and return this block */
                shdr->rsz = x;
                shdr->usz = n;
                shdr->tag = tag = smalloc_mktag(shdr);
                if (spool->do_zero) memset(HEADER_TO_USER(shdr), 0, shdr->rsz);
                s = CHAR_PTR(HEADER_TO_USER(shdr));
                s += shdr->usz;
                for (x = 0;
                x < sizeof(struct smalloc_hdr);
                x += sizeof(uintptr_t)) {
                    tag = smalloc_uinthash(tag);
                    memcpy(s+x, &tag, sizeof(uintptr_t));
                }
                memset(s+x, 0xff, shdr->rsz - shdr->usz);
                return HEADER_TO_USER(shdr);
            }

            /* continue first search for next free block */
allocblock:        shdr = dhdr;
            continue;
        }

        shdr++;
    }

oom:    if (spool->oomfn) {
        x = spool->oomfn(spool, n);
        if (x > spool->pool_size) {
            spool->pool_size = x;
            if (sm_align_pool(spool)) goto again;
        }
    }

    errno = ENOMEM;
    return NULL;
}

void *sm_malloc(size_t n)
{
    return sm_malloc_pool(&smalloc_curr_pool, n);
}

[@file: lib/src/smalloc/sm_malloc_stats.c]
/*
 * This file is a part of SMalloc.
 * SMalloc is MIT licensed.
 * Copyright (c) 2017 Andrey Rys.
 */

#include "smalloc_i.h"

int sm_malloc_stats_pool(struct smalloc_pool *spool, size_t *total, size_t *user, size_t *free, int *nr_blocks)
{
    struct smalloc_hdr *shdr, *basehdr;
    int r = 0;

    if (!smalloc_verify_pool(spool)) {
        errno = EINVAL;
        return -1;
    }

    if (!total && !user && !free && !nr_blocks) return 0;

    if (total) *total = 0;
    if (user) *user = 0;
    if (free) *free = 0;
    if (nr_blocks) *nr_blocks = 0;

    shdr = basehdr = spool->pool;
    while (CHAR_PTR(shdr)-CHAR_PTR(basehdr) < spool->pool_size) {
        if (smalloc_is_alloc(spool, shdr)) {
            if (total) *total += HEADER_SZ + shdr->rsz + HEADER_SZ;
            if (user) *user += shdr->usz;
            if (nr_blocks) *nr_blocks += 1;
            r = 1;
        }

        shdr++;
    }

    *free = spool->pool_size - *total;

    return r;
}

int sm_malloc_stats(size_t *total, size_t *user, size_t *free, int *nr_blocks)
{
    return sm_malloc_stats_pool(&smalloc_curr_pool, total, user, free, nr_blocks);
}

[@file: lib/src/smalloc/sm_pool.c]
/*
 * This file is a part of SMalloc.
 * SMalloc is MIT licensed.
 * Copyright (c) 2017 Andrey Rys.
 */

#include "smalloc_i.h"

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
    if (!spool->pool || !spool->pool_size) return 0;
    if (spool->pool_size % HEADER_SZ) return 0;
    return 1;
}

int sm_align_pool(struct smalloc_pool *spool)
{
    size_t x;

    if (smalloc_verify_pool(spool)) return 1;

    x = spool->pool_size % HEADER_SZ;
    if (x) spool->pool_size -= x;
    if (spool->pool_size <= MIN_POOL_SZ) {
        errno = ENOSPC;
        return 0;
    }

    return 1;
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
    if (!spool) {
        errno = EINVAL;
        return 0;
    }

    if (!new_pool || !new_pool_size) {
        if (smalloc_verify_pool(spool)) {
            if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
            memset(spool, 0, sizeof(struct smalloc_pool));
            return 1;
        }

        errno = EINVAL;
        return 0;
    }

    spool->pool = new_pool;
    spool->pool_size = new_pool_size;
    spool->oomfn = oom_handler;
    if (!sm_align_pool(spool)) return 0;

    if (do_zero) {
        spool->do_zero = do_zero;
        memset(spool->pool, 0, spool->pool_size);
    }

    return 1;
}

int sm_set_default_pool(void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
    return sm_set_pool(&smalloc_curr_pool, new_pool, new_pool_size, do_zero, oom_handler);
}

int sm_release_pool(struct smalloc_pool *spool)
{
    return sm_set_pool(spool, NULL, 0, 0, NULL);
}

int sm_release_default_pool(void)
{
    return sm_release_pool(&smalloc_curr_pool);
}

[@file: lib/src/smalloc/sm_realloc.c]
/*
 * This file is a part of SMalloc.
 * SMalloc is MIT licensed.
 * Copyright (c) 2017 Andrey Rys.
 */

#include "smalloc_i.h"

void *sm_realloc_pool(struct smalloc_pool *spool, void *p, size_t n)
{
    return sm_realloc_pool_i(spool, p, n, 0);
}

void *sm_realloc(void *p, size_t n)
{
    return sm_realloc_pool_i(&smalloc_curr_pool, p, n, 0);
}

[@file: lib/src/smalloc/sm_realloc_i.c]
/*
 * This file is a part of SMalloc.
 * SMalloc is MIT licensed.
 * Copyright (c) 2017 Andrey Rys.
 */

#include "smalloc_i.h"

/*
 * Please do NOT use this function directly or rely on it's presence.
 * It may go away in future SMalloc versions, or it's calling
 * signature may change. It is internal function, hence "_i" suffix.
 */
void *sm_realloc_pool_i(struct smalloc_pool *spool, void *p, size_t n, int nomove)
{
    struct smalloc_hdr *basehdr, *shdr, *dhdr;
    void *r;
    char *s;
    int found;
    size_t rsz, usz, x;
    uintptr_t tag;

    if (!smalloc_verify_pool(spool)) {
        errno = EINVAL;
        return NULL;
    }

    if (!p) return sm_malloc_pool(spool, n);
    if (!n && p) {
        sm_free_pool(spool, p);
        return NULL;
    }

    /* determine user size */
    shdr = USER_TO_HEADER(p);
    if (!smalloc_is_alloc(spool, shdr)) smalloc_UB(spool, p);
    usz = shdr->usz;
    rsz = shdr->rsz;

    /* newsize is lesser than allocated - truncate */
    if (n <= usz) {
        if (spool->do_zero) memset(p + n, 0, shdr->rsz - n);
        s = CHAR_PTR(HEADER_TO_USER(shdr));
        s += usz;
        memset(s, 0, HEADER_SZ);
        if (spool->do_zero) memset(s+HEADER_SZ, 0, rsz - usz);
        shdr->rsz = (n%HEADER_SZ)?(((n/HEADER_SZ)+1)*HEADER_SZ):n;
        shdr->usz = n;
        shdr->tag = tag = smalloc_mktag(shdr);
        s = CHAR_PTR(HEADER_TO_USER(shdr));
        s += shdr->usz;
        for (x = 0; x < sizeof(struct smalloc_hdr); x += sizeof(uintptr_t)) {
            tag = smalloc_uinthash(tag);
            memcpy(s+x, &tag, sizeof(uintptr_t));
        }
        memset(s+x, 0xff, shdr->rsz - shdr->usz);
        return p;
    }

    /* newsize is bigger than allocated, but there is free room - modify */
    if (n > usz && n <= rsz) {
        if (spool->do_zero) {
            s = CHAR_PTR(HEADER_TO_USER(shdr));
            s += usz;
            memset(s, 0, HEADER_SZ);
        }
        shdr->usz = n;
        shdr->tag = tag = smalloc_mktag(shdr);
        s = CHAR_PTR(HEADER_TO_USER(shdr));
        s += shdr->usz;
        for (x = 0; x < sizeof(struct smalloc_hdr); x += sizeof(uintptr_t)) {
            tag = smalloc_uinthash(tag);
            memcpy(s+x, &tag, sizeof(uintptr_t));
        }
        memset(s+x, 0xff, shdr->rsz - shdr->usz);
        return p;
    }

    /* newsize is bigger, larger than rsz but there are free blocks beyond - extend */
    basehdr = spool->pool; dhdr = shdr+(rsz/HEADER_SZ); found = 0;
    while (CHAR_PTR(dhdr)-CHAR_PTR(basehdr) < spool->pool_size) {
        x = CHAR_PTR(dhdr)-CHAR_PTR(shdr);
        if (smalloc_is_alloc(spool, dhdr))
            goto allocblock;
        if (n + HEADER_SZ <= x) {
            x -= HEADER_SZ;
            found = 1;
            goto outfound;
        }
        dhdr++;
    }

outfound:
    /* write new numbers of same allocation */
    if (found) {
        if (spool->do_zero) {
            s = CHAR_PTR(HEADER_TO_USER(shdr));
            s += usz;
            memset(s, 0, HEADER_SZ);
            memset(s+HEADER_SZ, 0, rsz - usz);
        }
        shdr->rsz = x;
        shdr->usz = n;
        shdr->tag = tag = smalloc_mktag(shdr);
        s = CHAR_PTR(HEADER_TO_USER(shdr));
        s += shdr->usz;
        for (x = 0; x < sizeof(struct smalloc_hdr); x += sizeof(uintptr_t)) {
            tag = smalloc_uinthash(tag);
            memcpy(s+x, &tag, sizeof(uintptr_t));
        }
        memset(s+x, 0xff, shdr->rsz - shdr->usz);
        return p;
    }

allocblock:
    /* newsize is bigger than allocated and no free space - move */
    if (nomove) {
        /* fail if user asked */
        errno = ERANGE;
        return NULL;
    }
    r = sm_malloc_pool(spool, n);
    if (!r) return NULL;
    memcpy(r, p, usz);
    sm_free_pool(spool, p);

    return r;
}

[@file: lib/src/smalloc/sm_realloc_move.c]
/*
 * This file is a part of SMalloc.
 * SMalloc is MIT licensed.
 * Copyright (c) 2017 Andrey Rys.
 */

#include "smalloc_i.h"

void *sm_realloc_move_pool(struct smalloc_pool *spool, void *p, size_t n)
{
    return sm_realloc_pool_i(spool, p, n, 1);
}

void *sm_realloc_move(void *p, size_t n)
{
    return sm_realloc_pool_i(&smalloc_curr_pool, p, n, 1);
}

[@file: lib/src/smalloc/sm_szalloc.c]
/*
 * This file is a part of SMalloc.
 * SMalloc is MIT licensed.
 * Copyright (c) 2017 Andrey Rys.
 */

#include "smalloc_i.h"

size_t sm_szalloc_pool(struct smalloc_pool *spool, const void *p)
{
    struct smalloc_hdr *shdr;

    if (!smalloc_verify_pool(spool)) {
        errno = EINVAL;
        return ((size_t)-1);
    }

    if (!p) return 0;

    shdr = USER_TO_HEADER(p);
    if (smalloc_is_alloc(spool, shdr)) return shdr->usz;
    smalloc_UB(spool, p);
    return 0;
}

size_t sm_szalloc(const void *p)
{
    return sm_szalloc_pool(&smalloc_curr_pool, p);
}

[@file: lib/src/smalloc/sm_util.c]
/*
 * This file is a part of SMalloc.
 * SMalloc is MIT licensed.
 * Copyright (c) 2017 Andrey Rys.
 */

#include "smalloc_i.h"

static int smalloc_check_bounds(struct smalloc_pool *spool, struct smalloc_hdr *shdr)
{
    if (!spool) return 0;
    if (CHAR_PTR(shdr) >= CHAR_PTR(spool->pool)
    && CHAR_PTR(shdr) <= (CHAR_PTR(spool->pool)+spool->pool_size))
        return 1;
    return 0;
}

static int smalloc_valid_tag(struct smalloc_hdr *shdr)
{
    char *s;
    uintptr_t r = smalloc_mktag(shdr);
    size_t x;

    if (shdr->tag == r) {
        s = CHAR_PTR(HEADER_TO_USER(shdr));
        s += shdr->usz;
        for (x = 0; x < sizeof(struct smalloc_hdr); x += sizeof(uintptr_t)) {
            r = smalloc_uinthash(r);
            if (memcmp(s+x, &r, sizeof(uintptr_t)) != 0) return 0;
        }
        s += x; x = 0;
        while (x < shdr->rsz - shdr->usz) {
            if (s[x] != '\xFF') return 0;
            x++;
        }
        return 1;
    }
    return 0;
}

static void smalloc_do_crash(struct smalloc_pool *spool, const void *p)
{
    char *c = NULL;
    *c = 'X';
}

smalloc_ub_handler smalloc_UB = smalloc_do_crash;

void sm_set_ub_handler(smalloc_ub_handler handler)
{
    if (!handler) smalloc_UB = smalloc_do_crash;
    else smalloc_UB = handler;
}

int smalloc_is_alloc(struct smalloc_pool *spool, struct smalloc_hdr *shdr)
{
    if (!smalloc_check_bounds(spool, shdr)) return 0;
    if (shdr->rsz == 0) return 0;
    if (shdr->rsz > SIZE_MAX) return 0;
    if (shdr->usz > SIZE_MAX) return 0;
    if (shdr->usz > shdr->rsz) return 0;
    if (shdr->rsz % HEADER_SZ) return 0;
    if (!smalloc_valid_tag(shdr)) return 0;
    return 1;
}

[@file: lib/src/smalloc/sm_zalloc.c]
/*
 * This file is a part of SMalloc.
 * SMalloc is MIT licensed.
 * Copyright (c) 2017 Andrey Rys.
 */

#include "smalloc_i.h"

void *sm_zalloc_pool(struct smalloc_pool *spool, size_t n)
{
    void *r = sm_malloc_pool(spool, n);
    if (r) memset(r, 0, n);
    return r;
}

void *sm_zalloc(size_t n)
{
    return sm_zalloc_pool(&smalloc_curr_pool, n);
}

[@file: src/EXTString.cpp]
/*
  WEXTString.cpp - EXTString library for Wiring & Arduino
  ...mostly rewritten by Paul Stoffregen...
  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
  Copyright 2011, Paul Stoffregen, paul@pjrc.com

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include "EXTString.h"
#include "static_malloc.h"


/*********************************************/
/*  Constructors                             */
/*********************************************/

EXTString::EXTString(const char *cstr)
{
    init();
    if (cstr) copy(cstr, strlen(cstr));
}

EXTString::EXTString(const __FlashEXTStringHelper *pgmstr)
{
    init();
    *this = pgmstr;
}

EXTString::EXTString(const EXTString &value)
{
    init();
    *this = value;
}

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
EXTString::EXTString(EXTString &&rval)
{
    init();
    move(rval);
}
EXTString::EXTString(EXTStringSumHelper &&rval)
{
    init();
    move(rval);
}
#endif

EXTString::EXTString(char c)
{
    init();
    *this = c;
}

EXTString::EXTString(unsigned char c)
{
    init();
    char buf[4];
    utoa(c, buf, 10);
    *this = buf;
}

EXTString::EXTString(const int value, unsigned char base)
{
    init();
    char buf[18];
    itoa(value, buf, base);
    *this = buf;
}

EXTString::EXTString(unsigned int value, unsigned char base)
{
    init();
    char buf[17];
      utoa(value, buf, base);
    *this = buf;
}

EXTString::EXTString(long value, unsigned char base)
{
    init();
    char buf[34];
    ltoa(value, buf, base);
    *this = buf;
}

EXTString::EXTString(unsigned long value, unsigned char base)
{
    init();
    char buf[33];
    ultoa(value, buf, base);
    *this = buf;
}

EXTString::EXTString(float num, unsigned char digits)
{
    init();
    char buf[40];
    *this = dtostrf(num, digits + 2, digits, buf);
}

EXTString::~EXTString()
{
    sm_free(buffer);
}

/*********************************************/
/*  Memory Management                        */
/*********************************************/

inline void EXTString::init(void)
{
    buffer = NULL;
    capacity = 0;
    len = 0;
    flags = 0;
}

unsigned char EXTString::reserve(unsigned int size)
{
    if (capacity >= size) return 1;
    if (changeBuffer(size)) {
        if (len == 0) buffer[0] = 0;
        return 1;
    }
    return 0;
}

unsigned char EXTString::changeBuffer(unsigned int maxStrLen)
{
    char *newbuffer = (char *)sm_realloc(buffer, maxStrLen + 1);
    if (newbuffer) {
        buffer = newbuffer;
        capacity = maxStrLen;
        return 1;
    }
    return 0;
}

/*********************************************/
/*  Copy and Move                            */
/*********************************************/

EXTString & EXTString::copy(const char *cstr, unsigned int length)
{
    if (length == 0) {
        if (buffer) buffer[0] = 0;
        len = 0;
        return *this;
    }
    if (!reserve(length)) {
        if (buffer) {
            sm_free(buffer);
            buffer = NULL;
        }
        len = capacity = 0;
        return *this;
    }
    len = length;
    strcpy(buffer, cstr);
    return *this;
}

void EXTString::move(EXTString &rhs)
{
    if (&rhs == this) return;
    if (buffer) sm_free(buffer);
    buffer = rhs.buffer;
    capacity = rhs.capacity;
    len = rhs.len;
    rhs.buffer = NULL;
    rhs.capacity = 0;
    rhs.len = 0;
}

EXTString & EXTString::operator = (const EXTString &rhs)
{
    if (this == &rhs) return *this;
    return copy(rhs.buffer, rhs.len);
}

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
EXTString & EXTString::operator = (EXTString &&rval)
{
    if (this != &rval) move(rval);
    return *this;
}

EXTString & EXTString::operator = (EXTStringSumHelper &&rval)
{
    if (this != &rval) move(rval);
    return *this;
}
#endif

EXTString & EXTString::operator = (const char *cstr)
{
    if (cstr) {
        copy(cstr, strlen(cstr));
    } else {
        len = 0;
    }
    return *this;
}

EXTString & EXTString::operator = (const __FlashEXTStringHelper *pgmstr)
{
    copy(pgmstr);
    return *this;
}

EXTString & EXTString::operator = (char c)
{
    char buf[2];
    buf[0] = c;
    buf[1] = 0;
    return copy(buf, 1);
}

/*********************************************/
/*  Append                                   */
/*********************************************/

EXTString & EXTString::append(const EXTString &s)
{
    return append(s.buffer, s.len);
}

EXTString & EXTString::append(const char *cstr, unsigned int length)
{
    unsigned int newlen = len + length;
    bool self = false;
    unsigned int buffer_offset; 
    if ( (cstr >= buffer) && (cstr < (buffer+len) ) ) {
        self = true;
        buffer_offset = (unsigned int)(cstr-buffer);
    }
    if (length == 0 || !reserve(newlen)) return *this;
    if ( self ) {
        memcpy(buffer + len, buffer+buffer_offset, length);
        buffer[newlen] = 0;
        }
    else
        strcpy(buffer + len, cstr);
    len = newlen;
    return *this;
}

EXTString & EXTString::append(const char *cstr)
{
    if (cstr) append(cstr, strlen(cstr));
    return *this;
}

EXTString & EXTString::append(char c)
{
    char buf[2];
    buf[0] = c;
    buf[1] = 0;
    append(buf, 1);
    return *this;
}

EXTString & EXTString::append(int num)
{
    char buf[12];
    ltoa((long)num, buf, 10);
    append(buf, strlen(buf));
    return *this;
}

EXTString & EXTString::append(unsigned int num)
{
    char buf[11];
    ultoa((unsigned long)num, buf, 10);
    append(buf, strlen(buf));
    return *this;
}

EXTString & EXTString::append(long num)
{
    char buf[12];
    ltoa(num, buf, 10);
    append(buf, strlen(buf));
    return *this;
}

EXTString & EXTString::append(unsigned long num)
{
    char buf[11];
    ultoa(num, buf, 10);
    append(buf, strlen(buf));
    return *this;
}

EXTString & EXTString::append(float num)
{
    char buf[30];
    dtostrf(num, 4, 2, buf); 
    append(buf, strlen(buf));
    return *this;
}


/*********************************************/
/*  Concatenate                              */
/*********************************************/


EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, const EXTString &rhs)
{
    EXTStringSumHelper &a = const_cast<EXTStringSumHelper&>(lhs);
    a.append(rhs.buffer, rhs.len);
    return a;
}

EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, const char *cstr)
{
    EXTStringSumHelper &a = const_cast<EXTStringSumHelper&>(lhs);
    if (cstr) a.append(cstr, strlen(cstr));
    return a;
}

EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, const __FlashEXTStringHelper *pgmstr)
{
    EXTStringSumHelper &a = const_cast<EXTStringSumHelper&>(lhs);
    a.append(pgmstr);
    return a;
}

EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, char c)
{
    EXTStringSumHelper &a = const_cast<EXTStringSumHelper&>(lhs);
    a.append(c);
    return a;
}

EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, unsigned char c)
{
    EXTStringSumHelper &a = const_cast<EXTStringSumHelper&>(lhs);
    a.append(c);
    return a;
}

EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, int num)
{
    EXTStringSumHelper &a = const_cast<EXTStringSumHelper&>(lhs);
    a.append((long)num);
    return a;
}

EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, unsigned int num)
{
    EXTStringSumHelper &a = const_cast<EXTStringSumHelper&>(lhs);
    a.append((unsigned long)num);
    return a;
}

EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, long num)
{
    EXTStringSumHelper &a = const_cast<EXTStringSumHelper&>(lhs);
    a.append(num);
    return a;
}

EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, unsigned long num)
{
    EXTStringSumHelper &a = const_cast<EXTStringSumHelper&>(lhs);
    a.append(num);
    return a;
}

EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, float num)
{
    EXTStringSumHelper &a = const_cast<EXTStringSumHelper&>(lhs);
    a.append(num);
    return a;
}

EXTStringSumHelper & operator + (const EXTStringSumHelper &lhs, double num)
{
    EXTStringSumHelper &a = const_cast<EXTStringSumHelper&>(lhs);
    a.append(num);
    return a;
}

/*********************************************/
/*  Comparison                               */
/*********************************************/

int EXTString::compareTo(const EXTString &s) const
{
    if (!buffer || !s.buffer) {
        if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
        if (buffer && len > 0) return *(unsigned char *)buffer;
        return 0;
    }
    return strcmp(buffer, s.buffer);
}

unsigned char EXTString::equals(const EXTString &s2) const
{
    return (len == s2.len && compareTo(s2) == 0);
}

unsigned char EXTString::equals(const char *cstr) const
{
    if (len == 0) return (cstr == NULL || *cstr == 0);
    if (cstr == NULL) return buffer[0] == 0;
    return strcmp(buffer, cstr) == 0;
}

unsigned char EXTString::operator<(const EXTString &rhs) const
{
    return compareTo(rhs) < 0;
}

unsigned char EXTString::operator>(const EXTString &rhs) const
{
    return compareTo(rhs) > 0;
}

unsigned char EXTString::operator<=(const EXTString &rhs) const
{
    return compareTo(rhs) <= 0;
}

unsigned char EXTString::operator>=(const EXTString &rhs) const
{
    return compareTo(rhs) >= 0;
}

unsigned char EXTString::equalsIgnoreCase( const EXTString &s2 ) const
{
    if (this == &s2) return 1;
    if (len != s2.len) return 0;
    if (len == 0) return 1;
    const char *p1 = buffer;
    const char *p2 = s2.buffer;
    while (*p1) {
        if (tolower(*p1++) != tolower(*p2++)) return 0;
    } 
    return 1;
}

unsigned char EXTString::startsWith( const EXTString &s2 ) const
{
    if (len < s2.len) return 0;
    return startsWith(s2, 0);
}

unsigned char EXTString::startsWith( const EXTString &s2, unsigned int offset ) const
{
    if (offset > len - s2.len || !buffer || !s2.buffer) return 0;
    return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;
}

unsigned char EXTString::endsWith( const EXTString &s2 ) const
{
    if ( len < s2.len || !buffer || !s2.buffer) return 0;
    return strcmp(&buffer[len - s2.len], s2.buffer) == 0;
}

/*********************************************/
/*  Character Access                         */
/*********************************************/

const char EXTString::zerotermination = 0;

char EXTString::charAt(unsigned int loc) const
{
    return operator[](loc);
}

void EXTString::setCharAt(unsigned int loc, char c) 
{
    if (loc < len) buffer[loc] = c;
}

char & EXTString::operator[](unsigned int index)
{
    static char dummy_writable_char;
    if (index >= len || !buffer) {
        dummy_writable_char = 0;
        return dummy_writable_char;
    }
    return buffer[index];
}

char EXTString::operator[]( unsigned int index ) const
{
    if (index >= len || !buffer) return 0;
    return buffer[index];
}

void EXTString::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
    if (!bufsize || !buf) return;
    if (index >= len) {
        buf[0] = 0;
        return;
    }
    unsigned int n = bufsize - 1;
    if (n > len - index) n = len - index;
    strncpy((char *)buf, buffer + index, n);
    buf[n] = 0;
}

/*********************************************/
/*  Search                                   */
/*********************************************/

int EXTString::indexOf(char c) const
{
    return indexOf(c, 0);
}

int EXTString::indexOf( char ch, unsigned int fromIndex ) const
{
    if (fromIndex >= len) return -1;
    const char* temp = strchr(buffer + fromIndex, ch);
    if (temp == NULL) return -1;
    return temp - buffer;
}

int EXTString::indexOf(const EXTString &s2) const
{
    return indexOf(s2, 0);
}

int EXTString::indexOf(const EXTString &s2, unsigned int fromIndex) const
{
    if (fromIndex >= len) return -1;
    const char *found = strstr(buffer + fromIndex, s2.buffer);
    if (found == NULL) return -1;
    return found - buffer;
}

int EXTString::lastIndexOf( char theChar ) const
{
    return lastIndexOf(theChar, len - 1);
}

int EXTString::lastIndexOf(char ch, unsigned int fromIndex) const
{
    if (fromIndex >= len) return -1;
    char tempchar = buffer[fromIndex + 1];
    buffer[fromIndex + 1] = '\0';
    char* temp = strrchr( buffer, ch );
    buffer[fromIndex + 1] = tempchar;
    if (temp == NULL) return -1;
    return temp - buffer;
}

int EXTString::lastIndexOf(const EXTString &s2) const
{
    return lastIndexOf(s2, len - s2.len);
}

int EXTString::lastIndexOf(const EXTString &s2, unsigned int fromIndex) const
{
      if (s2.len == 0 || len == 0 || s2.len > len) return -1;
    if (fromIndex >= len) fromIndex = len - 1;
    int found = -1;
    for (char *p = buffer; p <= buffer + fromIndex; p++) {
        p = strstr(p, s2.buffer);
        if (!p) break;
        if ((unsigned int)(p - buffer) <= fromIndex) found = p - buffer;
    }
    return found;
}

EXTString EXTString::substring( unsigned int left ) const
{
    return substring(left, len);
}

EXTString EXTString::substring(unsigned int left, unsigned int right) const
{
    if (left > right) {
        unsigned int temp = right;
        right = left;
        left = temp;
    }
    EXTString out;
    if (left > len) return out;
    if (right > len) right = len;
    char temp = buffer[right];  // save the replaced character
    buffer[right] = '\0';    
    out = buffer + left;  // pointer arithmetic
    buffer[right] = temp;  //restore character
    return out;
}

/*********************************************/
/*  Modification                             */
/*********************************************/

EXTString & EXTString::replace(char find, char replace)
{
    if (!buffer) return *this;
    for (char *p = buffer; *p; p++) {
        if (*p == find) *p = replace;
    }
    return *this;
}

EXTString & EXTString::replace(const EXTString& find, const EXTString& replace)
{
    if (len == 0 || find.len == 0) return *this;
    int diff = replace.len - find.len;
    char *readFrom = buffer;
    char *foundAt;
    if (diff == 0) {
        while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
            memcpy(foundAt, replace.buffer, replace.len);
            readFrom = foundAt + replace.len;
        }
    } else if (diff < 0) {
        char *writeTo = buffer;
        while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
            unsigned int n = foundAt - readFrom;
            memcpy(writeTo, readFrom, n);
            writeTo += n;
            memcpy(writeTo, replace.buffer, replace.len);
            writeTo += replace.len;
            readFrom = foundAt + find.len;
            len += diff;
        }
        strcpy(writeTo, readFrom);
    } else {
        unsigned int size = len; // compute size needed for result
        while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
            readFrom = foundAt + find.len;
            size += diff;
        }
        if (size == len) return *this;
        if (size > capacity && !changeBuffer(size)) return *this;
        int index = len - 1;
        while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
            readFrom = buffer + index + find.len;
            memmove(readFrom + diff, readFrom, len - (readFrom - buffer));
            len += diff;
            buffer[len] = 0;
            memcpy(buffer + index, replace.buffer, replace.len);
            index--;
        }
    }
    return *this;
}

EXTString & EXTString::remove(unsigned int index)
{
    if (index < len) {
        len = index;
        buffer[len] = 0;
    }
    return *this;
}

EXTString & EXTString::remove(unsigned int index, unsigned int count)
{
    if (index < len && count > 0) {
          if (index + count > len) count = len - index;
        len = len - count;
        memmove(buffer + index, buffer + index + count, len - index);
        buffer[len] = 0;
    }
    return *this;
}

EXTString & EXTString::toLowerCase(void)
{
    if (!buffer) return *this;
    for (char *p = buffer; *p; p++) {
        *p = tolower(*p);
    }
    return *this;
}

EXTString & EXTString::toUpperCase(void)
{
    if (!buffer) return *this;
    for (char *p = buffer; *p; p++) {
        *p = toupper(*p);
    }
    return *this;
}

EXTString & EXTString::trim(void)
{
    if (!buffer || len == 0) return *this;
    char *begin = buffer;
    while (isspace(*begin)) begin++;
    char *end = buffer + len - 1;
    while (isspace(*end) && end >= begin) end--;
    len = end + 1 - begin;
    if (begin > buffer) memcpy(buffer, begin, len);
    buffer[len] = 0;
    return *this;
}

/*********************************************/
/*  Parsing / Conversion                     */
/*********************************************/

long EXTString::toInt(void) const
{
    if (buffer) return atol(buffer);
    return 0;
}

float EXTString::toFloat(void) const
{
    if (buffer) return strtof(buffer, (char **)NULL);
    return 0.0;
}



[@file: src/filesystem.cpp]
#include "filesystem.h"

LittleFS_Program myfs;
uint32_t diskSize;

/**
 * @brief Load from file to string
 * 
 * @param fs file system
 * @param filePath path to file
 * @param str string to load file to
 * @return int 
 */
int loadFileToStr(const char* filePath, EXTString& str, LittleFS_Program& fs) {
    // open file
    File file = fs.open(filePath, FILE_READ);

    if (file) { // if file exists
        str = "";
        for (int c = file.read(); c >= 0; c = file.read()) 
            str += (char)c;
        file.close();
        return str.length();

    } else { // if file doesn't exist
        // create new file
        file = fs.open(filePath, FILE_WRITE_BEGIN);
        if (!file) return -2;

        file.close();
        return -1;
    }
}

/**
 * @brief save from string to file
 * 
 * @param fs file system 
 * @param filePath path to file
 * @param str string to save
 * @return int 
 */
int saveStrToFile(const char* filePath, EXTString& str, LittleFS_Program& fs) {
    
    // delete previous file
    fs.remove("/file");

    // open new file
    File file = fs.open("/file", FILE_WRITE_BEGIN);

    // write to file
    if (file) {
        file.write((const uint8_t*)str.c_str(), str.length());
        file.flush();
        int position = file.position();
        file.close();
        return position;
    } 
    
    // file error
    return -1;
}

/**
 * @brief Initialize FS
 * 
 * @param size size of FS in flash, default = PROG_FLASH_SIZE
 * @return int (0: fail, >0: success)
 */
int disk_init(uint32_t size, LittleFS_Program& fs) {
    diskSize = size;
    int cnt = 5;
    for (; cnt > 0; cnt--) {
        if (fs.begin(diskSize)) 
            return cnt;
        delay(100);
    }
    return 0;
}
[@file: src/HIDKeyboard.cpp]
/*
  Keyboard.cpp

  Copyright (c) 2015, Arduino LLC
  Original code (pre-library): Copyright (c) 2011, Peter Barrett

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include "HIDKeyboard.h"
#include "usb_keyboard.h"

const uint32_t _asciimap[] =
{
    0x00U, // NUL
    0x00U, // SOH
    0x00U, // STX
    0x00U, // ETX
    0x00U, // EOT
    0x00U, // ENQ
    0x00U, // ACK
    0x00U, // BEL
    0x2aU, // BS    Backspace
    0x2bU, // TAB   Tab
    0x28U, // LF    Enter
    0x00U, // VT
    0x00U, // FF
    0x00U, // CR
    0x00U, // SO
    0x00U, // SI
    0x00U, // DEL
    0x00U, // DC1
    0x00U, // DC2
    0x00U, // DC3
    0x00U, // DC4
    0x00U, // NAK
    0x00U, // SYN
    0x00U, // ETB
    0x00U, // CAN
    0x00U, // EM
    0x00U, // SUB
    0x00U, // ESC
    0x00U, // FS
    0x00U, // GS
    0x00U, // RS
    0x00U, // US
    0x2cU,         //  ' '
    0x1eU | SHIFT, // !
    0x34U | SHIFT, // "
    0x20U | SHIFT, // #
    0x21U | SHIFT, // $
    0x22U | SHIFT, // %
    0x24U | SHIFT, // &
    0x34U,         // '
    0x26U | SHIFT, // (
    0x27U | SHIFT, // )
    0x25U | SHIFT, // *
    0x2eU | SHIFT, // +
    0x36U,         // ,
    0x2dU,         // -
    0x37U,         // .
    0x38U,         // /
    0x27U,         // 0
    0x1eU,         // 1
    0x1fU,         // 2
    0x20U,         // 3
    0x21U,         // 4
    0x22U,         // 5
    0x23U,         // 6
    0x24U,         // 7
    0x25U,         // 8
    0x26U,         // 9
    0x33U | SHIFT, // :
    0x33U,         // ;
    0x36U | SHIFT, // <
    0x2eU,         // =
    0x37U | SHIFT, // >
    0x38U | SHIFT, // ?
    0x1fU | SHIFT, // @
    0x04U | SHIFT, // A
    0x05U | SHIFT, // B
    0x06U | SHIFT, // C
    0x07U | SHIFT, // D
    0x08U | SHIFT, // E
    0x09U | SHIFT, // F
    0x0aU | SHIFT, // G
    0x0bU | SHIFT, // H
    0x0cU | SHIFT, // I
    0x0dU | SHIFT, // J
    0x0eU | SHIFT, // K
    0x0fU | SHIFT, // L
    0x10U | SHIFT, // M
    0x11U | SHIFT, // N
    0x12U | SHIFT, // O
    0x13U | SHIFT, // P
    0x14U | SHIFT, // Q
    0x15U | SHIFT, // R
    0x16U | SHIFT, // S
    0x17U | SHIFT, // T
    0x18U | SHIFT, // U
    0x19U | SHIFT, // V
    0x1aU | SHIFT, // W
    0x1bU | SHIFT, // X
    0x1cU | SHIFT, // Y
    0x1dU | SHIFT, // Z
    0x2fU,         // [
    0x31U,         // bslash
    0x30U,         // ]
    0x23U | SHIFT, // ^
    0x2dU | SHIFT, // _
    0x35U,         // `
    0x04U,         // a
    0x05U,         // b
    0x06U,         // c
    0x07U,         // d
    0x08U,         // e
    0x09U,         // f
    0x0aU,         // g
    0x0bU,         // h
    0x0cU,         // i
    0x0dU,         // j
    0x0eU,         // k
    0x0fU,         // l
    0x10U,         // m
    0x11U,         // n
    0x12U,         // o
    0x13U,         // p
    0x14U,         // q
    0x15U,         // r
    0x16U,         // s
    0x17U,         // t
    0x18U,         // u
    0x19U,         // v
    0x1aU,         // w
    0x1bU,         // x
    0x1cU,         // y
    0x1dU,         // z
    0x2fU | SHIFT, // {
    0x31U | SHIFT, // |
    0x30U | SHIFT, // }
    0x35U | SHIFT, // ~
    0x00U,         // DEL
    // MODIFIER
    M_KEY_LEFT_CTRL,
    M_KEY_LEFT_SHIFT,
    M_KEY_LEFT_ALT, 
    M_KEY_LEFT_GUI, 
    M_KEY_RIGHT_CTRL, 
    M_KEY_RIGHT_SHIFT, 
    M_KEY_RIGHT_ALT, 
    M_KEY_RIGHT_GUI, 
    // NONPRINT
    M_KEY_UP_ARROW,
    M_KEY_DOWN_ARROW,
    M_KEY_LEFT_ARROW,
    M_KEY_RIGHT_ARROW,
    M_KEY_BACKSPACE,
    M_KEY_TAB,
    M_KEY_RETURN,
    M_KEY_ESC,
    M_KEY_INSERT,
    M_KEY_PRTSC,
    M_KEY_DELETE,
    M_KEY_PAGE_UP,
    M_KEY_PAGE_DOWN,
    M_KEY_HOME,
    M_KEY_END,
    M_KEY_CAPS_LOCK,
    M_KEY_NUM_LOCK,

    // F Keys
    M_KEY_F1, 
    M_KEY_F2, 
    M_KEY_F3, 
    M_KEY_F4, 
    M_KEY_F5, 
    M_KEY_F6, 
    M_KEY_F7, 
    M_KEY_F8, 
    M_KEY_F9, 
    M_KEY_F10, 
    M_KEY_F11, 
    M_KEY_F12, 
    M_KEY_F13, 
    M_KEY_F14, 
    M_KEY_F15, 
    M_KEY_F16, 
    M_KEY_F17, 
    M_KEY_F18, 
    M_KEY_F19, 
    M_KEY_F20, 
    M_KEY_F21, 
    M_KEY_F22, 
    M_KEY_F23, 
    M_KEY_F24, 

    // KEYPAD
    M_KEY_NUM_0,
    M_KEY_NUM_1,
    M_KEY_NUM_2,
    M_KEY_NUM_3,
    M_KEY_NUM_4,
    M_KEY_NUM_5,
    M_KEY_NUM_6,
    M_KEY_NUM_7,
    M_KEY_NUM_8,
    M_KEY_NUM_9,
    M_KEY_NUM_SLASH,
    M_KEY_NUM_ASTERISK,
    M_KEY_NUM_MINUS,
    M_KEY_NUM_PLUS,
    M_KEY_NUM_ENTER,
    M_KEY_NUM_PERIOD,
    M_KEY_NUM_EQUAL,

    // MEDIA 1
    M_KEY_MEDIA_NEXT,
    M_KEY_MEDIA_PREV, 
    M_KEY_MEDIA_STOP, 
    M_KEY_MEDIA_PAUSE, 
    M_KEY_MEDIA_MUTE, 
    M_KEY_MEDIA_VOLUP, 
    M_KEY_MEDIA_VOLDN, 
    M_KEY_MEDIA_WWW_HOME, 
    
    // MEDIA 2
    M_KEY_FILE_EXPLORER, 
    M_KEY_MEDIA_CALC, 
    M_KEY_MEDIA_BRIGHTNESS_D, 
    M_KEY_MEDIA_BRIGHTNESS_I, 
    M_KEY_MEDIA_WWW_STOP, 
    M_KEY_MEDIA_WWW_BACK, 
    M_KEY_CONSUMER_CTL, 
    M_KEY_MEDIA_EMAIL, 
};

uint32_t Reports::pressRaw(uint32_t k) {
    uint8_t i; uint32_t retVal = k;
    if ((k & M_KEY_TYPE_MASK) == M_KEY_TYPE_MODIF)
    { // it's a modifier key
        _keyReport.modifiers |= (k & 0xff);
        return retVal;
    }
    else if ((k & M_KEY_TYPE_MASK) == 0x0U)
    { // ascii
        k = _asciimap[k & 0xffU] | M_KEY_TARGET_KB;
        if ((k & M_KEY_TYPE_MASK) == SHIFT)
            _keyReport.modifiers |= (M_KEY_LEFT_SHIFT & 0xff);
    }
    else if ((k & M_KEY_TYPE_MASK) == M_KEY_TARGET_CC)
    { // media
        _cc_report |= (k & 0xFFFFU);
        return k;
    }
    else if (!k)
        return 0;

    for (i = 0; i < sizeof(_keyReport.keys); i++)
    {
        if (_keyReport.keys[i] == 0x00)
        {
            _keyReport.keys[i] = (uint8_t)k;
            return k;
        }
    }
    return 0;
}

uint32_t Reports::press(uint8_t data) {
    uint32_t k = (data > 127)? _asciimap[data] : data;
    return pressRaw(k);
}

uint32_t Reports::release(uint8_t data) {
    uint32_t k = (data > 127)? _asciimap[data] : data;
    return releaseRaw(k);
}

uint32_t Reports::pressMulti(const uint8_t* data) {
    if (data == NULL) return 0;
    int i = 0;
    uint32_t retval = 0;
    while (data[i]) {
        retval |= press((const uint8_t)data[i]) & M_KEY_TARGET_MASK;
        i++;
    }
    return retval;
}

uint32_t Reports::releaseMulti(const uint8_t* data) {
    if (data == NULL) return 0;
    int i = 0;
    uint32_t retval = 0;
    while (data[i]) {
        retval |= release((const uint8_t)data[i]) & M_KEY_TARGET_MASK;
        i++;
    }
    return retval;
}

uint32_t Reports::releaseRaw(uint32_t k) {
    uint8_t i; uint32_t retVal = k;
    if ((k & M_KEY_TYPE_MASK) == M_KEY_TYPE_MODIF)
    { // it's a modifier key
        _keyReport.modifiers &= ~(k & 0xff);
        return retVal;
    }
    else if ((k & M_KEY_TYPE_MASK) == 0x0U)
    { // ascii
        k = _asciimap[k & 0xffU] | M_KEY_TARGET_KB;
        if ((k & M_KEY_TYPE_MASK) == SHIFT)
            _keyReport.modifiers &= ~(M_KEY_LEFT_SHIFT & 0xff);
    }
    else if ((k & M_KEY_TYPE_MASK) == M_KEY_TARGET_CC)
    { // media
        _cc_report &= ~(k & 0xFFFFU);
        return k;
    }
    else if (!k)
        return 0;

    for (i = 0; i < sizeof(_keyReport.keys); i++)
    {
        if (_keyReport.keys[i] == (uint8_t)k)
        {
            _keyReport.keys[i] = 0;
            return k;
        }
    }
    return 0;
}

void Reports::releaseAll(void)
{
    memset(&_keyReport, 0, sizeof(_keyReport));
    _cc_report = 0;
}


void Reports::sendKeyReport() {
    usb_keyboard_transmit(KEYBOARD_ENDPOINT, (uint8_t*)&_keyReport, KEYBOARD_SIZE);
}
[@file: src/kbcontrol.cpp]
#include "kbcontrol.h"

// keyboard params
EXTString rx_str = "";
EXTString tx_str = "";
bool tx_lock = false;
uint32_t kb_delay = 0;
uint32_t type_pos = 0;

void memory_test(Stream& st) {
    // calculate clock frq
    float frequency = psram_clock_speed_get();

    st.printf("CCM_CBCMR = %08lX (%f MHz)\n", CCM_CBCMR, frequency);

    // allocate memory
    uint32_t str_size = 0x200000UL;
    char* str = (char*)sm_malloc(str_size);

    // test memset speed
    uint32_t arm_cyccnt_write = ARM_DWT_CYCCNT;
    memset(str, 'U', str_size);
    arm_cyccnt_write = ARM_DWT_CYCCNT - arm_cyccnt_write;

    // check integrity
    bool mem_ok = true;
    for (char* i = str; i < str + str_size && *i == 'U'; i++) {
        if (*i != 'U') {
            mem_ok = false;
            break;
        }
    }

    // log
    if (mem_ok) {
        st.printf(
            "write count: %lu, ms: %lf, per_bytes: %lf, MB/s: %lf\n",
            str_size, (double)arm_cyccnt_write / F_CPU_ACTUAL,
            (double)arm_cyccnt_write / str_size,
            (double)((uint64_t)F_CPU_ACTUAL * str_size) /
                arm_cyccnt_write / 1000000.0);
    } else {
        st.printf("Memory Error\n");
    }

    // free allocated memory
    sm_free(str);
}

/**
 * @brief Process received character from serial
 *
 * @param c
 */
void process_char(Stream& st, char c) {

    /** @brief Clear received string */
    static bool enable_backspace_clear = true;
    if (c == '\b' && enable_backspace_clear) {
        rx_str = "";
        st.println("cleared");
        return;
    }

    /**
     * @brief received Escape char (\033)
     *
     * start processing received string
     * when received Escape char
     *
     */
    if (c == '\033') {
        st.println();

        /**
         * @brief Toggle backspace clear
         *
         * Toggles whether backspace char clears
         * rx_str or be treated as a normal character
         *
         */
        if (strncmp(rx_str.c_str(), "KB bkspc", 8) == 0 &&
            rx_str.length() == 8) {
            rx_str = "";
            enable_backspace_clear = !enable_backspace_clear;
            st.println((enable_backspace_clear) ? "Backspace clears RX buffer"
                                                : "Backspace is normal key");
            return;
        }

        /**
         * @brief set keyboard report delay
         * MAX allowed: 1000000us (1 second)
         */
        if (strncmp(rx_str.c_str(), "KB delay ", 9) == 0 &&
            rx_str.length() > 9 && rx_str.length() < 19) {

            EXTString kb_delay_str(rx_str.substring(9).c_str());
            kb_delay_str.trim();

            kb_delay = kb_delay_str.toInt();
            kb_delay = (kb_delay > 1000000) ? 1000000 : kb_delay;

            rx_str = "";
            st.printf("Key Delay: %lu ms\n", kb_delay);
            st.printf("Report Rate: %lu Hz\n",
                      (1000000UL / (kb_delay > 125U ? kb_delay : 125U)));
            return;
        }

        /**
         * @brief retrieves keyboard report delay
         */
        if (strncmp(rx_str.c_str(), "KB delay", 8) == 0 &&
            rx_str.length() == 8) {

            rx_str = "";
            st.printf("Key Delay: %lu ms\n", kb_delay);
            st.printf("Report Rate: %lu Hz\n",
                      (1000000UL / (kb_delay > 125U ? kb_delay : 125U)));
            return;
        }

        /**
         * @brief set keyboard autotype position
         */
        if (strncmp(rx_str.c_str(), "KB pos ", 7) == 0 && rx_str.length() > 7 &&
            rx_str.length() < 17) {

            EXTString kb_pos_str(rx_str.substring(7).c_str());
            kb_pos_str.trim();

            type_pos = kb_pos_str.toInt();
            type_pos = (type_pos >= tx_str.length()) ? (tx_str.length() - 1)
                                                     : type_pos;

            rx_str = "";
            st.printf("Key Pos: %lu\n", type_pos);
            return;
        }

        /**
         * @brief get keyboard autotype position
         */
        if (strncmp(rx_str.c_str(), "KB pos", 6) == 0 && rx_str.length() == 6) {

            rx_str = "";
            st.printf("Key Pos: %lu\n", type_pos);
            return;
        }

        /**
         * @brief get keyboard autotype text length
         *
         */
        if (strncmp(rx_str.c_str(), "KB len", 6) == 0 && rx_str.length() == 6) {

            rx_str = "";
            st.printf("Length: %lu\n", tx_str.length());
            return;
        }

        /**
         * @brief mouse position
         *
         */
        static int mouse_x = 0;
        static int mouse_y = 0;

        /**
         * @brief set mouse x position
         *
         */
        if (strncmp(rx_str.c_str(), "KB mouse x ", 11) == 0 &&
            rx_str.length() > 11 && rx_str.length() < 18) {

            EXTString kb_pos_str(rx_str.substring(11).c_str());
            kb_pos_str.trim();
            mouse_x = kb_pos_str.toInt();
            rx_str = "";
            usb_mouse_position(mouse_x, mouse_y);
            st.printf("Pos: %lu, %lu\n", mouse_x, mouse_y);
            return;
        }

        /**
         * @brief set mouse y position
         *
         */
        if (strncmp(rx_str.c_str(), "KB mouse y ", 11) == 0 &&
            rx_str.length() > 11 && rx_str.length() < 18) {

            EXTString kb_pos_str(rx_str.substring(11).c_str());
            kb_pos_str.trim();
            mouse_y = kb_pos_str.toInt();
            rx_str = "";
            usb_mouse_position(mouse_x, mouse_y);
            st.printf("Pos: %lu, %lu\n", mouse_x, mouse_y);
            return;
        }

        /**
         * @brief Load data from file to tx_str
         *
         */
        if (strncmp(rx_str.c_str(), "KB load", 7) == 0 &&
            rx_str.length() == 7) {

            rx_str = "";
            st.println("loading");

            int loaded = loadFileToStr("/file", tx_str);

            if (loaded >= 0)
                st.printf("Loaded %lu bytes\n", loaded);
            else
                st.printf("Error Code: %d", loaded);

            return;
        }

        /**
         * @brief save data from tx_str to file
         *
         */
        if (strncmp(rx_str.c_str(), "KB save", 7) == 0 &&
            rx_str.length() == 7) {

            st.println("saving");
            rx_str = "";

            int saved = saveStrToFile("/file", tx_str);

            if (saved >= 0)
                st.printf("Saved %d bytes\n", saved);
            else
                st.printf("Error Code: %d", saved);

            return;
        }

        /**
         * @brief Test PSRAM Speed
         *
         */
        if (strncmp(rx_str.c_str(), "KB ram test", 11) == 0 &&
            rx_str.length() == 11) {

            rx_str = "";

            memory_test(st);

            return;
        }

        /**
         * @brief Test PSRAM Speed
         *
         */
        if (strncmp(rx_str.c_str(), "KB ram speed", 12) == 0 &&
            rx_str.length() == 12) {

            rx_str = "";

            print_ram_speeds(st);

            return;
        }

        // set EXT RAM speed
        if (strncmp(rx_str.c_str(), "KB ram ", 7) == 0 && rx_str.length() > 7 &&
            rx_str.length() < 10) {

            EXTString kb_pos_str(rx_str.substring(7).c_str());
            kb_pos_str.trim();
            rx_str = "";

            // get clock speed index
            uint32_t index = kb_pos_str.toInt();

            // set clock speed
            psram_clock_speed_set(index);

            // calculate clock frq
            float frequency = psram_clock_speed_get();

            st.printf("CCM_CBCMR = %08lX (%f MHz)\n", CCM_CBCMR, frequency);

            return;
        }
        // get EXT RAM speed
        if (strncmp(rx_str.c_str(), "KB ram", 6) == 0 && rx_str.length() == 6) {

            rx_str = "";

            // calculate clock frq
            float frequency = psram_clock_speed_get();

            st.printf("CCM_CBCMR = %08lX (%f MHz)\n", CCM_CBCMR, frequency);

            return;
        }

        // change string
        if (!tx_lock && rx_str.length()) {
            tx_lock = true;
            tx_str.move(rx_str);
            type_pos = 0UL;
            tx_lock = false;
            st.printf("Received %lu bytes\n", (uint32_t)tx_str.length());
            st.printf("Address of tx_str         : 0x%08lx\n", &tx_str);
            st.printf("Address of tx_str.c_str() : 0x%08lx\n", tx_str.c_str());
            st.printf("Address of rx_str         : 0x%08lx\n", &rx_str);
            st.printf("Address of rx_str.c_str() : 0x%08lx\n", rx_str.c_str());
        }
    } else {
        rx_str += (char)c;
        st.print(c);
    }
}

/**
 * @brief wrapper function for process_char
 *
 * loops process_char on Stream::available()
 *
 * @param st stream to process
 */
void process_char_loop(Stream& st) {
    while (st.available()) {
        process_char(st, st.read());
    }
}

[@file: src/main.cpp]
#include "EXTString.h"
#include "HIDKeyboard.h"
#include "filesystem.h"
#include "text.h"
#include <Arduino.h>
#include <math.h>
#include "psramctrl.h"
#include "kbcontrol.h"

#define USB_LED_NUM_LOCK    (1U << 0U)
#define USB_LED_CAPS_LOCK   (1U << 1U)
#define USB_LED_SCROLL_LOCK (1U << 2U)
#define USB_LED_COMPOSE     (1U << 3U)
#define USB_LED_KANA        (1U << 4U)

#define DELAY_WRAP(STATEMENT, DELAY)                                           \
    {                                                                          \
        uint32_t begin = ARM_DWT_CYCCNT,                                       \
                 cycles = F_CPU_ACTUAL / 1000000UL * ((uint32_t)DELAY);        \
        STATEMENT;                                                             \
        while (ARM_DWT_CYCCNT - begin < cycles)                                \
            ;                                                                  \
    }

static uint32_t ms_table[20] = {0, 100, 200, 500};

/**
 * @brief Get the dip switch value for KB delay
 *
 * DIP Switch is on pins (16, 17, 18, 19, 20, 21, 22, 23)
 *
 * @return uint8_t
 */
static uint8_t dip_val_read() {
    const uint32_t reg = GPIO6_PSR;
    uint8_t val = (reg & CORE_PIN16_BITMASK) > 0;
    val = (val << 1U) | ((reg & CORE_PIN17_BITMASK) > 0);
    val = (val << 1U) | ((reg & CORE_PIN18_BITMASK) > 0);
    val = (val << 1U) | ((reg & CORE_PIN19_BITMASK) > 0);
    val = (val << 1U) | ((reg & CORE_PIN20_BITMASK) > 0);
    val = (val << 1U) | ((reg & CORE_PIN21_BITMASK) > 0);
    val = (val << 1U) | ((reg & CORE_PIN22_BITMASK) > 0);
    val = (val << 1U) | ((reg & CORE_PIN23_BITMASK) > 0);
    return val;
}

void setup() {

    // init psram
    psram_init();

    // set screen size for mouse position functions
    usb_mouse_screen_size(1920, 1080, false);

    // initialize USB CDC
    Serial.begin(0);
    delay(1000);

    // config type pin and reset pin
    pinMode(5, INPUT_PULLUP);
    pinMode(4, INPUT_PULLUP);

    // config CAPS LOCK LED pin
    pinMode(LED_BUILTIN, OUTPUT);

    // config dip switch pin
    for (int i = 16; i < 24; i++)
        pinMode(i, INPUT_PULLDOWN);
    
    // init FS
    if (!disk_init()) Serial.printf("Error initializing FS\n");

    // Load saved file to tx_str
    int loaded = loadFileToStr("/file", tx_str);
    if (loaded >= 0) {
        Serial.printf("Loaded %lu bytes\n", loaded);
    } else if (loaded == -1) {
        Serial.printf("File Does Not Exist!, Creating new file\n");
    } else {
        Serial.printf("File Error");
    }

    // init delay table
    for (int i = 4; i < 20; i++) {
        ms_table[i] = ms_table[i - 3] * 10;
    }
}

void loop() {

    // process any input from USB CDC
    process_char_loop(Serial);

    // Keyboard report struct
    static Reports report;

    // read type pin and reset pin state
    static bool type_pin_pressed = false;
    static uint32_t type_pin_ms = 0;
    bool type_pin = (CORE_PIN5_PINREG & CORE_PIN5_BITMASK) > 0;
    bool reset_pin = (CORE_PIN4_PINREG & CORE_PIN4_BITMASK) > 0;

    // reset type pos when reset pin is pressed, but type pin isnt
    type_pos = (!reset_pin && !type_pin_pressed) ? 0 : type_pos;

    // KB output LEDs
    digitalWriteFast(LED_BUILTIN, keyboard_leds & USB_LED_CAPS_LOCK);

    // Debounce
    if (!type_pin && !type_pin_pressed) { 
        // if type pin is pressed

        if (millis() - type_pin_ms > 10) {
            // 10ms debounce

            type_pin_pressed = true;
            type_pin_ms = millis();
            if (type_pos < tx_str.length()) {
                DELAY_WRAP(
                    report.press(tx_str[type_pos++]); 
                    report.sendKeyReport();
                , kb_delay);
            }
        }
    } else if (type_pin && type_pin_pressed) { 
        // if type pin is released

        if (millis() - type_pin_ms > 10) {
            // 10ms debounce

            type_pin_pressed = false;
            type_pin_ms = millis();

            // release the keys
            DELAY_WRAP(
                report.releaseAll(); 
                report.sendKeyReport();
            , kb_delay);

            // reset type pos if reached end of text
            if (type_pos == tx_str.length()) type_pos = 0;
        }
    } else if (!type_pin && type_pin_pressed && (millis() - type_pin_ms >= 500)) { 
        // autotype if key is pressed for longer than 500ms

        // release previously pressed key
        DELAY_WRAP(
            report.releaseAll(); 
            report.sendKeyReport();
        , kb_delay);

        // press key
        if (type_pos < tx_str.length()) {
            DELAY_WRAP(report.press(tx_str[type_pos++]); report.sendKeyReport();
                       , kb_delay);
        }

        // continuous mode: reset type pos when autotyping has reached end of the text
        if (!reset_pin && (type_pos == tx_str.length())) type_pos = 0;
    }

    // KB delay from DIP switch state
    static uint32_t dip_ms = 0;
    static uint16_t dip_last = 0x100U;
    uint16_t dip_val = dip_val_read();

    // 20ms debounce
    if (dip_val != dip_last && (millis() - dip_ms > 20)) {
        dip_last = dip_val;
        dip_ms = millis();

        // get delay value from delay table
        kb_delay = ms_table[(dip_val & 0x0f) > 12 ? 12 : (dip_val & 0x0f)];

        // log
        Serial.printf("Delay: %lu, Report Rate: %lu Hz\n", kb_delay,
                      (1000000UL / (kb_delay > 125U ? kb_delay : 125U)));
        memory_test(Serial);
    }

    // cap all ms difference at 1000ms (prevent overflow)
    dip_ms = millis() - dip_ms > 1000 ? 
                millis() - 1000 : dip_ms;

    type_pin_ms = millis() - type_pin_ms > 1000 ? 
                    millis() - 1000 : type_pin_ms;
}
[@file: src/psramctrl.cpp]
#include "psramctrl.h"

static EXTMEM uint8_t extmem_pool[EXTMEM_SIZE];

/**
 * @brief RAM speed data
 *
 */

float clock_source(int i) {
    float clocks[] = {
        (float)(24 * 22 * 18) / ((CCM_ANALOG_PFD_528 >> 16) & 0x3fU),
        (float)(24 * 20 * 18) / ((CCM_ANALOG_PFD_480 >> 0) & 0x3fU),
        (float)(24 * 20 * 18) / ((CCM_ANALOG_PFD_480 >> 8) & 0x3fU),
        (float)(24 * 22)
    };
    return clocks[i];
}

std::vector<clock_info> ram_clock_sel_psc = {
    {49.5      , ((7UL << 29UL) | (0UL << 8UL))}, // 0.  
    {56.57143  , ((6UL << 29UL) | (0UL << 8UL))}, // 1.  
    {66.0      , ((5UL << 29UL) | (0UL << 8UL))}, // 2.  
    {66.0      , ((7UL << 29UL) | (3UL << 8UL))}, // 3.  
    {75.428574 , ((6UL << 29UL) | (3UL << 8UL))}, // 4.  
    {79.199997 , ((4UL << 29UL) | (0UL << 8UL))}, // 5.  
    {83.077499 , ((7UL << 29UL) | (2UL << 8UL))}, // 6.  
    {88.0      , ((5UL << 29UL) | (3UL << 8UL))}, // 7.  
    {90.0      , ((7UL << 29UL) | (1UL << 8UL))}, // 8.  
    {94.945717 , ((6UL << 29UL) | (2UL << 8UL))}, // 9.  
    {99.0      , ((3UL << 29UL) | (0UL << 8UL))}, // 10. 
    {102.85714 , ((6UL << 29UL) | (1UL << 8UL))}, // 11. 
    {105.599998, ((4UL << 29UL) | (3UL << 8UL))}, // 12. 
    {110.769997, ((5UL << 29UL) | (2UL << 8UL))}, // 13. 
    {120.0     , ((5UL << 29UL) | (1UL << 8UL))}, // 14. 
    {132.0     , ((2UL << 29UL) | (0UL << 8UL))}, // 15. 
    {132.0     , ((3UL << 29UL) | (3UL << 8UL))}, // 16. 
    {132.923996, ((4UL << 29UL) | (2UL << 8UL))}, // 17. 
    {144.0     , ((4UL << 29UL) | (1UL << 8UL))}, // 18. 
    {166.154999, ((3UL << 29UL) | (2UL << 8UL))}, // 19. 
    {176.0     , ((2UL << 29UL) | (3UL << 8UL))}, // 20. 
    {180.0     , ((3UL << 29UL) | (1UL << 8UL))}, // 21. 
    {198.0     , ((1UL << 29UL) | (0UL << 8UL))}, // 22. 
    {221.539993, ((2UL << 29UL) | (2UL << 8UL))}, // 23. 
    {240.0     , ((2UL << 29UL) | (1UL << 8UL))}, // 24. 
    {264.0     , ((1UL << 29UL) | (3UL << 8UL))}, // 25. 
    {332.309998, ((1UL << 29UL) | (2UL << 8UL))}, // 26. 
    {360.0     , ((1UL << 29UL) | (1UL << 8UL))}, // 27. 
    {396.0     , ((0UL << 29UL) | (0UL << 8UL))}, // 28. 
    {528.0     , ((0UL << 29UL) | (3UL << 8UL))}, // 29. 
    {664.619995, ((0UL << 29UL) | (2UL << 8UL))}, // 30. 
    {720.0     , ((0UL << 29UL) | (1UL << 8UL))}, // 31. 
};

// const uint32_t ram_clock_sel_psc_size =
//     ram_clock_sel_psc.size();//sizeof(ram_clock_sel_psc) / sizeof(ram_clock_sel_psc[0]);

static void ram_clock_sel_psc_refresh() {
    ram_clock_sel_psc.clear();
    for (uint32_t clk_src = 0; clk_src < 4; clk_src++) {
        for (uint32_t psc = 0; psc < 8; psc++) {
            float frq = clock_source(clk_src)/(psc + 1);
            uint32_t cbcmr_mask = (psc << 29U) | (clk_src << 8U);
            ram_clock_sel_psc.push_back({frq, cbcmr_mask});
        }
    }
    std::sort(ram_clock_sel_psc.begin(), ram_clock_sel_psc.end(), 
            [](clock_info& a, clock_info& b) {return b.frq > a.frq;});
}

int psram_init() {
    // set default psram pool
    ram_clock_sel_psc_refresh();
    return sm_set_default_pool(extmem_pool, EXTMEM_SIZE, true, nullptr);
}


void psram_clock_speed_set(uint16_t index) {
    ram_clock_sel_psc_refresh();
    index = (index < ram_clock_sel_psc.size())?
            index : ram_clock_sel_psc.size() - 1;
    CCM_CBCMR = (CCM_CBCMR & ~CBCMR_BIT_MASK) |
                    ram_clock_sel_psc[index].mask;
}

void print_ram_speeds(Stream& st) {
    ram_clock_sel_psc_refresh();
    for (uint32_t i = 0; i < ram_clock_sel_psc.size(); i++) {
        st.printf("%02d. (%dU << 29U) | (%dUL << 8U), frq = %f\n", i,
                    (ram_clock_sel_psc[i].mask >> 29U) & 7U, 
                    (ram_clock_sel_psc[i].mask >> 8U) & 7U, 
                    ram_clock_sel_psc[i].frq);
    }
}

float psram_clock_speed_get() {
    ram_clock_sel_psc_refresh();
    return (clock_source((CCM_CBCMR >> 8) & 3) /
            (float)(((CCM_CBCMR >> 29) & 7) + 1));
}
[@file: src/text.c]
unsigned char txt[] = "#include <Arduino.h>\r\n#include \"text.h\"\r\n#include \"HIDKeyboard.h\"\r\n#include <usb_keyboard.h>\r\n\r\n#define USB_LED_NUM_LOCK 0\r\n#define USB_LED_CAPS_LOCK 1\r\n#define USB_LED_SCROLL_LOCK 2\r\n#define USB_LED_COMPOSE 3\r\n#define USB_LED_KANA 4\r\n\r\nextern int usb_keyboard_transmit(int endpoint, const uint8_t *data, uint32_t len);\r\nstatic Reports report;\r\n\r\nvoid setup() {\r\n    // put your setup code here, to run once:\r\n    Keyboard.begin();\r\n    pinMode(5, INPUT_PULLUP);\r\n    pinMode(LED_BUILTIN, OUTPUT);\r\n}\r\n\r\nvoid loop() {\r\n    static uint32_t ms = 0;\r\n    static uint32_t i = 0;\r\n    static bool pressed = false;\r\n    bool pin_now = (CORE_PIN5_PINREG & CORE_PIN5_BITMASK) > 0;\r\n    digitalWriteFast(LED_BUILTIN, keyboard_leds & 0x02U);\r\n    if (!pin_now && !pressed) {\r\n        // char tmpp[] = \"1234567890-=qwertyuiop[]\\\\asdfghjkl;\'zxcvbnm,./\\b\\n\\t\";\r\n        // min time before press\r\n        if (millis() - ms > 10) {\r\n            // report.pressMulti((uint8_t*)\"abcdefghijklmnopqrstuvwxyz1234567890-=[]\\\\;\'\\n,./`\\b\\t \" STR_CAPS_LOCK STR_DELETE STR_PAGE_UP STR_PAGE_DOWN STR_NUM_LOCK);\r\n            if (i < size_txt) {\r\n                report.press(txt[i++]);\r\n                report.sendKeyReport();\r\n            }\r\n            pressed = true;\r\n            ms = millis();\r\n        }\r\n    } else if (pin_now && pressed) {\r\n        // release min time\r\n        if (millis() - ms > 10) {\r\n            report.releaseAll();\r\n            report.sendKeyReport();\r\n            if (i == size_txt) i = 0;\r\n            pressed = false;\r\n            ms = millis();\r\n        }\r\n    } else if (!pin_now && pressed && (millis() - ms >= 500)) {\r\n        static bool clear = false;\r\n        if (i < size_txt) {\r\n            report.releaseAll();\r\n            report.sendKeyReport();\r\n            report.press(txt[i++]);\r\n            report.sendKeyReport();\r\n            clear = true;\r\n        } else if (clear) {\r\n            report.releaseAll();\r\n            report.sendKeyReport();\r\n            clear = false;\r\n        }\r\n    }\r\n    ms = millis() - ms > 1000? millis() - 1000: ms;\r\n}"; unsigned long long size_txt = sizeof(txt) - 1;
[@file: test/README]

This directory is intended for PlatformIO Test Runner and project tests.

Unit Testing is a software testing method by which individual units of
source code, sets of one or more MCU program modules together with associated
control data, usage procedures, and operating procedures, are tested to
determine whether they are fit for use. Unit testing finds problems early
in the development cycle.

More information about PlatformIO Unit Testing:
- https://docs.platformio.org/en/latest/advanced/unit-testing/index.html

[@file: to_replace/memory_test.cpp]
#include <Arduino.h>
uint32_t rTime;
uint32_t rTCnt = 0;
extern "C" uint8_t external_psram_size;

bool memory_ok = false;
uint32_t *memory_begin, *memory_end;

bool check_fixed_pattern(uint32_t pattern);
bool check_lfsr_pattern(uint32_t seed);

void setup() {
    while (!Serial)
        ; // wait
    pinMode(13, OUTPUT);
    uint8_t size = external_psram_size;
    Serial.printf("EXTMEM Memory Test, %d Mbyte\n", size);
    if (size == 0) return;
    const float clocks[4] = {396.0f, 720.0f, 664.62f, 528.0f};
    CCM_CBCMR = (CCM_CBCMR & ~(7UL << 29UL) & ~(3UL << 8UL)) | (3UL << 29UL) |
                (1UL << 8UL);
    float frequency =
        clocks[(CCM_CBCMR >> 8) & 3] / (float)(((CCM_CBCMR >> 29) & 7) + 1);
    Serial.printf(" CCM_CBCMR=%08X (%.1f MHz)\n", CCM_CBCMR, frequency);
    memory_begin = (uint32_t*)(0x70000000);
    memory_end = (uint32_t*)(0x70000000 + size * 1048576);
    elapsedMillis msec = 0;
    if (!check_fixed_pattern(0x5A698421)) return;
    if (!check_lfsr_pattern(2976674124ul)) return;
    if (!check_lfsr_pattern(1438200953ul)) return;
    if (!check_lfsr_pattern(3413783263ul)) return;
    if (!check_lfsr_pattern(1900517911ul)) return;
    if (!check_lfsr_pattern(1227909400ul)) return;
    if (!check_lfsr_pattern(276562754ul)) return;
    if (!check_lfsr_pattern(146878114ul)) return;
    if (!check_lfsr_pattern(615545407ul)) return;
    if (!check_lfsr_pattern(110497896ul)) return;
    if (!check_lfsr_pattern(74539250ul)) return;
    if (!check_lfsr_pattern(4197336575ul)) return;
    if (!check_lfsr_pattern(2280382233ul)) return;
    if (!check_lfsr_pattern(542894183ul)) return;
    if (!check_lfsr_pattern(3978544245ul)) return;
    if (!check_lfsr_pattern(2315909796ul)) return;
    if (!check_lfsr_pattern(3736286001ul)) return;
    if (!check_lfsr_pattern(2876690683ul)) return;
    if (!check_lfsr_pattern(215559886ul)) return;
    if (!check_lfsr_pattern(539179291ul)) return;
    if (!check_lfsr_pattern(537678650ul)) return;
    if (!check_lfsr_pattern(4001405270ul)) return;
    if (!check_lfsr_pattern(2169216599ul)) return;
    if (!check_lfsr_pattern(4036891097ul)) return;
    if (!check_lfsr_pattern(1535452389ul)) return;
    if (!check_lfsr_pattern(2959727213ul)) return;
    if (!check_lfsr_pattern(4219363395ul)) return;
    if (!check_lfsr_pattern(1036929753ul)) return;
    if (!check_lfsr_pattern(2125248865ul)) return;
    if (!check_lfsr_pattern(3177905864ul)) return;
    if (!check_lfsr_pattern(2399307098ul)) return;
    if (!check_lfsr_pattern(3847634607ul)) return;
    if (!check_lfsr_pattern(27467969ul)) return;
    if (!check_lfsr_pattern(520563506ul)) return;
    if (!check_lfsr_pattern(381313790ul)) return;
    if (!check_lfsr_pattern(4174769276ul)) return;
    if (!check_lfsr_pattern(3932189449ul)) return;
    if (!check_lfsr_pattern(4079717394ul)) return;
    if (!check_lfsr_pattern(868357076ul)) return;
    if (!check_lfsr_pattern(2474062993ul)) return;
    if (!check_lfsr_pattern(1502682190ul)) return;
    if (!check_lfsr_pattern(2471230478ul)) return;
    if (!check_lfsr_pattern(85016565ul)) return;
    if (!check_lfsr_pattern(1427530695ul)) return;
    if (!check_lfsr_pattern(1100533073ul)) return;
    if (!check_fixed_pattern(0x55555555)) return;
    if (!check_fixed_pattern(0x33333333)) return;
    if (!check_fixed_pattern(0x0F0F0F0F)) return;
    if (!check_fixed_pattern(0x00FF00FF)) return;
    if (!check_fixed_pattern(0x0000FFFF)) return;
    if (!check_fixed_pattern(0xAAAAAAAA)) return;
    if (!check_fixed_pattern(0xCCCCCCCC)) return;
    if (!check_fixed_pattern(0xF0F0F0F0)) return;
    if (!check_fixed_pattern(0xFF00FF00)) return;
    if (!check_fixed_pattern(0xFFFF0000)) return;
    if (!check_fixed_pattern(0xFFFFFFFF)) return;
    if (!check_fixed_pattern(0x00000000)) return;
    Serial.printf(" test ran for %.2f seconds\n", (float)msec / 1000.0f);
    Serial.printf(" %d MB's test ran at %.2f MB/sec overall\n",
                  2 * rTCnt * external_psram_size,
                  2 * rTCnt * external_psram_size * 1024.0 / (float)msec);
    Serial.println("All memory tests passed :-)");
    memory_ok = true;
}

bool fail_message(volatile uint32_t* location, uint32_t actual,
                  uint32_t expected) {
    Serial.printf(" Error at %08X, read %08X but expected %08X\n",
                  (uint32_t)location, actual, expected);
    return false;
}

// fill the entire RAM with a fixed pattern, then check it
bool check_fixed_pattern(uint32_t pattern) {
    volatile uint32_t* p;
    Serial.printf("testing with fixed pattern %08X\t", pattern);
    rTime = micros();
    for (p = memory_begin; p < memory_end; p++) {
        *p = pattern;
    }
    rTime = micros() - rTime;
    Serial.printf("\tfill us:%d MB/s:%.2f\t", rTime,
                  external_psram_size * 1024 * 1024.0 / rTime);
    arm_dcache_flush_delete((void*)memory_begin,
                            (uint32_t)memory_end - (uint32_t)memory_begin);
    rTime = micros();
    for (p = memory_begin; p < memory_end; p++) {
        uint32_t actual = *p;
        if (actual != pattern) return fail_message(p, actual, pattern);
    }
    rTime = micros() - rTime;
    Serial.printf("\ttest us:%d MB/s:%.2f\n", rTime,
                  external_psram_size * 1024 * 1024.0 / rTime);
    rTCnt++;
    return true;
}

// fill the entire RAM with a pseudo-random sequence, then check it
bool check_lfsr_pattern(uint32_t seed) {
    volatile uint32_t* p;
    uint32_t reg;

    Serial.printf("testing with pseudo-random sequence, seed=%u\t", seed);
    reg = seed;
    uint32_t rTime;
    rTime = micros();
    for (p = memory_begin; p < memory_end; p++) {
        *p = reg;
        for (int i = 0; i < 3; i++) {
            if (reg & 1) {
                reg >>= 1;
                reg ^= 0x7A5BC2E3;
            } else {
                reg >>= 1;
            }
        }
    }
    rTime = micros() - rTime;
    Serial.printf("\tfill us:%d MB/s:%.2f\t", rTime,
                  external_psram_size * 1024 * 1024.0 / rTime);
    arm_dcache_flush_delete((void*)memory_begin,
                            (uint32_t)memory_end - (uint32_t)memory_begin);
    reg = seed;
    rTime = micros();
    for (p = memory_begin; p < memory_end; p++) {
        uint32_t actual = *p;
        if (actual != reg) return fail_message(p, actual, reg);
        // Serial.printf(" reg=%08X\n", reg);
        for (int i = 0; i < 3; i++) {
            if (reg & 1) {
                reg >>= 1;
                reg ^= 0x7A5BC2E3;
            } else {
                reg >>= 1;
            }
        }
    }
    rTime = micros() - rTime;
    Serial.printf("\ttest us:%d MB/s:%.2f\n", rTime,
                  external_psram_size * 1024 * 1024.0 / rTime);
    rTCnt++;
    return true;
}

void loop() {
    digitalWrite(13, HIGH);
    delay(100);
    if (!memory_ok) digitalWrite(13, LOW); // rapid blink if any test fails
    delay(100);
}
[@file: to_replace/usb_desc.c]
/* Teensyduino Core Library
 * http://www.pjrc.com/teensy/
 * Copyright (c) 2019 PJRC.COM, LLC.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * 1. The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * 2. If the Software is incorporated into a build system that allows
 * selection among a list of target devices, then similar target
 * devices manufactured by PJRC.COM must be included in the list of
 * target devices and selectable in the same manner.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

//#if F_CPU >= 20000000

#define USB_DESC_LIST_DEFINE
#include "usb_desc.h"
#ifdef NUM_ENDPOINTS
#include "usb_names.h"
#include "imxrt.h"
#include "avr_functions.h"
#include "avr/pgmspace.h"

// At very slow CPU speeds, the OCRAM just isn't fast enough for
// USB to work reliably.  But the precious/limited DTCM is.  So
// as an ugly workaround, undefine DMAMEM so all buffers which
// would normally be allocated in OCRAM are placed in DTCM.
#if defined(F_CPU) && F_CPU < 30000000
#undef DMAMEM
#endif

// USB Descriptors are binary data which the USB host reads to
// automatically detect a USB device's capabilities.  The format
// and meaning of every field is documented in numerous USB
// standards.  When working with USB descriptors, despite the
// complexity of the standards and poor writing quality in many
// of those documents, remember descriptors are nothing more
// than constant binary data that tells the USB host what the
// device can do.  Computers will load drivers based on this data.
// Those drivers then communicate on the endpoints specified by
// the descriptors.

// To configure a new combination of interfaces or make minor
// changes to existing configuration (eg, change the name or ID
// numbers), usually you would edit "usb_desc.h".  This file
// is meant to be configured by the header, so generally it is
// only edited to add completely new USB interfaces or features.



// **************************************************************
//   USB Device
// **************************************************************

#define LSB(n) ((n) & 255)
#define MSB(n) (((n) >> 8) & 255)

#ifdef CDC_IAD_DESCRIPTOR
#ifndef DEVICE_CLASS
#define DEVICE_CLASS 0xEF
#endif
#ifndef DEVICE_SUBCLASS
#define DEVICE_SUBCLASS 0x02
#endif
#ifndef DEVICE_PROTOCOL
#define DEVICE_PROTOCOL 0x01
#endif
#endif


// USB Device Descriptor.  The USB host reads this first, to learn
// what type of device is connected.
static uint8_t device_descriptor[] = {
        18,                                     // bLength
        1,                                      // bDescriptorType
        0x00, 0x02,                             // bcdUSB
#ifdef DEVICE_CLASS
        DEVICE_CLASS,                           // bDeviceClass
#else
    0,
#endif
#ifdef DEVICE_SUBCLASS
        DEVICE_SUBCLASS,                        // bDeviceSubClass
#else
    0,
#endif
#ifdef DEVICE_PROTOCOL
        DEVICE_PROTOCOL,                        // bDeviceProtocol
#else
    0,
#endif
        EP0_SIZE,                               // bMaxPacketSize0
        LSB(VENDOR_ID), MSB(VENDOR_ID),         // idVendor
        LSB(PRODUCT_ID), MSB(PRODUCT_ID),       // idProduct
#ifdef BCD_DEVICE
    LSB(BCD_DEVICE), MSB(BCD_DEVICE),       // bcdDevice
#else
  // For USB types that don't explicitly define BCD_DEVICE,
  // use the minor version number to help teensy_ports
  // identify which Teensy model is used.
  #if defined(__IMXRT1062__) && defined(ARDUINO_TEENSY40)
        0x79, 0x02, // Teensy 4.0
  #elif defined(__IMXRT1062__) && defined(ARDUINO_TEENSY41)
        0x80, 0x02, // Teensy 4.1
  #elif defined(__IMXRT1062__) && defined(ARDUINO_TEENSY_MICROMOD)
        0x81, 0x02, // Teensy MicroMod
  #else
        0x00, 0x02,
  #endif
#endif
        1,                                      // iManufacturer
        2,                                      // iProduct
        3,                                      // iSerialNumber
        1                                       // bNumConfigurations
};

PROGMEM static const uint8_t qualifier_descriptor[] = {    // 9.6.2 Device_Qualifier, page 264
    10,                    // bLength
    6,                    // bDescriptorType
    0x00, 0x02,                // bcdUSB
#ifdef DEVICE_CLASS
        DEVICE_CLASS,                           // bDeviceClass
#else
    0,
#endif
#ifdef DEVICE_SUBCLASS
        DEVICE_SUBCLASS,                        // bDeviceSubClass
#else
    0,
#endif
#ifdef DEVICE_PROTOCOL
        DEVICE_PROTOCOL,                        // bDeviceProtocol
#else
    0,
#endif
        EP0_SIZE,                               // bMaxPacketSize0
        1,                    // bNumConfigurations
        0                                       // bReserved
};

// These descriptors must NOT be "const", because the USB DMA
// has trouble accessing flash memory with enough bandwidth
// while the processor is executing from flash.



// **************************************************************
//   HID Report Descriptors
// **************************************************************

// Each HID interface needs a special report descriptor that tells
// the meaning and format of the data.

#ifdef KEYBOARD_INTERFACE
// Keyboard Protocol 1, HID 1.11 spec, Appendix B, page 59-60
static uint8_t keyboard_report_desc[] = {
        0x05, 0x01,                     // Usage Page (Generic Desktop),
        0x09, 0x06,                     // Usage (Keyboard),
        0xA1, 0x01,                     // Collection (Application),
        0x75, 0x01,                     //   Report Size (1),
        0x95, 0x08,                     //   Report Count (8),
        0x05, 0x07,                     //   Usage Page (Key Codes),
        0x19, 0xE0,                     //   Usage Minimum (224),
        0x29, 0xE7,                     //   Usage Maximum (231),
        0x15, 0x00,                     //   Logical Minimum (0),
        0x25, 0x01,                     //   Logical Maximum (1),
        0x81, 0x02,                     //   Input (Data, Variable, Absolute), ;Modifier keys
        0x95, 0x01,                     //   Report Count (1),
        0x75, 0x08,                     //   Report Size (8),
        0x81, 0x03,                     //   Input (Constant),          ;Reserved byte
        0x95, 0x05,                     //   Report Count (5),
        0x75, 0x01,                     //   Report Size (1),
        0x05, 0x08,                     //   Usage Page (LEDs),
        0x19, 0x01,                     //   Usage Minimum (1),
        0x29, 0x05,                     //   Usage Maximum (5),
        0x91, 0x02,                     //   Output (Data, Variable, Absolute), ;LED report
        0x95, 0x01,                     //   Report Count (1),
        0x75, 0x03,                     //   Report Size (3),
        0x91, 0x03,                     //   Output (Constant),         ;LED report padding
        0x95, KEYBOARD_SIZE-2,          //   Report Count (62),
        0x75, 0x08,                     //   Report Size (8),
        0x15, 0x00,                     //   Logical Minimum (0),
        0x25, 0x7F,                     //   Logical Maximum(104),
        0x05, 0x07,                     //   Usage Page (Key Codes),
        0x19, 0x00,                     //   Usage Minimum (0),
        0x29, 0x7F,                     //   Usage Maximum (104),
        0x81, 0x00,                     //   Input (Data, Array),       ;Normal keys
        0xC0                            // End Collection
};
#endif

#ifdef KEYMEDIA_INTERFACE
static uint8_t keymedia_report_desc[] = {
        0x05, 0x0C,                     // Usage Page (Consumer)
        0x09, 0x01,                     // Usage (Consumer Controls)
        0xA1, 0x01,                     // Collection (Application)
        0x75, 0x0A,                     //   Report Size (10)
        0x95, 0x04,                     //   Report Count (4)
        0x19, 0x00,                     //   Usage Minimum (0)
        0x2A, 0x9C, 0x02,               //   Usage Maximum (0x29C)
        0x15, 0x00,                     //   Logical Minimum (0)
        0x26, 0x9C, 0x02,               //   Logical Maximum (0x29C)
        0x81, 0x00,                     //   Input (Data, Array)
        0x05, 0x01,                     //   Usage Page (Generic Desktop)
        0x75, 0x08,                     //   Report Size (8)
        0x95, 0x03,                     //   Report Count (3)
        0x19, 0x00,                     //   Usage Minimum (0)
        0x29, 0xB7,                     //   Usage Maximum (0xB7)
        0x15, 0x00,                     //   Logical Minimum (0)
        0x26, 0xB7, 0x00,               //   Logical Maximum (0xB7)
        0x81, 0x00,                     //   Input (Data, Array)
        0xC0                            // End Collection
};
#endif

#ifdef MOUSE_INTERFACE
// Mouse Protocol 1, HID 1.11 spec, Appendix B, page 59-60, with wheel extension
static uint8_t mouse_report_desc[] = {
        0x05, 0x01,                     // Usage Page (Generic Desktop)
        0x09, 0x02,                     // Usage (Mouse)
        0xA1, 0x01,                     // Collection (Application)
        0x85, 0x01,                     //   REPORT_ID (1)
        0x05, 0x09,                     //   Usage Page (Button)
        0x19, 0x01,                     //   Usage Minimum (Button #1)
        0x29, 0x08,                     //   Usage Maximum (Button #8)
        0x15, 0x00,                     //   Logical Minimum (0)
        0x25, 0x01,                     //   Logical Maximum (1)
        0x95, 0x08,                     //   Report Count (8)
        0x75, 0x01,                     //   Report Size (1)
        0x81, 0x02,                     //   Input (Data, Variable, Absolute)
        0x05, 0x01,                     //   Usage Page (Generic Desktop)
        0x09, 0x30,                     //   Usage (X)
        0x09, 0x31,                     //   Usage (Y)
        0x09, 0x38,                     //   Usage (Wheel)
        0x15, 0x81,                     //   Logical Minimum (-127)
        0x25, 0x7F,                     //   Logical Maximum (127)
        0x75, 0x08,                     //   Report Size (8),
        0x95, 0x03,                     //   Report Count (3),
        0x81, 0x06,                     //   Input (Data, Variable, Relative)
        0x05, 0x0C,                     //   Usage Page (Consumer)
        0x0A, 0x38, 0x02,               //   Usage (AC Pan)
        0x15, 0x81,                     //   Logical Minimum (-127)
        0x25, 0x7F,                     //   Logical Maximum (127)
        0x75, 0x08,                     //   Report Size (8),
        0x95, 0x01,                     //   Report Count (1),
        0x81, 0x06,                     //   Input (Data, Variable, Relative)
        0xC0,                           // End Collection
        0x05, 0x01,                     // Usage Page (Generic Desktop)
        0x09, 0x02,                     // Usage (Mouse)
        0xA1, 0x01,                     // Collection (Application)
        0x85, 0x02,                     //   REPORT_ID (2)
        0x05, 0x01,                     //   Usage Page (Generic Desktop)
        0x09, 0x30,                     //   Usage (X)
        0x09, 0x31,                     //   Usage (Y)
        0x15, 0x00,                     //   Logical Minimum (0)
        0x26, 0xFF, 0x7F,               //   Logical Maximum (32767)
        0x75, 0x10,                     //   Report Size (16),
        0x95, 0x02,                     //   Report Count (2),
        0x81, 0x02,                     //   Input (Data, Variable, Absolute)
        0xC0                            // End Collection
};
#endif

#ifdef JOYSTICK_INTERFACE
#if JOYSTICK_SIZE == 12
static uint8_t joystick_report_desc[] = {
        0x05, 0x01,                     // Usage Page (Generic Desktop)
        0x09, 0x04,                     // Usage (Joystick)
        0xA1, 0x01,                     // Collection (Application)
        0x15, 0x00,                     //   Logical Minimum (0)
        0x25, 0x01,                     //   Logical Maximum (1)
        0x75, 0x01,                     //   Report Size (1)
        0x95, 0x20,                     //   Report Count (32)
        0x05, 0x09,                     //   Usage Page (Button)
        0x19, 0x01,                     //   Usage Minimum (Button #1)
        0x29, 0x20,                     //   Usage Maximum (Button #32)
        0x81, 0x02,                     //   Input (variable,absolute)
        0x15, 0x00,                     //   Logical Minimum (0)
        0x25, 0x07,                     //   Logical Maximum (7)
        0x35, 0x00,                     //   Physical Minimum (0)
        0x46, 0x3B, 0x01,               //   Physical Maximum (315)
        0x75, 0x04,                     //   Report Size (4)
        0x95, 0x01,                     //   Report Count (1)
        0x65, 0x14,                     //   Unit (20)
        0x05, 0x01,                     //   Usage Page (Generic Desktop)
        0x09, 0x39,                     //   Usage (Hat switch)
        0x81, 0x42,                     //   Input (variable,absolute,null_state)
        0x05, 0x01,                     //   Usage Page (Generic Desktop)
        0x09, 0x01,                     //   Usage (Pointer)
        0xA1, 0x00,                     //   Collection ()
        0x15, 0x00,                     //     Logical Minimum (0)
        0x26, 0xFF, 0x03,               //     Logical Maximum (1023)
        0x75, 0x0A,                     //     Report Size (10)
        0x95, 0x04,                     //     Report Count (4)
        0x09, 0x30,                     //     Usage (X)
        0x09, 0x31,                     //     Usage (Y)
        0x09, 0x32,                     //     Usage (Z)
        0x09, 0x35,                     //     Usage (Rz)
        0x81, 0x02,                     //     Input (variable,absolute)
        0xC0,                           //   End Collection
        0x15, 0x00,                     //   Logical Minimum (0)
        0x26, 0xFF, 0x03,               //   Logical Maximum (1023)
        0x75, 0x0A,                     //   Report Size (10)
        0x95, 0x02,                     //   Report Count (2)
        0x09, 0x36,                     //   Usage (Slider)
        0x09, 0x36,                     //   Usage (Slider)
        0x81, 0x02,                     //   Input (variable,absolute)
        0xC0                            // End Collection
};
#elif JOYSTICK_SIZE == 64
// extreme joystick  (to use this, edit JOYSTICK_SIZE to 64 in usb_desc.h)
//  128 buttons   16
//    6 axes      12
//   17 sliders   34
//    4 pov        2
static uint8_t joystick_report_desc[] = {
        0x05, 0x01,                     // Usage Page (Generic Desktop)
        0x09, 0x04,                     // Usage (Joystick)
        0xA1, 0x01,                     // Collection (Application)
        0x15, 0x00,                     // Logical Minimum (0)
        0x25, 0x01,                     // Logical Maximum (1)
        0x75, 0x01,                     // Report Size (1)
        0x95, 0x80,                     // Report Count (128)
        0x05, 0x09,                     // Usage Page (Button)
        0x19, 0x01,                     // Usage Minimum (Button #1)
        0x29, 0x80,                     // Usage Maximum (Button #128)
        0x81, 0x02,                     // Input (variable,absolute)
        0x05, 0x01,                     // Usage Page (Generic Desktop)
        0x09, 0x01,                     // Usage (Pointer)
        0xA1, 0x00,                     // Collection ()
        0x15, 0x00,                     // Logical Minimum (0)
        0x27, 0xFF, 0xFF, 0, 0,         // Logical Maximum (65535)
        0x75, 0x10,                     // Report Size (16)
        0x95, 23,                       // Report Count (23)
        0x09, 0x30,                     // Usage (X)
        0x09, 0x31,                     // Usage (Y)
        0x09, 0x32,                     // Usage (Z)
        0x09, 0x33,                     // Usage (Rx)
        0x09, 0x34,                     // Usage (Ry)
        0x09, 0x35,                     // Usage (Rz)
        0x09, 0x36,                     // Usage (Slider)
        0x09, 0x36,                     // Usage (Slider)
        0x09, 0x36,                     // Usage (Slider)
        0x09, 0x36,                     // Usage (Slider)
        0x09, 0x36,                     // Usage (Slider)
        0x09, 0x36,                     // Usage (Slider)
        0x09, 0x36,                     // Usage (Slider)
        0x09, 0x36,                     // Usage (Slider)
        0x09, 0x36,                     // Usage (Slider)
        0x09, 0x36,                     // Usage (Slider)
        0x09, 0x36,                     // Usage (Slider)
        0x09, 0x36,                     // Usage (Slider)
        0x09, 0x36,                     // Usage (Slider)
        0x09, 0x36,                     // Usage (Slider)
        0x09, 0x36,                     // Usage (Slider)
        0x09, 0x36,                     // Usage (Slider)
        0x09, 0x36,                     // Usage (Slider)
        0x81, 0x02,                     // Input (variable,absolute)
        0xC0,                           // End Collection
        0x15, 0x00,                     // Logical Minimum (0)
        0x25, 0x07,                     // Logical Maximum (7)
        0x35, 0x00,                     // Physical Minimum (0)
        0x46, 0x3B, 0x01,               // Physical Maximum (315)
        0x75, 0x04,                     // Report Size (4)
        0x95, 0x04,                     // Report Count (4)
        0x65, 0x14,                     // Unit (20)
        0x05, 0x01,                     // Usage Page (Generic Desktop)
        0x09, 0x39,                     // Usage (Hat switch)
        0x09, 0x39,                     // Usage (Hat switch)
        0x09, 0x39,                     // Usage (Hat switch)
        0x09, 0x39,                     // Usage (Hat switch)
        0x81, 0x42,                     // Input (variable,absolute,null_state)
        0xC0                            // End Collection
};
#endif // JOYSTICK_SIZE
#endif // JOYSTICK_INTERFACE

#ifdef MULTITOUCH_INTERFACE
// https://forum.pjrc.com/threads/32331-USB-HID-Touchscreen-support-needed
// https://msdn.microsoft.com/en-us/library/windows/hardware/jj151563%28v=vs.85%29.aspx
// https://msdn.microsoft.com/en-us/library/windows/hardware/jj151565%28v=vs.85%29.aspx
// https://msdn.microsoft.com/en-us/library/windows/hardware/ff553734%28v=vs.85%29.aspx
// https://msdn.microsoft.com/en-us/library/windows/hardware/jj151564%28v=vs.85%29.aspx
// download.microsoft.com/download/a/d/f/adf1347d-08dc-41a4-9084-623b1194d4b2/digitizerdrvs_touch.docx
static uint8_t multitouch_report_desc[] = {
        0x05, 0x0D,                     // Usage Page (Digitizer)
        0x09, 0x04,                     // Usage (Touch Screen)
        0xa1, 0x01,                     // Collection (Application)
        0x09, 0x22,                     //   Usage (Finger)
        0xA1, 0x02,                     //   Collection (Logical)
        0x09, 0x42,                     //     Usage (Tip Switch)
        0x15, 0x00,                     //     Logical Minimum (0)
        0x25, 0x01,                     //     Logical Maximum (1)
        0x75, 0x01,                     //     Report Size (1)
        0x95, 0x01,                     //     Report Count (1)
        0x81, 0x02,                     //     Input (variable,absolute)
        0x09, 0x51,                     //     Usage (Contact Identifier)
        0x25, 0x7F,                     //     Logical Maximum (127)
        0x75, 0x07,                     //     Report Size (7)
        0x95, 0x01,                     //     Report Count (1)
        0x81, 0x02,                     //     Input (variable,absolute)
        0x09, 0x30,                     //     Usage (Pressure)
        0x26, 0xFF, 0x00,               //     Logical Maximum (255)
        0x75, 0x08,                     //     Report Size (8)
        0x95, 0x01,                     //     Report Count (1)
        0x81, 0x02,                     //     Input (variable,absolute)
        0x05, 0x01,                     //     Usage Page (Generic Desktop)
        0x09, 0x30,                     //     Usage (X)
        0x09, 0x31,                     //     Usage (Y)
        0x26, 0xFF, 0x7F,               //     Logical Maximum (32767)
        0x65, 0x00,                     //     Unit (None)  <-- probably needs real units?
        0x75, 0x10,                     //     Report Size (16)
        0x95, 0x02,                     //     Report Count (2)
        0x81, 0x02,                     //     Input (variable,absolute)
        0xC0,                           //   End Collection
        0x05, 0x0D,                     //   Usage Page (Digitizer)
        0x27, 0xFF, 0xFF, 0, 0,         //   Logical Maximum (65535)
        0x75, 0x10,                     //   Report Size (16)
        0x95, 0x01,                     //   Report Count (1)
        0x09, 0x56,                     //   Usage (Scan Time)
        0x81, 0x02,                     //   Input (variable,absolute)
        0x09, 0x54,                     //   USAGE (Contact count)
        0x25, 0x7f,                     //   LOGICAL_MAXIMUM (127)
        0x95, 0x01,                     //   REPORT_COUNT (1)
        0x75, 0x08,                     //   REPORT_SIZE (8)
        0x81, 0x02,                     //   INPUT (Data,Var,Abs)
        0x05, 0x0D,                     //   Usage Page (Digitizers)
        0x09, 0x55,                     //   Usage (Contact Count Maximum)
        0x25, MULTITOUCH_FINGERS,       //   Logical Maximum (10)
        0x75, 0x08,                     //   Report Size (8)
        0x95, 0x01,                     //   Report Count (1)
        0xB1, 0x02,                     //   Feature (variable,absolute)
        0xC0                            // End Collection
};
#endif

#ifdef SEREMU_INTERFACE
static uint8_t seremu_report_desc[] = {
        0x06, 0xC9, 0xFF,               // Usage Page 0xFFC9 (vendor defined)
        0x09, 0x04,                     // Usage 0x04
        0xA1, 0x5C,                     // Collection 0x5C
        0x75, 0x08,                     //   report size = 8 bits (global)
        0x15, 0x00,                     //   logical minimum = 0 (global)
        0x26, 0xFF, 0x00,               //   logical maximum = 255 (global)
        0x95, SEREMU_TX_SIZE,           //   report count (global)
        0x09, 0x75,                     //   usage (local)
        0x81, 0x02,                     //   Input
        0x95, SEREMU_RX_SIZE,           //   report count (global)
        0x09, 0x76,                     //   usage (local)
        0x91, 0x02,                     //   Output
        0x95, 0x04,                     //   report count (global)
        0x09, 0x76,                     //   usage (local)
        0xB1, 0x02,                     //   Feature
        0xC0                            // end collection
};
#endif

#ifdef RAWHID_INTERFACE
static uint8_t rawhid_report_desc[] = {
        0x06, LSB(RAWHID_USAGE_PAGE), MSB(RAWHID_USAGE_PAGE),
        0x0A, LSB(RAWHID_USAGE), MSB(RAWHID_USAGE),
        0xA1, 0x01,                     // Collection 0x01
        0x75, 0x08,                     //   report size = 8 bits
        0x15, 0x00,                     //   logical minimum = 0
        0x26, 0xFF, 0x00,               //   logical maximum = 255
        0x95, RAWHID_TX_SIZE,           //   report count
        0x09, 0x01,                     //   usage
        0x81, 0x02,                     //   Input (array)
        0x95, RAWHID_RX_SIZE,           //   report count
        0x09, 0x02,                     //   usage
        0x91, 0x02,                     //   Output (array)
        0xC0                            // end collection
};
#endif

#ifdef FLIGHTSIM_INTERFACE
static uint8_t flightsim_report_desc[] = {
        0x06, 0x1C, 0xFF,               // Usage page = 0xFF1C
        0x0A, 0x39, 0xA7,               // Usage = 0xA739
        0xA1, 0x01,                     // Collection 0x01
        0x75, 0x08,                     //   report size = 8 bits
        0x15, 0x00,                     //   logical minimum = 0
        0x26, 0xFF, 0x00,               //   logical maximum = 255
        0x95, FLIGHTSIM_TX_SIZE,        //   report count
        0x09, 0x01,                     //   usage
        0x81, 0x02,                     //   Input (array)
        0x95, FLIGHTSIM_RX_SIZE,        //   report count
        0x09, 0x02,                     //   usage
        0x91, 0x02,                     //   Output (array)
        0xC0                            // end collection
};
#endif


// **************************************************************
//   USB Descriptor Sizes
// **************************************************************

// pre-compute the size and position of everything in the config descriptor
//
#define CONFIG_HEADER_DESCRIPTOR_SIZE    9

#define CDC_IAD_DESCRIPTOR_POS        CONFIG_HEADER_DESCRIPTOR_SIZE
#ifdef  CDC_IAD_DESCRIPTOR
#define CDC_IAD_DESCRIPTOR_SIZE        8
#else
#define CDC_IAD_DESCRIPTOR_SIZE        0
#endif

#define CDC_DATA_INTERFACE_DESC_POS    CDC_IAD_DESCRIPTOR_POS+CDC_IAD_DESCRIPTOR_SIZE
#ifdef  CDC_DATA_INTERFACE
#define CDC_DATA_INTERFACE_DESC_SIZE    9+5+5+4+5+7+9+7+7
#else
#define CDC_DATA_INTERFACE_DESC_SIZE    0
#endif

#define CDC2_DATA_INTERFACE_DESC_POS    CDC_DATA_INTERFACE_DESC_POS+CDC_DATA_INTERFACE_DESC_SIZE
#ifdef  CDC2_DATA_INTERFACE
#define CDC2_DATA_INTERFACE_DESC_SIZE   8 + 9+5+5+4+5+7+9+7+7
#else
#define CDC2_DATA_INTERFACE_DESC_SIZE   0
#endif

#define CDC3_DATA_INTERFACE_DESC_POS    CDC2_DATA_INTERFACE_DESC_POS+CDC2_DATA_INTERFACE_DESC_SIZE
#ifdef  CDC3_DATA_INTERFACE
#define CDC3_DATA_INTERFACE_DESC_SIZE   8 + 9+5+5+4+5+7+9+7+7
#else
#define CDC3_DATA_INTERFACE_DESC_SIZE   0
#endif

#define MIDI_INTERFACE_DESC_POS        CDC3_DATA_INTERFACE_DESC_POS+CDC3_DATA_INTERFACE_DESC_SIZE
#ifdef  MIDI_INTERFACE
  #if !defined(MIDI_NUM_CABLES) || MIDI_NUM_CABLES < 1 || MIDI_NUM_CABLES > 16
  #error "MIDI_NUM_CABLES must be defined between 1 to 16"
  #endif
#define MIDI_INTERFACE_DESC_SIZE    9+7+((6+6+9+9)*MIDI_NUM_CABLES)+(9+4+MIDI_NUM_CABLES)*2
#else
#define MIDI_INTERFACE_DESC_SIZE    0
#endif

#define KEYBOARD_INTERFACE_DESC_POS    MIDI_INTERFACE_DESC_POS+MIDI_INTERFACE_DESC_SIZE
#ifdef  KEYBOARD_INTERFACE
#define KEYBOARD_INTERFACE_DESC_SIZE    9+9+7
#define KEYBOARD_HID_DESC_OFFSET    KEYBOARD_INTERFACE_DESC_POS+9
#else
#define KEYBOARD_INTERFACE_DESC_SIZE    0
#endif

#define MOUSE_INTERFACE_DESC_POS    KEYBOARD_INTERFACE_DESC_POS+KEYBOARD_INTERFACE_DESC_SIZE
#ifdef  MOUSE_INTERFACE
#define MOUSE_INTERFACE_DESC_SIZE    9+9+7
#define MOUSE_HID_DESC_OFFSET        MOUSE_INTERFACE_DESC_POS+9
#else
#define MOUSE_INTERFACE_DESC_SIZE    0
#endif

#define RAWHID_INTERFACE_DESC_POS    MOUSE_INTERFACE_DESC_POS+MOUSE_INTERFACE_DESC_SIZE
#ifdef  RAWHID_INTERFACE
#define RAWHID_INTERFACE_DESC_SIZE    9+9+7+7
#define RAWHID_HID_DESC_OFFSET        RAWHID_INTERFACE_DESC_POS+9
#else
#define RAWHID_INTERFACE_DESC_SIZE    0
#endif

#define FLIGHTSIM_INTERFACE_DESC_POS    RAWHID_INTERFACE_DESC_POS+RAWHID_INTERFACE_DESC_SIZE
#ifdef  FLIGHTSIM_INTERFACE
#define FLIGHTSIM_INTERFACE_DESC_SIZE    9+9+7+7
#define FLIGHTSIM_HID_DESC_OFFSET    FLIGHTSIM_INTERFACE_DESC_POS+9
#else
#define FLIGHTSIM_INTERFACE_DESC_SIZE    0
#endif

#define SEREMU_INTERFACE_DESC_POS    FLIGHTSIM_INTERFACE_DESC_POS+FLIGHTSIM_INTERFACE_DESC_SIZE
#ifdef  SEREMU_INTERFACE
#define SEREMU_INTERFACE_DESC_SIZE    9+9+7+7
#define SEREMU_HID_DESC_OFFSET        SEREMU_INTERFACE_DESC_POS+9
#else
#define SEREMU_INTERFACE_DESC_SIZE    0
#endif

#define JOYSTICK_INTERFACE_DESC_POS    SEREMU_INTERFACE_DESC_POS+SEREMU_INTERFACE_DESC_SIZE
#ifdef  JOYSTICK_INTERFACE
#define JOYSTICK_INTERFACE_DESC_SIZE    9+9+7
#define JOYSTICK_HID_DESC_OFFSET    JOYSTICK_INTERFACE_DESC_POS+9
#else
#define JOYSTICK_INTERFACE_DESC_SIZE    0
#endif

#define MTP_INTERFACE_DESC_POS        JOYSTICK_INTERFACE_DESC_POS+JOYSTICK_INTERFACE_DESC_SIZE
#ifdef  MTP_INTERFACE
#define MTP_INTERFACE_DESC_SIZE        9+7+7+7
#else
#define MTP_INTERFACE_DESC_SIZE    0
#endif

#define KEYMEDIA_INTERFACE_DESC_POS    MTP_INTERFACE_DESC_POS+MTP_INTERFACE_DESC_SIZE
#ifdef  KEYMEDIA_INTERFACE
#define KEYMEDIA_INTERFACE_DESC_SIZE    9+9+7
#define KEYMEDIA_HID_DESC_OFFSET    KEYMEDIA_INTERFACE_DESC_POS+9
#else
#define KEYMEDIA_INTERFACE_DESC_SIZE    0
#endif

#define AUDIO_INTERFACE_DESC_POS    KEYMEDIA_INTERFACE_DESC_POS+KEYMEDIA_INTERFACE_DESC_SIZE
#ifdef  AUDIO_INTERFACE
#define AUDIO_INTERFACE_DESC_SIZE    8 + 9+10+12+9+12+10+9 + 9+9+7+11+9+7 + 9+9+7+11+9+7+9
#else
#define AUDIO_INTERFACE_DESC_SIZE    0
#endif

#define MULTITOUCH_INTERFACE_DESC_POS    AUDIO_INTERFACE_DESC_POS+AUDIO_INTERFACE_DESC_SIZE
#ifdef  MULTITOUCH_INTERFACE
#define MULTITOUCH_INTERFACE_DESC_SIZE    9+9+7
#define MULTITOUCH_HID_DESC_OFFSET    MULTITOUCH_INTERFACE_DESC_POS+9
#else
#define MULTITOUCH_INTERFACE_DESC_SIZE    0
#endif

#define EXPERIMENTAL_INTERFACE_DESC_POS    MULTITOUCH_INTERFACE_DESC_POS+MULTITOUCH_INTERFACE_DESC_SIZE
#ifdef  EXPERIMENTAL_INTERFACE
#define EXPERIMENTAL_INTERFACE_DESC_SIZE 9+7+7
#define EXPERIMENTAL_HID_DESC_OFFSET    MULTITOUCH_INTERFACE_DESC_POS+9
#else
#define EXPERIMENTAL_INTERFACE_DESC_SIZE 0
#endif

#define CONFIG_DESC_SIZE        EXPERIMENTAL_INTERFACE_DESC_POS+EXPERIMENTAL_INTERFACE_DESC_SIZE



// **************************************************************
//   USB Configuration
// **************************************************************

// USB Configuration Descriptor.  This huge descriptor tells all
// of the devices capabilities.

PROGMEM const uint8_t usb_config_descriptor_480[CONFIG_DESC_SIZE] = {
        // configuration descriptor, USB spec 9.6.3, page 264-266, Table 9-10
        9,                                      // bLength;
        2,                                      // bDescriptorType;
        LSB(CONFIG_DESC_SIZE),                 // wTotalLength
        MSB(CONFIG_DESC_SIZE),
        NUM_INTERFACE,                          // bNumInterfaces
        1,                                      // bConfigurationValue
        0,                                      // iConfiguration
        0xC0,                                   // bmAttributes
        50,                                     // bMaxPower

#ifdef CDC_IAD_DESCRIPTOR
        // interface association descriptor, USB ECN, Table 9-Z
        8,                                      // bLength
        11,                                     // bDescriptorType
        CDC_STATUS_INTERFACE,                   // bFirstInterface
        2,                                      // bInterfaceCount
        0x02,                                   // bFunctionClass
        0x02,                                   // bFunctionSubClass
        0x01,                                   // bFunctionProtocol
        0,                                      // iFunction
#endif

#ifdef CDC_DATA_INTERFACE
    // configuration for 480 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        CDC_STATUS_INTERFACE,            // bInterfaceNumber
        0,                                      // bAlternateSetting
        1,                                      // bNumEndpoints
        0x02,                                   // bInterfaceClass
        0x02,                                   // bInterfaceSubClass
        0x01,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // CDC Header Functional Descriptor, CDC Spec 5.2.3.1, Table 26
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x00,                                   // bDescriptorSubtype
        0x10, 0x01,                             // bcdCDC
        // Call Management Functional Descriptor, CDC Spec 5.2.3.2, Table 27
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x01,                                   // bDescriptorSubtype
        0x01,                                   // bmCapabilities
        1,                                      // bDataInterface
        // Abstract Control Management Functional Descriptor, CDC Spec 5.2.3.3, Table 28
        4,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x02,                                   // bDescriptorSubtype
        0x06,                                   // bmCapabilities
        // Union Functional Descriptor, CDC Spec 5.2.3.8, Table 33
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x06,                                   // bDescriptorSubtype
        CDC_STATUS_INTERFACE,                   // bMasterInterface
        CDC_DATA_INTERFACE,                     // bSlaveInterface0
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC_ACM_ENDPOINT | 0x80,                // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        LSB(CDC_ACM_SIZE),MSB(CDC_ACM_SIZE),    // wMaxPacketSize
        5,                                      // bInterval
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        CDC_DATA_INTERFACE,                     // bInterfaceNumber
        0,                                      // bAlternateSetting
        2,                                      // bNumEndpoints
        0x0A,                                   // bInterfaceClass
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC_RX_ENDPOINT,                        // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(CDC_RX_SIZE_480),MSB(CDC_RX_SIZE_480),// wMaxPacketSize
        0,                                      // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC_TX_ENDPOINT | 0x80,                 // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(CDC_TX_SIZE_480),MSB(CDC_TX_SIZE_480),// wMaxPacketSize
        0,                                      // bInterval
#endif // CDC_DATA_INTERFACE

#ifdef CDC2_DATA_INTERFACE
    // configuration for 480 Mbit/sec speed
        // interface association descriptor, USB ECN, Table 9-Z
        8,                                      // bLength
        11,                                     // bDescriptorType
        CDC2_STATUS_INTERFACE,                  // bFirstInterface
        2,                                      // bInterfaceCount
        0x02,                                   // bFunctionClass
        0x02,                                   // bFunctionSubClass
        0x01,                                   // bFunctionProtocol
        0,                                      // iFunction
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        CDC2_STATUS_INTERFACE,                  // bInterfaceNumber
        0,                                      // bAlternateSetting
        1,                                      // bNumEndpoints
        0x02,                                   // bInterfaceClass
        0x02,                                   // bInterfaceSubClass
        0x01,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // CDC Header Functional Descriptor, CDC Spec 5.2.3.1, Table 26
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x00,                                   // bDescriptorSubtype
        0x10, 0x01,                             // bcdCDC
        // Call Management Functional Descriptor, CDC Spec 5.2.3.2, Table 27
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x01,                                   // bDescriptorSubtype
        0x01,                                   // bmCapabilities
        1,                                      // bDataInterface
        // Abstract Control Management Functional Descriptor, CDC Spec 5.2.3.3, Table 28
        4,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x02,                                   // bDescriptorSubtype
        0x06,                                   // bmCapabilities
        // Union Functional Descriptor, CDC Spec 5.2.3.8, Table 33
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x06,                                   // bDescriptorSubtype
        CDC2_STATUS_INTERFACE,                  // bMasterInterface
        CDC2_DATA_INTERFACE,                    // bSlaveInterface0
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC2_ACM_ENDPOINT | 0x80,               // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        CDC_ACM_SIZE, 0,                        // wMaxPacketSize
        5,                                      // bInterval
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        CDC2_DATA_INTERFACE,                    // bInterfaceNumber
        0,                                      // bAlternateSetting
        2,                                      // bNumEndpoints
        0x0A,                                   // bInterfaceClass
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC2_RX_ENDPOINT,                       // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(CDC_RX_SIZE_480),MSB(CDC_RX_SIZE_480),// wMaxPacketSize
        0,                                      // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC2_TX_ENDPOINT | 0x80,                // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(CDC_TX_SIZE_480),MSB(CDC_TX_SIZE_480),// wMaxPacketSize
        0,                                      // bInterval
#endif // CDC2_DATA_INTERFACE

#ifdef CDC3_DATA_INTERFACE
    // configuration for 480 Mbit/sec speed
        // interface association descriptor, USB ECN, Table 9-Z
        8,                                      // bLength
        11,                                     // bDescriptorType
        CDC3_STATUS_INTERFACE,                  // bFirstInterface
        2,                                      // bInterfaceCount
        0x02,                                   // bFunctionClass
        0x02,                                   // bFunctionSubClass
        0x01,                                   // bFunctionProtocol
        0,                                      // iFunction
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        CDC3_STATUS_INTERFACE,                  // bInterfaceNumber
        0,                                      // bAlternateSetting
        1,                                      // bNumEndpoints
        0x02,                                   // bInterfaceClass
        0x02,                                   // bInterfaceSubClass
        0x01,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // CDC Header Functional Descriptor, CDC Spec 5.2.3.1, Table 26
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x00,                                   // bDescriptorSubtype
        0x10, 0x01,                             // bcdCDC
        // Call Management Functional Descriptor, CDC Spec 5.2.3.2, Table 27
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x01,                                   // bDescriptorSubtype
        0x01,                                   // bmCapabilities
        1,                                      // bDataInterface
        // Abstract Control Management Functional Descriptor, CDC Spec 5.2.3.3, Table 28
        4,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x02,                                   // bDescriptorSubtype
        0x06,                                   // bmCapabilities
        // Union Functional Descriptor, CDC Spec 5.2.3.8, Table 33
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x06,                                   // bDescriptorSubtype
        CDC3_STATUS_INTERFACE,                  // bMasterInterface
        CDC3_DATA_INTERFACE,                    // bSlaveInterface0
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC3_ACM_ENDPOINT | 0x80,               // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        CDC_ACM_SIZE, 0,                        // wMaxPacketSize
        5,                                      // bInterval
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        CDC3_DATA_INTERFACE,                    // bInterfaceNumber
        0,                                      // bAlternateSetting
        2,                                      // bNumEndpoints
        0x0A,                                   // bInterfaceClass
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC3_RX_ENDPOINT,                       // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(CDC_RX_SIZE_480),MSB(CDC_RX_SIZE_480),// wMaxPacketSize
        0,                                      // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC3_TX_ENDPOINT | 0x80,                // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(CDC_TX_SIZE_480),MSB(CDC_TX_SIZE_480),// wMaxPacketSize
        0,                                      // bInterval
#endif // CDC3_DATA_INTERFACE

#ifdef MIDI_INTERFACE
    // configuration for 480 Mbit/sec speed
        // Standard MS Interface Descriptor,
        9,                                      // bLength
        4,                                      // bDescriptorType
        MIDI_INTERFACE,                         // bInterfaceNumber
        0,                                      // bAlternateSetting
        2,                                      // bNumEndpoints
        0x01,                                   // bInterfaceClass (0x01 = Audio)
        0x03,                                   // bInterfaceSubClass (0x03 = MIDI)
        0x00,                                   // bInterfaceProtocol (unused for MIDI)
        0,                                      // iInterface
        // MIDI MS Interface Header, USB MIDI 6.1.2.1, page 21, Table 6-2
        7,                                      // bLength
        0x24,                                   // bDescriptorType = CS_INTERFACE
        0x01,                                   // bDescriptorSubtype = MS_HEADER
        0x00, 0x01,                             // bcdMSC = revision 01.00
    LSB(7+(6+6+9+9)*MIDI_NUM_CABLES),       // wTotalLength
    MSB(7+(6+6+9+9)*MIDI_NUM_CABLES),
        // MIDI IN Jack Descriptor, B.4.3, Table B-7 (embedded), page 40
        6,                                      // bLength
        0x24,                                   // bDescriptorType = CS_INTERFACE
        0x02,                                   // bDescriptorSubtype = MIDI_IN_JACK
        0x01,                                   // bJackType = EMBEDDED
        1,                                      // bJackID, ID = 1
        0,                                      // iJack
        // MIDI IN Jack Descriptor, B.4.3, Table B-8 (external), page 40
        6,                                      // bLength
        0x24,                                   // bDescriptorType = CS_INTERFACE
        0x02,                                   // bDescriptorSubtype = MIDI_IN_JACK
        0x02,                                   // bJackType = EXTERNAL
        2,                                      // bJackID, ID = 2
        0,                                      // iJack
        // MIDI OUT Jack Descriptor, B.4.4, Table B-9, page 41
        9,
        0x24,                                   // bDescriptorType = CS_INTERFACE
        0x03,                                   // bDescriptorSubtype = MIDI_OUT_JACK
        0x01,                                   // bJackType = EMBEDDED
        3,                                      // bJackID, ID = 3
        1,                                      // bNrInputPins = 1 pin
        2,                                      // BaSourceID(1) = 2
        1,                                      // BaSourcePin(1) = first pin
        0,                                      // iJack
        // MIDI OUT Jack Descriptor, B.4.4, Table B-10, page 41
        9,
        0x24,                                   // bDescriptorType = CS_INTERFACE
        0x03,                                   // bDescriptorSubtype = MIDI_OUT_JACK
        0x02,                                   // bJackType = EXTERNAL
        4,                                      // bJackID, ID = 4
        1,                                      // bNrInputPins = 1 pin
        1,                                      // BaSourceID(1) = 1
        1,                                      // BaSourcePin(1) = first pin
        0,                                      // iJack
  #if MIDI_NUM_CABLES >= 2
    #define MIDI_INTERFACE_JACK_PAIR(a, b, c, d) \
        6, 0x24, 0x02, 0x01, (a), 0, \
        6, 0x24, 0x02, 0x02, (b), 0, \
        9, 0x24, 0x03, 0x01, (c), 1, (b), 1, 0, \
        9, 0x24, 0x03, 0x02, (d), 1, (a), 1, 0,
    MIDI_INTERFACE_JACK_PAIR(5, 6, 7, 8)
  #endif
  #if MIDI_NUM_CABLES >= 3
    MIDI_INTERFACE_JACK_PAIR(9, 10, 11, 12)
  #endif
  #if MIDI_NUM_CABLES >= 4
    MIDI_INTERFACE_JACK_PAIR(13, 14, 15, 16)
  #endif
  #if MIDI_NUM_CABLES >= 5
    MIDI_INTERFACE_JACK_PAIR(17, 18, 19, 20)
  #endif
  #if MIDI_NUM_CABLES >= 6
    MIDI_INTERFACE_JACK_PAIR(21, 22, 23, 24)
  #endif
  #if MIDI_NUM_CABLES >= 7
    MIDI_INTERFACE_JACK_PAIR(25, 26, 27, 28)
  #endif
  #if MIDI_NUM_CABLES >= 8
    MIDI_INTERFACE_JACK_PAIR(29, 30, 31, 32)
  #endif
  #if MIDI_NUM_CABLES >= 9
    MIDI_INTERFACE_JACK_PAIR(33, 34, 35, 36)
  #endif
  #if MIDI_NUM_CABLES >= 10
    MIDI_INTERFACE_JACK_PAIR(37, 38, 39, 40)
  #endif
  #if MIDI_NUM_CABLES >= 11
    MIDI_INTERFACE_JACK_PAIR(41, 42, 43, 44)
  #endif
  #if MIDI_NUM_CABLES >= 12
    MIDI_INTERFACE_JACK_PAIR(45, 46, 47, 48)
  #endif
  #if MIDI_NUM_CABLES >= 13
    MIDI_INTERFACE_JACK_PAIR(49, 50, 51, 52)
  #endif
  #if MIDI_NUM_CABLES >= 14
    MIDI_INTERFACE_JACK_PAIR(53, 54, 55, 56)
  #endif
  #if MIDI_NUM_CABLES >= 15
    MIDI_INTERFACE_JACK_PAIR(57, 58, 59, 60)
  #endif
  #if MIDI_NUM_CABLES >= 16
    MIDI_INTERFACE_JACK_PAIR(61, 62, 63, 64)
  #endif
        // Standard Bulk OUT Endpoint Descriptor, B.5.1, Table B-11, pae 42
        9,                                      // bLength
        5,                                      // bDescriptorType = ENDPOINT
        MIDI_RX_ENDPOINT,                       // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(MIDI_RX_SIZE_480),MSB(MIDI_RX_SIZE_480),// wMaxPacketSize
        0,                                      // bInterval
        0,                                      // bRefresh
        0,                                      // bSynchAddress
        // Class-specific MS Bulk OUT Endpoint Descriptor, B.5.2, Table B-12, page 42
        4+MIDI_NUM_CABLES,                      // bLength
        0x25,                                   // bDescriptorSubtype = CS_ENDPOINT
        0x01,                                   // bJackType = MS_GENERAL
        MIDI_NUM_CABLES,                        // bNumEmbMIDIJack = number of jacks
        1,                                      // BaAssocJackID(1) = jack ID #1
  #if MIDI_NUM_CABLES >= 2
        5,
  #endif
  #if MIDI_NUM_CABLES >= 3
        9,
  #endif
  #if MIDI_NUM_CABLES >= 4
        13,
  #endif
  #if MIDI_NUM_CABLES >= 5
        17,
  #endif
  #if MIDI_NUM_CABLES >= 6
        21,
  #endif
  #if MIDI_NUM_CABLES >= 7
        25,
  #endif
  #if MIDI_NUM_CABLES >= 8
        29,
  #endif
  #if MIDI_NUM_CABLES >= 9
        33,
  #endif
  #if MIDI_NUM_CABLES >= 10
        37,
  #endif
  #if MIDI_NUM_CABLES >= 11
        41,
  #endif
  #if MIDI_NUM_CABLES >= 12
        45,
  #endif
  #if MIDI_NUM_CABLES >= 13
        49,
  #endif
  #if MIDI_NUM_CABLES >= 14
        53,
  #endif
  #if MIDI_NUM_CABLES >= 15
        57,
  #endif
  #if MIDI_NUM_CABLES >= 16
        61,
  #endif
        // Standard Bulk IN Endpoint Descriptor, B.5.1, Table B-11, pae 42
        9,                                      // bLength
        5,                                      // bDescriptorType = ENDPOINT
        MIDI_TX_ENDPOINT | 0x80,                // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(MIDI_TX_SIZE_480),MSB(MIDI_TX_SIZE_480),// wMaxPacketSize
        0,                                      // bInterval
        0,                                      // bRefresh
        0,                                      // bSynchAddress
        // Class-specific MS Bulk IN Endpoint Descriptor, B.5.2, Table B-12, page 42
        4+MIDI_NUM_CABLES,                      // bLength
        0x25,                                   // bDescriptorSubtype = CS_ENDPOINT
        0x01,                                   // bJackType = MS_GENERAL
        MIDI_NUM_CABLES,                        // bNumEmbMIDIJack = number of jacks
        3,                                      // BaAssocJackID(1) = jack ID #3
  #if MIDI_NUM_CABLES >= 2
        7,
  #endif
  #if MIDI_NUM_CABLES >= 3
        11,
  #endif
  #if MIDI_NUM_CABLES >= 4
        15,
  #endif
  #if MIDI_NUM_CABLES >= 5
        19,
  #endif
  #if MIDI_NUM_CABLES >= 6
        23,
  #endif
  #if MIDI_NUM_CABLES >= 7
        27,
  #endif
  #if MIDI_NUM_CABLES >= 8
        31,
  #endif
  #if MIDI_NUM_CABLES >= 9
        35,
  #endif
  #if MIDI_NUM_CABLES >= 10
        39,
  #endif
  #if MIDI_NUM_CABLES >= 11
        43,
  #endif
  #if MIDI_NUM_CABLES >= 12
        47,
  #endif
  #if MIDI_NUM_CABLES >= 13
        51,
  #endif
  #if MIDI_NUM_CABLES >= 14
        55,
  #endif
  #if MIDI_NUM_CABLES >= 15
        59,
  #endif
  #if MIDI_NUM_CABLES >= 16
        63,
  #endif
#endif // MIDI_INTERFACE

#ifdef KEYBOARD_INTERFACE
    // configuration for 480 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        KEYBOARD_INTERFACE,                     // bInterfaceNumber
        0,                                      // bAlternateSetting
        1,                                      // bNumEndpoints
        0x03,                                   // bInterfaceClass (0x03 = HID)
        0x01,                                   // bInterfaceSubClass (0x01 = Boot)
        0x01,                                   // bInterfaceProtocol (0x01 = Keyboard)
        0,                                      // iInterface
        // HID interface descriptor, HID 1.11 spec, section 6.2.1
        9,                                      // bLength
        0x21,                                   // bDescriptorType
        0x11, 0x01,                             // bcdHID
        0,                                      // bCountryCode
        1,                                      // bNumDescriptors
        0x22,                                   // bDescriptorType
        LSB(sizeof(keyboard_report_desc)),      // wDescriptorLength
        MSB(sizeof(keyboard_report_desc)),
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        KEYBOARD_ENDPOINT | 0x80,               // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        KEYBOARD_SIZE, 0,                       // wMaxPacketSize
        KEYBOARD_INTERVAL,                      // bInterval
#endif // KEYBOARD_INTERFACE

#ifdef MOUSE_INTERFACE
    // configuration for 480 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        MOUSE_INTERFACE,                        // bInterfaceNumber
        0,                                      // bAlternateSetting
        1,                                      // bNumEndpoints
        0x03,                                   // bInterfaceClass (0x03 = HID)
        0x00,                                   // bInterfaceSubClass (0x01 = Boot)
        0x00,                                   // bInterfaceProtocol (0x02 = Mouse)
        0,                                      // iInterface
        // HID interface descriptor, HID 1.11 spec, section 6.2.1
        9,                                      // bLength
        0x21,                                   // bDescriptorType
        0x11, 0x01,                             // bcdHID
        0,                                      // bCountryCode
        1,                                      // bNumDescriptors
        0x22,                                   // bDescriptorType
        LSB(sizeof(mouse_report_desc)),         // wDescriptorLength
        MSB(sizeof(mouse_report_desc)),
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        MOUSE_ENDPOINT | 0x80,                  // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        MOUSE_SIZE, 0,                          // wMaxPacketSize
        MOUSE_INTERVAL,                         // bInterval
#endif // MOUSE_INTERFACE

#ifdef RAWHID_INTERFACE
    // configuration for 480 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        RAWHID_INTERFACE,                       // bInterfaceNumber
        0,                                      // bAlternateSetting
        2,                                      // bNumEndpoints
        0x03,                                   // bInterfaceClass (0x03 = HID)
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // HID interface descriptor, HID 1.11 spec, section 6.2.1
        9,                                      // bLength
        0x21,                                   // bDescriptorType
        0x11, 0x01,                             // bcdHID
        0,                                      // bCountryCode
        1,                                      // bNumDescriptors
        0x22,                                   // bDescriptorType
        LSB(sizeof(rawhid_report_desc)),        // wDescriptorLength
        MSB(sizeof(rawhid_report_desc)),
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        RAWHID_TX_ENDPOINT | 0x80,              // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        RAWHID_TX_SIZE, 0,                      // wMaxPacketSize
        RAWHID_TX_INTERVAL,                     // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        RAWHID_RX_ENDPOINT,                     // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        RAWHID_RX_SIZE, 0,                      // wMaxPacketSize
        RAWHID_RX_INTERVAL,            // bInterval
#endif // RAWHID_INTERFACE

#ifdef FLIGHTSIM_INTERFACE
    // configuration for 480 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        FLIGHTSIM_INTERFACE,                    // bInterfaceNumber
        0,                                      // bAlternateSetting
        2,                                      // bNumEndpoints
        0x03,                                   // bInterfaceClass (0x03 = HID)
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // HID interface descriptor, HID 1.11 spec, section 6.2.1
        9,                                      // bLength
        0x21,                                   // bDescriptorType
        0x11, 0x01,                             // bcdHID
        0,                                      // bCountryCode
        1,                                      // bNumDescriptors
        0x22,                                   // bDescriptorType
        LSB(sizeof(flightsim_report_desc)),     // wDescriptorLength
        MSB(sizeof(flightsim_report_desc)),
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        FLIGHTSIM_TX_ENDPOINT | 0x80,           // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        FLIGHTSIM_TX_SIZE, 0,                   // wMaxPacketSize
        FLIGHTSIM_TX_INTERVAL,                  // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        FLIGHTSIM_RX_ENDPOINT,                  // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        FLIGHTSIM_RX_SIZE, 0,                   // wMaxPacketSize
        FLIGHTSIM_RX_INTERVAL,            // bInterval
#endif // FLIGHTSIM_INTERFACE

#ifdef SEREMU_INTERFACE
    // configuration for 480 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        SEREMU_INTERFACE,                       // bInterfaceNumber
        0,                                      // bAlternateSetting
        2,                                      // bNumEndpoints
        0x03,                                   // bInterfaceClass (0x03 = HID)
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // HID interface descriptor, HID 1.11 spec, section 6.2.1
        9,                                      // bLength
        0x21,                                   // bDescriptorType
        0x11, 0x01,                             // bcdHID
        0,                                      // bCountryCode
        1,                                      // bNumDescriptors
        0x22,                                   // bDescriptorType
        LSB(sizeof(seremu_report_desc)),        // wDescriptorLength
        MSB(sizeof(seremu_report_desc)),
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        SEREMU_TX_ENDPOINT | 0x80,              // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        SEREMU_TX_SIZE, 0,                      // wMaxPacketSize
        SEREMU_TX_INTERVAL,                     // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        SEREMU_RX_ENDPOINT,                     // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        SEREMU_RX_SIZE, 0,                      // wMaxPacketSize
        SEREMU_RX_INTERVAL,            // bInterval
#endif // SEREMU_INTERFACE

#ifdef JOYSTICK_INTERFACE
    // configuration for 480 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        JOYSTICK_INTERFACE,                     // bInterfaceNumber
        0,                                      // bAlternateSetting
        1,                                      // bNumEndpoints
        0x03,                                   // bInterfaceClass (0x03 = HID)
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // HID interface descriptor, HID 1.11 spec, section 6.2.1
        9,                                      // bLength
        0x21,                                   // bDescriptorType
        0x11, 0x01,                             // bcdHID
        0,                                      // bCountryCode
        1,                                      // bNumDescriptors
        0x22,                                   // bDescriptorType
        LSB(sizeof(joystick_report_desc)),      // wDescriptorLength
        MSB(sizeof(joystick_report_desc)),
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        JOYSTICK_ENDPOINT | 0x80,               // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        JOYSTICK_SIZE, 0,                       // wMaxPacketSize
        JOYSTICK_INTERVAL,                      // bInterval
#endif // JOYSTICK_INTERFACE

#ifdef MTP_INTERFACE
    // configuration for 480 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        MTP_INTERFACE,                          // bInterfaceNumber
        0,                                      // bAlternateSetting
        3,                                      // bNumEndpoints
        0x06,                                   // bInterfaceClass (0x06 = still image)
        0x01,                                   // bInterfaceSubClass
        0x01,                                   // bInterfaceProtocol
        4,                                      // iInterface
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        MTP_TX_ENDPOINT | 0x80,                 // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(MTP_TX_SIZE_480),MSB(MTP_TX_SIZE_480), // wMaxPacketSize
        0,                                      // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        MTP_RX_ENDPOINT,                        // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(MTP_RX_SIZE_480),MSB(MTP_RX_SIZE_480), // wMaxPacketSize
        0,                                      // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        MTP_EVENT_ENDPOINT | 0x80,              // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        MTP_EVENT_SIZE, 0,                      // wMaxPacketSize
        MTP_EVENT_INTERVAL_480,                 // bInterval
#endif // MTP_INTERFACE

#ifdef KEYMEDIA_INTERFACE
    // configuration for 480 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        KEYMEDIA_INTERFACE,                     // bInterfaceNumber
        0,                                      // bAlternateSetting
        1,                                      // bNumEndpoints
        0x03,                                   // bInterfaceClass (0x03 = HID)
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // HID interface descriptor, HID 1.11 spec, section 6.2.1
        9,                                      // bLength
        0x21,                                   // bDescriptorType
        0x11, 0x01,                             // bcdHID
        0,                                      // bCountryCode
        1,                                      // bNumDescriptors
        0x22,                                   // bDescriptorType
        LSB(sizeof(keymedia_report_desc)),      // wDescriptorLength
        MSB(sizeof(keymedia_report_desc)),
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        KEYMEDIA_ENDPOINT | 0x80,               // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        KEYMEDIA_SIZE, 0,                       // wMaxPacketSize
        KEYMEDIA_INTERVAL,                      // bInterval
#endif // KEYMEDIA_INTERFACE

#ifdef AUDIO_INTERFACE
    // configuration for 480 Mbit/sec speed
        // interface association descriptor, USB ECN, Table 9-Z
        8,                                      // bLength
        11,                                     // bDescriptorType
        AUDIO_INTERFACE,                        // bFirstInterface
        3,                                      // bInterfaceCount
        0x01,                                   // bFunctionClass
        0x01,                                   // bFunctionSubClass
        0x00,                                   // bFunctionProtocol
        0,                                      // iFunction
    // Standard AudioControl (AC) Interface Descriptor
    // USB DCD for Audio Devices 1.0, Table 4-1, page 36
    9,                    // bLength
    4,                    // bDescriptorType, 4 = INTERFACE
    AUDIO_INTERFACE,            // bInterfaceNumber
    0,                    // bAlternateSetting
    0,                    // bNumEndpoints
    1,                    // bInterfaceClass, 1 = AUDIO
    1,                    // bInterfaceSubclass, 1 = AUDIO_CONTROL
    0,                    // bInterfaceProtocol
    0,                    // iInterface
    // Class-specific AC Interface Header Descriptor
    // USB DCD for Audio Devices 1.0, Table 4-2, page 37-38
    10,                    // bLength
    0x24,                    // bDescriptorType, 0x24 = CS_INTERFACE
    0x01,                    // bDescriptorSubtype, 1 = HEADER
    0x00, 0x01,                // bcdADC (version 1.0)
    LSB(62), MSB(62),            // wTotalLength
    2,                    // bInCollection
    AUDIO_INTERFACE+1,            // baInterfaceNr(1) - Transmit to PC
    AUDIO_INTERFACE+2,            // baInterfaceNr(2) - Receive from PC
    // Input Terminal Descriptor
    // USB DCD for Audio Devices 1.0, Table 4-3, page 39
    12,                    // bLength
    0x24,                    // bDescriptorType, 0x24 = CS_INTERFACE
    0x02,                    // bDescriptorSubType, 2 = INPUT_TERMINAL
    1,                    // bTerminalID
    //0x01, 0x02,                // wTerminalType, 0x0201 = MICROPHONE
    //0x03, 0x06,                // wTerminalType, 0x0603 = Line Connector
    0x02, 0x06,                // wTerminalType, 0x0602 = Digital Audio
    0,                    // bAssocTerminal, 0 = unidirectional
    2,                    // bNrChannels
    0x03, 0x00,                // wChannelConfig, 0x0003 = Left & Right Front
    0,                    // iChannelNames
    0,                     // iTerminal
    // Output Terminal Descriptor
    // USB DCD for Audio Devices 1.0, Table 4-4, page 40
    9,                    // bLength
    0x24,                    // bDescriptorType, 0x24 = CS_INTERFACE
    3,                    // bDescriptorSubtype, 3 = OUTPUT_TERMINAL
    2,                    // bTerminalID
    0x01, 0x01,                // wTerminalType, 0x0101 = USB_STREAMING
    0,                    // bAssocTerminal, 0 = unidirectional
    1,                    // bCSourceID, connected to input terminal, ID=1
    0,                    // iTerminal
    // Input Terminal Descriptor
    // USB DCD for Audio Devices 1.0, Table 4-3, page 39
    12,                    // bLength
    0x24,                    // bDescriptorType, 0x24 = CS_INTERFACE
    2,                    // bDescriptorSubType, 2 = INPUT_TERMINAL
    3,                    // bTerminalID
    0x01, 0x01,                // wTerminalType, 0x0101 = USB_STREAMING
    0,                    // bAssocTerminal, 0 = unidirectional
    2,                    // bNrChannels
    0x03, 0x00,                // wChannelConfig, 0x0003 = Left & Right Front
    0,                    // iChannelNames
    0,                     // iTerminal
    // Volume feature descriptor
    10,                    // bLength
    0x24,                 // bDescriptorType = CS_INTERFACE
    0x06,                 // bDescriptorSubType = FEATURE_UNIT
    0x31,                 // bUnitID
    0x03,                 // bSourceID (Input Terminal)
    0x01,                 // bControlSize (each channel is 1 byte, 3 channels)
    0x01,                 // bmaControls(0) Master: Mute
    0x02,                 // bmaControls(1) Left: Volume
    0x02,                 // bmaControls(2) Right: Volume
    0x00,                // iFeature
    // Output Terminal Descriptor
    // USB DCD for Audio Devices 1.0, Table 4-4, page 40
    9,                    // bLength
    0x24,                    // bDescriptorType, 0x24 = CS_INTERFACE
    3,                    // bDescriptorSubtype, 3 = OUTPUT_TERMINAL
    4,                    // bTerminalID
    //0x02, 0x03,                // wTerminalType, 0x0302 = Headphones
    0x02, 0x06,                // wTerminalType, 0x0602 = Digital Audio
    0,                    // bAssocTerminal, 0 = unidirectional
    0x31,                // bCSourceID, connected to feature, ID=31
    0,                    // iTerminal
    // Standard AS Interface Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.5.1, Table 4-18, page 59
    // Alternate 0: default setting, disabled zero bandwidth
    9,                    // bLenght
    4,                    // bDescriptorType = INTERFACE
    AUDIO_INTERFACE+1,            // bInterfaceNumber
    0,                    // bAlternateSetting
    0,                    // bNumEndpoints
    1,                    // bInterfaceClass, 1 = AUDIO
    2,                    // bInterfaceSubclass, 2 = AUDIO_STREAMING
    0,                    // bInterfaceProtocol
    0,                    // iInterface
    // Alternate 1: streaming data
    9,                    // bLenght
    4,                    // bDescriptorType = INTERFACE
    AUDIO_INTERFACE+1,            // bInterfaceNumber
    1,                    // bAlternateSetting
    1,                    // bNumEndpoints
    1,                    // bInterfaceClass, 1 = AUDIO
    2,                    // bInterfaceSubclass, 2 = AUDIO_STREAMING
    0,                    // bInterfaceProtocol
    0,                    // iInterface
    // Class-Specific AS Interface Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.5.2, Table 4-19, page 60
    7,                     // bLength
    0x24,                    // bDescriptorType = CS_INTERFACE
    1,                    // bDescriptorSubtype, 1 = AS_GENERAL
    2,                    // bTerminalLink: Terminal ID = 2
    3,                    // bDelay (approx 3ms delay, audio lib updates)
    0x01, 0x00,                // wFormatTag, 0x0001 = PCM
    // Type I Format Descriptor
    // USB DCD for Audio Data Formats 1.0, Section 2.2.5, Table 2-1, page 10
    11,                    // bLength
    0x24,                    // bDescriptorType = CS_INTERFACE
    2,                    // bDescriptorSubtype = FORMAT_TYPE
    1,                    // bFormatType = FORMAT_TYPE_I
    2,                    // bNrChannels = 2
    2,                    // bSubFrameSize = 2 byte
    16,                    // bBitResolution = 16 bits
    1,                    // bSamFreqType = 1 frequency
    LSB(44100), MSB(44100), 0,        // tSamFreq
    // Standard AS Isochronous Audio Data Endpoint Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.6.1.1, Table 4-20, page 61-62
    9,                     // bLength
    5,                     // bDescriptorType, 5 = ENDPOINT_DESCRIPTOR
    AUDIO_TX_ENDPOINT | 0x80,        // bEndpointAddress
    0x09,                     // bmAttributes = isochronous, adaptive
    LSB(AUDIO_TX_SIZE), MSB(AUDIO_TX_SIZE),    // wMaxPacketSize
    4,                     // bInterval, 4 = every 8 micro-frames
    0,                    // bRefresh
    0,                    // bSynchAddress
    // Class-Specific AS Isochronous Audio Data Endpoint Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.6.1.2, Table 4-21, page 62-63
    7,                      // bLength
    0x25,                      // bDescriptorType, 0x25 = CS_ENDPOINT
    1,                      // bDescriptorSubtype, 1 = EP_GENERAL
    0x00,                      // bmAttributes
    0,                      // bLockDelayUnits, 1 = ms
    0x00, 0x00,                  // wLockDelay
    // Standard AS Interface Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.5.1, Table 4-18, page 59
    // Alternate 0: default setting, disabled zero bandwidth
    9,                    // bLenght
    4,                    // bDescriptorType = INTERFACE
    AUDIO_INTERFACE+2,            // bInterfaceNumber
    0,                    // bAlternateSetting
    0,                    // bNumEndpoints
    1,                    // bInterfaceClass, 1 = AUDIO
    2,                    // bInterfaceSubclass, 2 = AUDIO_STREAMING
    0,                    // bInterfaceProtocol
    0,                    // iInterface
    // Alternate 1: streaming data
    9,                    // bLenght
    4,                    // bDescriptorType = INTERFACE
    AUDIO_INTERFACE+2,            // bInterfaceNumber
    1,                    // bAlternateSetting
    2,                    // bNumEndpoints
    1,                    // bInterfaceClass, 1 = AUDIO
    2,                    // bInterfaceSubclass, 2 = AUDIO_STREAMING
    0,                    // bInterfaceProtocol
    0,                    // iInterface
    // Class-Specific AS Interface Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.5.2, Table 4-19, page 60
    7,                     // bLength
    0x24,                    // bDescriptorType = CS_INTERFACE
    1,                    // bDescriptorSubtype, 1 = AS_GENERAL
    3,                    // bTerminalLink: Terminal ID = 3
    3,                    // bDelay (approx 3ms delay, audio lib updates)
    0x01, 0x00,                // wFormatTag, 0x0001 = PCM
    // Type I Format Descriptor
    // USB DCD for Audio Data Formats 1.0, Section 2.2.5, Table 2-1, page 10
    11,                    // bLength
    0x24,                    // bDescriptorType = CS_INTERFACE
    2,                    // bDescriptorSubtype = FORMAT_TYPE
    1,                    // bFormatType = FORMAT_TYPE_I
    2,                    // bNrChannels = 2
    2,                    // bSubFrameSize = 2 byte
    16,                    // bBitResolution = 16 bits
    1,                    // bSamFreqType = 1 frequency
    LSB(44100), MSB(44100), 0,        // tSamFreq
    // Standard AS Isochronous Audio Data Endpoint Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.6.1.1, Table 4-20, page 61-62
    9,                     // bLength
    5,                     // bDescriptorType, 5 = ENDPOINT_DESCRIPTOR
    AUDIO_RX_ENDPOINT,            // bEndpointAddress
    0x05,                     // bmAttributes = isochronous, asynchronous
    LSB(AUDIO_RX_SIZE), MSB(AUDIO_RX_SIZE),    // wMaxPacketSize
    4,                     // bInterval, 4 = every 8 micro-frames
    0,                    // bRefresh
    AUDIO_SYNC_ENDPOINT | 0x80,        // bSynchAddress
    // Class-Specific AS Isochronous Audio Data Endpoint Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.6.1.2, Table 4-21, page 62-63
    7,                      // bLength
    0x25,                      // bDescriptorType, 0x25 = CS_ENDPOINT
    1,                      // bDescriptorSubtype, 1 = EP_GENERAL
    0x00,                      // bmAttributes
    0,                      // bLockDelayUnits, 1 = ms
    0x00, 0x00,                  // wLockDelay
    // Standard AS Isochronous Audio Synch Endpoint Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.6.2.1, Table 4-22, page 63-64
    9,                     // bLength
    5,                     // bDescriptorType, 5 = ENDPOINT_DESCRIPTOR
    AUDIO_SYNC_ENDPOINT | 0x80,        // bEndpointAddress
    0x11,                     // bmAttributes = isochronous, feedback
    4, 0,                    // wMaxPacketSize, 4 bytes
    4,                     // bInterval, 4 = 4 = every 8 micro-frames
    7,                    // bRefresh,
    0,                    // bSynchAddress
#endif

#ifdef MULTITOUCH_INTERFACE
    // configuration for 480 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        MULTITOUCH_INTERFACE,                   // bInterfaceNumber
        0,                                      // bAlternateSetting
        1,                                      // bNumEndpoints
        0x03,                                   // bInterfaceClass (0x03 = HID)
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // HID interface descriptor, HID 1.11 spec, section 6.2.1
        9,                                      // bLength
        0x21,                                   // bDescriptorType
        0x11, 0x01,                             // bcdHID
        0,                                      // bCountryCode
        1,                                      // bNumDescriptors
        0x22,                                   // bDescriptorType
        LSB(sizeof(multitouch_report_desc)),    // wDescriptorLength
        MSB(sizeof(multitouch_report_desc)),
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        MULTITOUCH_ENDPOINT | 0x80,             // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        MULTITOUCH_SIZE, 0,                     // wMaxPacketSize
        4,                                      // bInterval, 4 = 1ms
#endif // MULTITOUCH_INTERFACE

#ifdef EXPERIMENTAL_INTERFACE
    // configuration for 480 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        EXPERIMENTAL_INTERFACE,                 // bInterfaceNumber
        0,                                      // bAlternateSetting
        2,                                      // bNumEndpoints
        0xFF,                                   // bInterfaceClass (0xFF = Vendor)
        0x6A,                                   // bInterfaceSubClass
        0xFF,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        1 | 0x80,                               // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(512), MSB(512),                     // wMaxPacketSize
        1,                                      // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        1,                                      // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(512), MSB(512),                     // wMaxPacketSize
        1,                                      // bInterval
#endif // EXPERIMENTAL_INTERFACE
};


PROGMEM const uint8_t usb_config_descriptor_12[CONFIG_DESC_SIZE] = {
        // configuration descriptor, USB spec 9.6.3, page 264-266, Table 9-10
        9,                                      // bLength;
        2,                                      // bDescriptorType;
        LSB(CONFIG_DESC_SIZE),                 // wTotalLength
        MSB(CONFIG_DESC_SIZE),
        NUM_INTERFACE,                          // bNumInterfaces
        1,                                      // bConfigurationValue
        0,                                      // iConfiguration
        0xC0,                                   // bmAttributes
        50,                                     // bMaxPower

#ifdef CDC_IAD_DESCRIPTOR
        // interface association descriptor, USB ECN, Table 9-Z
        8,                                      // bLength
        11,                                     // bDescriptorType
        CDC_STATUS_INTERFACE,                   // bFirstInterface
        2,                                      // bInterfaceCount
        0x02,                                   // bFunctionClass
        0x02,                                   // bFunctionSubClass
        0x01,                                   // bFunctionProtocol
        0,                                      // iFunction
#endif

#ifdef CDC_DATA_INTERFACE
    // configuration for 12 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        CDC_STATUS_INTERFACE,            // bInterfaceNumber
        0,                                      // bAlternateSetting
        1,                                      // bNumEndpoints
        0x02,                                   // bInterfaceClass
        0x02,                                   // bInterfaceSubClass
        0x01,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // CDC Header Functional Descriptor, CDC Spec 5.2.3.1, Table 26
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x00,                                   // bDescriptorSubtype
        0x10, 0x01,                             // bcdCDC
        // Call Management Functional Descriptor, CDC Spec 5.2.3.2, Table 27
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x01,                                   // bDescriptorSubtype
        0x01,                                   // bmCapabilities
        1,                                      // bDataInterface
        // Abstract Control Management Functional Descriptor, CDC Spec 5.2.3.3, Table 28
        4,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x02,                                   // bDescriptorSubtype
        0x06,                                   // bmCapabilities
        // Union Functional Descriptor, CDC Spec 5.2.3.8, Table 33
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x06,                                   // bDescriptorSubtype
        CDC_STATUS_INTERFACE,                   // bMasterInterface
        CDC_DATA_INTERFACE,                     // bSlaveInterface0
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC_ACM_ENDPOINT | 0x80,                // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        CDC_ACM_SIZE, 0,                        // wMaxPacketSize
        16,                                     // bInterval
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        CDC_DATA_INTERFACE,                     // bInterfaceNumber
        0,                                      // bAlternateSetting
        2,                                      // bNumEndpoints
        0x0A,                                   // bInterfaceClass
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC_RX_ENDPOINT,                        // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(CDC_RX_SIZE_12),MSB(CDC_RX_SIZE_12),// wMaxPacketSize
        0,                                      // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC_TX_ENDPOINT | 0x80,                 // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(CDC_TX_SIZE_12),MSB(CDC_TX_SIZE_12),// wMaxPacketSize
        0,                                      // bInterval
#endif // CDC_DATA_INTERFACE

#ifdef CDC2_DATA_INTERFACE
    // configuration for 12 Mbit/sec speed
        // interface association descriptor, USB ECN, Table 9-Z
        8,                                      // bLength
        11,                                     // bDescriptorType
        CDC2_STATUS_INTERFACE,                  // bFirstInterface
        2,                                      // bInterfaceCount
        0x02,                                   // bFunctionClass
        0x02,                                   // bFunctionSubClass
        0x01,                                   // bFunctionProtocol
        0,                                      // iFunction
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        CDC2_STATUS_INTERFACE,                  // bInterfaceNumber
        0,                                      // bAlternateSetting
        1,                                      // bNumEndpoints
        0x02,                                   // bInterfaceClass
        0x02,                                   // bInterfaceSubClass
        0x01,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // CDC Header Functional Descriptor, CDC Spec 5.2.3.1, Table 26
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x00,                                   // bDescriptorSubtype
        0x10, 0x01,                             // bcdCDC
        // Call Management Functional Descriptor, CDC Spec 5.2.3.2, Table 27
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x01,                                   // bDescriptorSubtype
        0x01,                                   // bmCapabilities
        1,                                      // bDataInterface
        // Abstract Control Management Functional Descriptor, CDC Spec 5.2.3.3, Table 28
        4,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x02,                                   // bDescriptorSubtype
        0x06,                                   // bmCapabilities
        // Union Functional Descriptor, CDC Spec 5.2.3.8, Table 33
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x06,                                   // bDescriptorSubtype
        CDC2_STATUS_INTERFACE,                  // bMasterInterface
        CDC2_DATA_INTERFACE,                    // bSlaveInterface0
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC2_ACM_ENDPOINT | 0x80,               // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        CDC_ACM_SIZE, 0,                        // wMaxPacketSize
        64,                                     // bInterval
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        CDC2_DATA_INTERFACE,                    // bInterfaceNumber
        0,                                      // bAlternateSetting
        2,                                      // bNumEndpoints
        0x0A,                                   // bInterfaceClass
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC2_RX_ENDPOINT,                       // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        CDC_RX_SIZE_12, 0,                      // wMaxPacketSize
        0,                                      // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC2_TX_ENDPOINT | 0x80,                // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        CDC_TX_SIZE_12, 0,                      // wMaxPacketSize
        0,                                      // bInterval
#endif // CDC2_DATA_INTERFACE

#ifdef CDC3_DATA_INTERFACE
    // configuration for 12 Mbit/sec speed
        // interface association descriptor, USB ECN, Table 9-Z
        8,                                      // bLength
        11,                                     // bDescriptorType
        CDC3_STATUS_INTERFACE,                  // bFirstInterface
        2,                                      // bInterfaceCount
        0x02,                                   // bFunctionClass
        0x02,                                   // bFunctionSubClass
        0x01,                                   // bFunctionProtocol
        0,                                      // iFunction
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        CDC3_STATUS_INTERFACE,                  // bInterfaceNumber
        0,                                      // bAlternateSetting
        1,                                      // bNumEndpoints
        0x02,                                   // bInterfaceClass
        0x02,                                   // bInterfaceSubClass
        0x01,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // CDC Header Functional Descriptor, CDC Spec 5.2.3.1, Table 26
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x00,                                   // bDescriptorSubtype
        0x10, 0x01,                             // bcdCDC
        // Call Management Functional Descriptor, CDC Spec 5.2.3.2, Table 27
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x01,                                   // bDescriptorSubtype
        0x01,                                   // bmCapabilities
        1,                                      // bDataInterface
        // Abstract Control Management Functional Descriptor, CDC Spec 5.2.3.3, Table 28
        4,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x02,                                   // bDescriptorSubtype
        0x06,                                   // bmCapabilities
        // Union Functional Descriptor, CDC Spec 5.2.3.8, Table 33
        5,                                      // bFunctionLength
        0x24,                                   // bDescriptorType
        0x06,                                   // bDescriptorSubtype
        CDC3_STATUS_INTERFACE,                  // bMasterInterface
        CDC3_DATA_INTERFACE,                    // bSlaveInterface0
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC3_ACM_ENDPOINT | 0x80,               // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        CDC_ACM_SIZE, 0,                        // wMaxPacketSize
        64,                                     // bInterval
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        CDC3_DATA_INTERFACE,                    // bInterfaceNumber
        0,                                      // bAlternateSetting
        2,                                      // bNumEndpoints
        0x0A,                                   // bInterfaceClass
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC3_RX_ENDPOINT,                       // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        CDC_RX_SIZE_12, 0,                      // wMaxPacketSize
        0,                                      // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        CDC3_TX_ENDPOINT | 0x80,                // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        CDC_TX_SIZE_12, 0,                      // wMaxPacketSize
        0,                                      // bInterval
#endif // CDC3_DATA_INTERFACE

#ifdef MIDI_INTERFACE
    // configuration for 12 Mbit/sec speed
        // Standard MS Interface Descriptor,
        9,                                      // bLength
        4,                                      // bDescriptorType
        MIDI_INTERFACE,                         // bInterfaceNumber
        0,                                      // bAlternateSetting
        2,                                      // bNumEndpoints
        0x01,                                   // bInterfaceClass (0x01 = Audio)
        0x03,                                   // bInterfaceSubClass (0x03 = MIDI)
        0x00,                                   // bInterfaceProtocol (unused for MIDI)
        0,                                      // iInterface
        // MIDI MS Interface Header, USB MIDI 6.1.2.1, page 21, Table 6-2
        7,                                      // bLength
        0x24,                                   // bDescriptorType = CS_INTERFACE
        0x01,                                   // bDescriptorSubtype = MS_HEADER
        0x00, 0x01,                             // bcdMSC = revision 01.00
    LSB(7+(6+6+9+9)*MIDI_NUM_CABLES),       // wTotalLength
    MSB(7+(6+6+9+9)*MIDI_NUM_CABLES),
        // MIDI IN Jack Descriptor, B.4.3, Table B-7 (embedded), page 40
        6,                                      // bLength
        0x24,                                   // bDescriptorType = CS_INTERFACE
        0x02,                                   // bDescriptorSubtype = MIDI_IN_JACK
        0x01,                                   // bJackType = EMBEDDED
        1,                                      // bJackID, ID = 1
        0,                                      // iJack
        // MIDI IN Jack Descriptor, B.4.3, Table B-8 (external), page 40
        6,                                      // bLength
        0x24,                                   // bDescriptorType = CS_INTERFACE
        0x02,                                   // bDescriptorSubtype = MIDI_IN_JACK
        0x02,                                   // bJackType = EXTERNAL
        2,                                      // bJackID, ID = 2
        0,                                      // iJack
        // MIDI OUT Jack Descriptor, B.4.4, Table B-9, page 41
        9,
        0x24,                                   // bDescriptorType = CS_INTERFACE
        0x03,                                   // bDescriptorSubtype = MIDI_OUT_JACK
        0x01,                                   // bJackType = EMBEDDED
        3,                                      // bJackID, ID = 3
        1,                                      // bNrInputPins = 1 pin
        2,                                      // BaSourceID(1) = 2
        1,                                      // BaSourcePin(1) = first pin
        0,                                      // iJack
        // MIDI OUT Jack Descriptor, B.4.4, Table B-10, page 41
        9,
        0x24,                                   // bDescriptorType = CS_INTERFACE
        0x03,                                   // bDescriptorSubtype = MIDI_OUT_JACK
        0x02,                                   // bJackType = EXTERNAL
        4,                                      // bJackID, ID = 4
        1,                                      // bNrInputPins = 1 pin
        1,                                      // BaSourceID(1) = 1
        1,                                      // BaSourcePin(1) = first pin
        0,                                      // iJack
  #if MIDI_NUM_CABLES >= 2
    #define MIDI_INTERFACE_JACK_PAIR(a, b, c, d) \
        6, 0x24, 0x02, 0x01, (a), 0, \
        6, 0x24, 0x02, 0x02, (b), 0, \
        9, 0x24, 0x03, 0x01, (c), 1, (b), 1, 0, \
        9, 0x24, 0x03, 0x02, (d), 1, (a), 1, 0,
    MIDI_INTERFACE_JACK_PAIR(5, 6, 7, 8)
  #endif
  #if MIDI_NUM_CABLES >= 3
    MIDI_INTERFACE_JACK_PAIR(9, 10, 11, 12)
  #endif
  #if MIDI_NUM_CABLES >= 4
    MIDI_INTERFACE_JACK_PAIR(13, 14, 15, 16)
  #endif
  #if MIDI_NUM_CABLES >= 5
    MIDI_INTERFACE_JACK_PAIR(17, 18, 19, 20)
  #endif
  #if MIDI_NUM_CABLES >= 6
    MIDI_INTERFACE_JACK_PAIR(21, 22, 23, 24)
  #endif
  #if MIDI_NUM_CABLES >= 7
    MIDI_INTERFACE_JACK_PAIR(25, 26, 27, 28)
  #endif
  #if MIDI_NUM_CABLES >= 8
    MIDI_INTERFACE_JACK_PAIR(29, 30, 31, 32)
  #endif
  #if MIDI_NUM_CABLES >= 9
    MIDI_INTERFACE_JACK_PAIR(33, 34, 35, 36)
  #endif
  #if MIDI_NUM_CABLES >= 10
    MIDI_INTERFACE_JACK_PAIR(37, 38, 39, 40)
  #endif
  #if MIDI_NUM_CABLES >= 11
    MIDI_INTERFACE_JACK_PAIR(41, 42, 43, 44)
  #endif
  #if MIDI_NUM_CABLES >= 12
    MIDI_INTERFACE_JACK_PAIR(45, 46, 47, 48)
  #endif
  #if MIDI_NUM_CABLES >= 13
    MIDI_INTERFACE_JACK_PAIR(49, 50, 51, 52)
  #endif
  #if MIDI_NUM_CABLES >= 14
    MIDI_INTERFACE_JACK_PAIR(53, 54, 55, 56)
  #endif
  #if MIDI_NUM_CABLES >= 15
    MIDI_INTERFACE_JACK_PAIR(57, 58, 59, 60)
  #endif
  #if MIDI_NUM_CABLES >= 16
    MIDI_INTERFACE_JACK_PAIR(61, 62, 63, 64)
  #endif
        // Standard Bulk OUT Endpoint Descriptor, B.5.1, Table B-11, pae 42
        9,                                      // bLength
        5,                                      // bDescriptorType = ENDPOINT
        MIDI_RX_ENDPOINT,                       // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(MIDI_RX_SIZE_12),MSB(MIDI_RX_SIZE_12),// wMaxPacketSize
        0,                                      // bInterval
        0,                                      // bRefresh
        0,                                      // bSynchAddress
        // Class-specific MS Bulk OUT Endpoint Descriptor, B.5.2, Table B-12, page 42
        4+MIDI_NUM_CABLES,                      // bLength
        0x25,                                   // bDescriptorSubtype = CS_ENDPOINT
        0x01,                                   // bJackType = MS_GENERAL
        MIDI_NUM_CABLES,                        // bNumEmbMIDIJack = number of jacks
        1,                                      // BaAssocJackID(1) = jack ID #1
  #if MIDI_NUM_CABLES >= 2
        5,
  #endif
  #if MIDI_NUM_CABLES >= 3
        9,
  #endif
  #if MIDI_NUM_CABLES >= 4
        13,
  #endif
  #if MIDI_NUM_CABLES >= 5
        17,
  #endif
  #if MIDI_NUM_CABLES >= 6
        21,
  #endif
  #if MIDI_NUM_CABLES >= 7
        25,
  #endif
  #if MIDI_NUM_CABLES >= 8
        29,
  #endif
  #if MIDI_NUM_CABLES >= 9
        33,
  #endif
  #if MIDI_NUM_CABLES >= 10
        37,
  #endif
  #if MIDI_NUM_CABLES >= 11
        41,
  #endif
  #if MIDI_NUM_CABLES >= 12
        45,
  #endif
  #if MIDI_NUM_CABLES >= 13
        49,
  #endif
  #if MIDI_NUM_CABLES >= 14
        53,
  #endif
  #if MIDI_NUM_CABLES >= 15
        57,
  #endif
  #if MIDI_NUM_CABLES >= 16
        61,
  #endif
        // Standard Bulk IN Endpoint Descriptor, B.5.1, Table B-11, pae 42
        9,                                      // bLength
        5,                                      // bDescriptorType = ENDPOINT
        MIDI_TX_ENDPOINT | 0x80,                // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(MIDI_TX_SIZE_12),MSB(MIDI_TX_SIZE_12),// wMaxPacketSize
        0,                                      // bInterval
        0,                                      // bRefresh
        0,                                      // bSynchAddress
        // Class-specific MS Bulk IN Endpoint Descriptor, B.5.2, Table B-12, page 42
        4+MIDI_NUM_CABLES,                      // bLength
        0x25,                                   // bDescriptorSubtype = CS_ENDPOINT
        0x01,                                   // bJackType = MS_GENERAL
        MIDI_NUM_CABLES,                        // bNumEmbMIDIJack = number of jacks
        3,                                      // BaAssocJackID(1) = jack ID #3
  #if MIDI_NUM_CABLES >= 2
        7,
  #endif
  #if MIDI_NUM_CABLES >= 3
        11,
  #endif
  #if MIDI_NUM_CABLES >= 4
        15,
  #endif
  #if MIDI_NUM_CABLES >= 5
        19,
  #endif
  #if MIDI_NUM_CABLES >= 6
        23,
  #endif
  #if MIDI_NUM_CABLES >= 7
        27,
  #endif
  #if MIDI_NUM_CABLES >= 8
        31,
  #endif
  #if MIDI_NUM_CABLES >= 9
        35,
  #endif
  #if MIDI_NUM_CABLES >= 10
        39,
  #endif
  #if MIDI_NUM_CABLES >= 11
        43,
  #endif
  #if MIDI_NUM_CABLES >= 12
        47,
  #endif
  #if MIDI_NUM_CABLES >= 13
        51,
  #endif
  #if MIDI_NUM_CABLES >= 14
        55,
  #endif
  #if MIDI_NUM_CABLES >= 15
        59,
  #endif
  #if MIDI_NUM_CABLES >= 16
        63,
  #endif
#endif // MIDI_INTERFACE

#ifdef KEYBOARD_INTERFACE
    // configuration for 12 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        KEYBOARD_INTERFACE,                     // bInterfaceNumber
        0,                                      // bAlternateSetting
        1,                                      // bNumEndpoints
        0x03,                                   // bInterfaceClass (0x03 = HID)
        0x01,                                   // bInterfaceSubClass (0x01 = Boot)
        0x01,                                   // bInterfaceProtocol (0x01 = Keyboard)
        0,                                      // iInterface
        // HID interface descriptor, HID 1.11 spec, section 6.2.1
        9,                                      // bLength
        0x21,                                   // bDescriptorType
        0x11, 0x01,                             // bcdHID
        0,                                      // bCountryCode
        1,                                      // bNumDescriptors
        0x22,                                   // bDescriptorType
        LSB(sizeof(keyboard_report_desc)),      // wDescriptorLength
        MSB(sizeof(keyboard_report_desc)),
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        KEYBOARD_ENDPOINT | 0x80,               // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        KEYBOARD_SIZE, 0,                       // wMaxPacketSize
        KEYBOARD_INTERVAL,                      // bInterval
#endif // KEYBOARD_INTERFACE

#ifdef MOUSE_INTERFACE
    // configuration for 12 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        MOUSE_INTERFACE,                        // bInterfaceNumber
        0,                                      // bAlternateSetting
        1,                                      // bNumEndpoints
        0x03,                                   // bInterfaceClass (0x03 = HID)
        0x00,                                   // bInterfaceSubClass (0x01 = Boot)
        0x00,                                   // bInterfaceProtocol (0x02 = Mouse)
        0,                                      // iInterface
        // HID interface descriptor, HID 1.11 spec, section 6.2.1
        9,                                      // bLength
        0x21,                                   // bDescriptorType
        0x11, 0x01,                             // bcdHID
        0,                                      // bCountryCode
        1,                                      // bNumDescriptors
        0x22,                                   // bDescriptorType
        LSB(sizeof(mouse_report_desc)),         // wDescriptorLength
        MSB(sizeof(mouse_report_desc)),
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        MOUSE_ENDPOINT | 0x80,                  // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        MOUSE_SIZE, 0,                          // wMaxPacketSize
        MOUSE_INTERVAL,                         // bInterval
#endif // MOUSE_INTERFACE

#ifdef RAWHID_INTERFACE
    // configuration for 12 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        RAWHID_INTERFACE,                       // bInterfaceNumber
        0,                                      // bAlternateSetting
        2,                                      // bNumEndpoints
        0x03,                                   // bInterfaceClass (0x03 = HID)
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // HID interface descriptor, HID 1.11 spec, section 6.2.1
        9,                                      // bLength
        0x21,                                   // bDescriptorType
        0x11, 0x01,                             // bcdHID
        0,                                      // bCountryCode
        1,                                      // bNumDescriptors
        0x22,                                   // bDescriptorType
        LSB(sizeof(rawhid_report_desc)),        // wDescriptorLength
        MSB(sizeof(rawhid_report_desc)),
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        RAWHID_TX_ENDPOINT | 0x80,              // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        RAWHID_TX_SIZE, 0,                      // wMaxPacketSize
        RAWHID_TX_INTERVAL,                     // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        RAWHID_RX_ENDPOINT,                     // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        RAWHID_RX_SIZE, 0,                      // wMaxPacketSize
        RAWHID_RX_INTERVAL,            // bInterval
#endif // RAWHID_INTERFACE

#ifdef FLIGHTSIM_INTERFACE
    // configuration for 12 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        FLIGHTSIM_INTERFACE,                    // bInterfaceNumber
        0,                                      // bAlternateSetting
        2,                                      // bNumEndpoints
        0x03,                                   // bInterfaceClass (0x03 = HID)
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // HID interface descriptor, HID 1.11 spec, section 6.2.1
        9,                                      // bLength
        0x21,                                   // bDescriptorType
        0x11, 0x01,                             // bcdHID
        0,                                      // bCountryCode
        1,                                      // bNumDescriptors
        0x22,                                   // bDescriptorType
        LSB(sizeof(flightsim_report_desc)),     // wDescriptorLength
        MSB(sizeof(flightsim_report_desc)),
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        FLIGHTSIM_TX_ENDPOINT | 0x80,           // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        FLIGHTSIM_TX_SIZE, 0,                   // wMaxPacketSize
        FLIGHTSIM_TX_INTERVAL,                  // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        FLIGHTSIM_RX_ENDPOINT,                  // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        FLIGHTSIM_RX_SIZE, 0,                   // wMaxPacketSize
        FLIGHTSIM_RX_INTERVAL,            // bInterval
#endif // FLIGHTSIM_INTERFACE

#ifdef SEREMU_INTERFACE
    // configuration for 12 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        SEREMU_INTERFACE,                       // bInterfaceNumber
        0,                                      // bAlternateSetting
        2,                                      // bNumEndpoints
        0x03,                                   // bInterfaceClass (0x03 = HID)
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // HID interface descriptor, HID 1.11 spec, section 6.2.1
        9,                                      // bLength
        0x21,                                   // bDescriptorType
        0x11, 0x01,                             // bcdHID
        0,                                      // bCountryCode
        1,                                      // bNumDescriptors
        0x22,                                   // bDescriptorType
        LSB(sizeof(seremu_report_desc)),        // wDescriptorLength
        MSB(sizeof(seremu_report_desc)),
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        SEREMU_TX_ENDPOINT | 0x80,              // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        SEREMU_TX_SIZE, 0,                      // wMaxPacketSize
        SEREMU_TX_INTERVAL,                     // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        SEREMU_RX_ENDPOINT,                     // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        SEREMU_RX_SIZE, 0,                      // wMaxPacketSize
        SEREMU_RX_INTERVAL,            // bInterval
#endif // SEREMU_INTERFACE

#ifdef JOYSTICK_INTERFACE
    // configuration for 12 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        JOYSTICK_INTERFACE,                     // bInterfaceNumber
        0,                                      // bAlternateSetting
        1,                                      // bNumEndpoints
        0x03,                                   // bInterfaceClass (0x03 = HID)
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // HID interface descriptor, HID 1.11 spec, section 6.2.1
        9,                                      // bLength
        0x21,                                   // bDescriptorType
        0x11, 0x01,                             // bcdHID
        0,                                      // bCountryCode
        1,                                      // bNumDescriptors
        0x22,                                   // bDescriptorType
        LSB(sizeof(joystick_report_desc)),      // wDescriptorLength
        MSB(sizeof(joystick_report_desc)),
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        JOYSTICK_ENDPOINT | 0x80,               // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        JOYSTICK_SIZE, 0,                       // wMaxPacketSize
        JOYSTICK_INTERVAL,                      // bInterval
#endif // JOYSTICK_INTERFACE

#ifdef MTP_INTERFACE
    // configuration for 12 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        MTP_INTERFACE,                          // bInterfaceNumber
        0,                                      // bAlternateSetting
        3,                                      // bNumEndpoints
        0x06,                                   // bInterfaceClass (0x06 = still image)
        0x01,                                   // bInterfaceSubClass
        0x01,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        MTP_TX_ENDPOINT | 0x80,                 // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(MTP_TX_SIZE_12),MSB(MTP_TX_SIZE_12),// wMaxPacketSize
        0,                                      // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        MTP_RX_ENDPOINT,                        // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(MTP_RX_SIZE_12),MSB(MTP_RX_SIZE_12),// wMaxPacketSize
        0,                                      // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        MTP_EVENT_ENDPOINT | 0x80,              // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        MTP_EVENT_SIZE, 0,                      // wMaxPacketSize
        MTP_EVENT_INTERVAL_12,                  // bInterval
#endif // MTP_INTERFACE

#ifdef KEYMEDIA_INTERFACE
    // configuration for 12 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        KEYMEDIA_INTERFACE,                     // bInterfaceNumber
        0,                                      // bAlternateSetting
        1,                                      // bNumEndpoints
        0x03,                                   // bInterfaceClass (0x03 = HID)
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // HID interface descriptor, HID 1.11 spec, section 6.2.1
        9,                                      // bLength
        0x21,                                   // bDescriptorType
        0x11, 0x01,                             // bcdHID
        0,                                      // bCountryCode
        1,                                      // bNumDescriptors
        0x22,                                   // bDescriptorType
        LSB(sizeof(keymedia_report_desc)),      // wDescriptorLength
        MSB(sizeof(keymedia_report_desc)),
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        KEYMEDIA_ENDPOINT | 0x80,               // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        KEYMEDIA_SIZE, 0,                       // wMaxPacketSize
        KEYMEDIA_INTERVAL,                      // bInterval
#endif // KEYMEDIA_INTERFACE

#ifdef AUDIO_INTERFACE
    // configuration for 12 Mbit/sec speed
        // interface association descriptor, USB ECN, Table 9-Z
        8,                                      // bLength
        11,                                     // bDescriptorType
        AUDIO_INTERFACE,                        // bFirstInterface
        3,                                      // bInterfaceCount
        0x01,                                   // bFunctionClass
        0x01,                                   // bFunctionSubClass
        0x00,                                   // bFunctionProtocol
        0,                                      // iFunction
    // Standard AudioControl (AC) Interface Descriptor
    // USB DCD for Audio Devices 1.0, Table 4-1, page 36
    9,                    // bLength
    4,                    // bDescriptorType, 4 = INTERFACE
    AUDIO_INTERFACE,            // bInterfaceNumber
    0,                    // bAlternateSetting
    0,                    // bNumEndpoints
    1,                    // bInterfaceClass, 1 = AUDIO
    1,                    // bInterfaceSubclass, 1 = AUDIO_CONTROL
    0,                    // bInterfaceProtocol
    0,                    // iInterface
    // Class-specific AC Interface Header Descriptor
    // USB DCD for Audio Devices 1.0, Table 4-2, page 37-38
    10,                    // bLength
    0x24,                    // bDescriptorType, 0x24 = CS_INTERFACE
    0x01,                    // bDescriptorSubtype, 1 = HEADER
    0x00, 0x01,                // bcdADC (version 1.0)
    LSB(62), MSB(62),            // wTotalLength
    2,                    // bInCollection
    AUDIO_INTERFACE+1,            // baInterfaceNr(1) - Transmit to PC
    AUDIO_INTERFACE+2,            // baInterfaceNr(2) - Receive from PC
    // Input Terminal Descriptor
    // USB DCD for Audio Devices 1.0, Table 4-3, page 39
    12,                    // bLength
    0x24,                    // bDescriptorType, 0x24 = CS_INTERFACE
    0x02,                    // bDescriptorSubType, 2 = INPUT_TERMINAL
    1,                    // bTerminalID
    //0x01, 0x02,                // wTerminalType, 0x0201 = MICROPHONE
    //0x03, 0x06,                // wTerminalType, 0x0603 = Line Connector
    0x02, 0x06,                // wTerminalType, 0x0602 = Digital Audio
    0,                    // bAssocTerminal, 0 = unidirectional
    2,                    // bNrChannels
    0x03, 0x00,                // wChannelConfig, 0x0003 = Left & Right Front
    0,                    // iChannelNames
    0,                     // iTerminal
    // Output Terminal Descriptor
    // USB DCD for Audio Devices 1.0, Table 4-4, page 40
    9,                    // bLength
    0x24,                    // bDescriptorType, 0x24 = CS_INTERFACE
    3,                    // bDescriptorSubtype, 3 = OUTPUT_TERMINAL
    2,                    // bTerminalID
    0x01, 0x01,                // wTerminalType, 0x0101 = USB_STREAMING
    0,                    // bAssocTerminal, 0 = unidirectional
    1,                    // bCSourceID, connected to input terminal, ID=1
    0,                    // iTerminal
    // Input Terminal Descriptor
    // USB DCD for Audio Devices 1.0, Table 4-3, page 39
    12,                    // bLength
    0x24,                    // bDescriptorType, 0x24 = CS_INTERFACE
    2,                    // bDescriptorSubType, 2 = INPUT_TERMINAL
    3,                    // bTerminalID
    0x01, 0x01,                // wTerminalType, 0x0101 = USB_STREAMING
    0,                    // bAssocTerminal, 0 = unidirectional
    2,                    // bNrChannels
    0x03, 0x00,                // wChannelConfig, 0x0003 = Left & Right Front
    0,                    // iChannelNames
    0,                     // iTerminal
    // Volume feature descriptor
    10,                    // bLength
    0x24,                 // bDescriptorType = CS_INTERFACE
    0x06,                 // bDescriptorSubType = FEATURE_UNIT
    0x31,                 // bUnitID
    0x03,                 // bSourceID (Input Terminal)
    0x01,                 // bControlSize (each channel is 1 byte, 3 channels)
    0x01,                 // bmaControls(0) Master: Mute
    0x02,                 // bmaControls(1) Left: Volume
    0x02,                 // bmaControls(2) Right: Volume
    0x00,                // iFeature
    // Output Terminal Descriptor
    // USB DCD for Audio Devices 1.0, Table 4-4, page 40
    9,                    // bLength
    0x24,                    // bDescriptorType, 0x24 = CS_INTERFACE
    3,                    // bDescriptorSubtype, 3 = OUTPUT_TERMINAL
    4,                    // bTerminalID
    //0x02, 0x03,                // wTerminalType, 0x0302 = Headphones
    0x02, 0x06,                // wTerminalType, 0x0602 = Digital Audio
    0,                    // bAssocTerminal, 0 = unidirectional
    0x31,                // bCSourceID, connected to feature, ID=31
    0,                    // iTerminal
    // Standard AS Interface Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.5.1, Table 4-18, page 59
    // Alternate 0: default setting, disabled zero bandwidth
    9,                    // bLenght
    4,                    // bDescriptorType = INTERFACE
    AUDIO_INTERFACE+1,            // bInterfaceNumber
    0,                    // bAlternateSetting
    0,                    // bNumEndpoints
    1,                    // bInterfaceClass, 1 = AUDIO
    2,                    // bInterfaceSubclass, 2 = AUDIO_STREAMING
    0,                    // bInterfaceProtocol
    0,                    // iInterface
    // Alternate 1: streaming data
    9,                    // bLenght
    4,                    // bDescriptorType = INTERFACE
    AUDIO_INTERFACE+1,            // bInterfaceNumber
    1,                    // bAlternateSetting
    1,                    // bNumEndpoints
    1,                    // bInterfaceClass, 1 = AUDIO
    2,                    // bInterfaceSubclass, 2 = AUDIO_STREAMING
    0,                    // bInterfaceProtocol
    0,                    // iInterface
    // Class-Specific AS Interface Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.5.2, Table 4-19, page 60
    7,                     // bLength
    0x24,                    // bDescriptorType = CS_INTERFACE
    1,                    // bDescriptorSubtype, 1 = AS_GENERAL
    2,                    // bTerminalLink: Terminal ID = 2
    3,                    // bDelay (approx 3ms delay, audio lib updates)
    0x01, 0x00,                // wFormatTag, 0x0001 = PCM
    // Type I Format Descriptor
    // USB DCD for Audio Data Formats 1.0, Section 2.2.5, Table 2-1, page 10
    11,                    // bLength
    0x24,                    // bDescriptorType = CS_INTERFACE
    2,                    // bDescriptorSubtype = FORMAT_TYPE
    1,                    // bFormatType = FORMAT_TYPE_I
    2,                    // bNrChannels = 2
    2,                    // bSubFrameSize = 2 byte
    16,                    // bBitResolution = 16 bits
    1,                    // bSamFreqType = 1 frequency
    LSB(44100), MSB(44100), 0,        // tSamFreq
    // Standard AS Isochronous Audio Data Endpoint Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.6.1.1, Table 4-20, page 61-62
    9,                     // bLength
    5,                     // bDescriptorType, 5 = ENDPOINT_DESCRIPTOR
    AUDIO_TX_ENDPOINT | 0x80,        // bEndpointAddress
    0x09,                     // bmAttributes = isochronous, adaptive
    LSB(AUDIO_TX_SIZE), MSB(AUDIO_TX_SIZE),    // wMaxPacketSize
    1,                     // bInterval, 1 = every frame
    0,                    // bRefresh
    0,                    // bSynchAddress
    // Class-Specific AS Isochronous Audio Data Endpoint Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.6.1.2, Table 4-21, page 62-63
    7,                      // bLength
    0x25,                      // bDescriptorType, 0x25 = CS_ENDPOINT
    1,                      // bDescriptorSubtype, 1 = EP_GENERAL
    0x00,                      // bmAttributes
    0,                      // bLockDelayUnits, 1 = ms
    0x00, 0x00,                  // wLockDelay
    // Standard AS Interface Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.5.1, Table 4-18, page 59
    // Alternate 0: default setting, disabled zero bandwidth
    9,                    // bLenght
    4,                    // bDescriptorType = INTERFACE
    AUDIO_INTERFACE+2,            // bInterfaceNumber
    0,                    // bAlternateSetting
    0,                    // bNumEndpoints
    1,                    // bInterfaceClass, 1 = AUDIO
    2,                    // bInterfaceSubclass, 2 = AUDIO_STREAMING
    0,                    // bInterfaceProtocol
    0,                    // iInterface
    // Alternate 1: streaming data
    9,                    // bLenght
    4,                    // bDescriptorType = INTERFACE
    AUDIO_INTERFACE+2,            // bInterfaceNumber
    1,                    // bAlternateSetting
    2,                    // bNumEndpoints
    1,                    // bInterfaceClass, 1 = AUDIO
    2,                    // bInterfaceSubclass, 2 = AUDIO_STREAMING
    0,                    // bInterfaceProtocol
    0,                    // iInterface
    // Class-Specific AS Interface Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.5.2, Table 4-19, page 60
    7,                     // bLength
    0x24,                    // bDescriptorType = CS_INTERFACE
    1,                    // bDescriptorSubtype, 1 = AS_GENERAL
    3,                    // bTerminalLink: Terminal ID = 3
    3,                    // bDelay (approx 3ms delay, audio lib updates)
    0x01, 0x00,                // wFormatTag, 0x0001 = PCM
    // Type I Format Descriptor
    // USB DCD for Audio Data Formats 1.0, Section 2.2.5, Table 2-1, page 10
    11,                    // bLength
    0x24,                    // bDescriptorType = CS_INTERFACE
    2,                    // bDescriptorSubtype = FORMAT_TYPE
    1,                    // bFormatType = FORMAT_TYPE_I
    2,                    // bNrChannels = 2
    2,                    // bSubFrameSize = 2 byte
    16,                    // bBitResolution = 16 bits
    1,                    // bSamFreqType = 1 frequency
    LSB(44100), MSB(44100), 0,        // tSamFreq
    // Standard AS Isochronous Audio Data Endpoint Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.6.1.1, Table 4-20, page 61-62
    9,                     // bLength
    5,                     // bDescriptorType, 5 = ENDPOINT_DESCRIPTOR
    AUDIO_RX_ENDPOINT,            // bEndpointAddress
    0x05,                     // bmAttributes = isochronous, asynchronous
    LSB(AUDIO_RX_SIZE), MSB(AUDIO_RX_SIZE),    // wMaxPacketSize
    1,                     // bInterval, 1 = every frame
    0,                    // bRefresh
    AUDIO_SYNC_ENDPOINT | 0x80,        // bSynchAddress
    // Class-Specific AS Isochronous Audio Data Endpoint Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.6.1.2, Table 4-21, page 62-63
    7,                      // bLength
    0x25,                      // bDescriptorType, 0x25 = CS_ENDPOINT
    1,                      // bDescriptorSubtype, 1 = EP_GENERAL
    0x00,                      // bmAttributes
    0,                      // bLockDelayUnits, 1 = ms
    0x00, 0x00,                  // wLockDelay
    // Standard AS Isochronous Audio Synch Endpoint Descriptor
    // USB DCD for Audio Devices 1.0, Section 4.6.2.1, Table 4-22, page 63-64
    9,                     // bLength
    5,                     // bDescriptorType, 5 = ENDPOINT_DESCRIPTOR
    AUDIO_SYNC_ENDPOINT | 0x80,        // bEndpointAddress
    0x11,                     // bmAttributes = isochronous, feedback
    3, 0,                    // wMaxPacketSize, 3 bytes
    1,                     // bInterval, 1 = every frame
    5,                    // bRefresh, 5 = 32ms
    0,                    // bSynchAddress
#endif

#ifdef MULTITOUCH_INTERFACE
    // configuration for 12 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        MULTITOUCH_INTERFACE,                   // bInterfaceNumber
        0,                                      // bAlternateSetting
        1,                                      // bNumEndpoints
        0x03,                                   // bInterfaceClass (0x03 = HID)
        0x00,                                   // bInterfaceSubClass
        0x00,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // HID interface descriptor, HID 1.11 spec, section 6.2.1
        9,                                      // bLength
        0x21,                                   // bDescriptorType
        0x11, 0x01,                             // bcdHID
        0,                                      // bCountryCode
        1,                                      // bNumDescriptors
        0x22,                                   // bDescriptorType
        LSB(sizeof(multitouch_report_desc)),    // wDescriptorLength
        MSB(sizeof(multitouch_report_desc)),
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        MULTITOUCH_ENDPOINT | 0x80,             // bEndpointAddress
        0x03,                                   // bmAttributes (0x03=intr)
        MULTITOUCH_SIZE, 0,                     // wMaxPacketSize
        1,                                      // bInterval
#endif // MULTITOUCH_INTERFACE

#ifdef EXPERIMENTAL_INTERFACE
    // configuration for 12 Mbit/sec speed
        // interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
        9,                                      // bLength
        4,                                      // bDescriptorType
        EXPERIMENTAL_INTERFACE,                 // bInterfaceNumber
        0,                                      // bAlternateSetting
        2,                                      // bNumEndpoints
        0xFF,                                   // bInterfaceClass (0xFF = Vendor)
        0x6A,                                   // bInterfaceSubClass
        0xFF,                                   // bInterfaceProtocol
        0,                                      // iInterface
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        1 | 0x80,                               // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(64), MSB(64),                       // wMaxPacketSize
        1,                                      // bInterval
        // endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
        7,                                      // bLength
        5,                                      // bDescriptorType
        1,                                      // bEndpointAddress
        0x02,                                   // bmAttributes (0x02=bulk)
        LSB(64), MSB(64),                       // wMaxPacketSize
        1,                                      // bInterval
#endif // EXPERIMENTAL_INTERFACE
};


__attribute__ ((section(".dmabuffers"), aligned(32)))
uint8_t usb_descriptor_buffer[CONFIG_DESC_SIZE];





// **************************************************************
//   String Descriptors
// **************************************************************

// The descriptors above can provide human readable strings,
// referenced by index numbers.  These descriptors are the
// actual string data

/* defined in usb_names.h
struct usb_string_descriptor_struct {
        uint8_t bLength;
        uint8_t bDescriptorType;
        uint16_t wString[];
};
*/

extern struct usb_string_descriptor_struct usb_string_manufacturer_name
        __attribute__ ((weak, alias("usb_string_manufacturer_name_default")));
extern struct usb_string_descriptor_struct usb_string_product_name
        __attribute__ ((weak, alias("usb_string_product_name_default")));
extern struct usb_string_descriptor_struct usb_string_serial_number
        __attribute__ ((weak, alias("usb_string_serial_number_default")));

PROGMEM const struct usb_string_descriptor_struct string0 = {
        4,
        3,
        {0x0409}
};

PROGMEM const struct usb_string_descriptor_struct usb_string_manufacturer_name_default = {
        2 + MANUFACTURER_NAME_LEN * 2,
        3,
        MANUFACTURER_NAME
};
PROGMEM const struct usb_string_descriptor_struct usb_string_product_name_default = {
    2 + PRODUCT_NAME_LEN * 2,
        3,
        PRODUCT_NAME
};
struct usb_string_descriptor_struct usb_string_serial_number_default = {
        12,
        3,
        {0,0,0,0,0,0,0,0,0,0}
};
#ifdef MTP_INTERFACE
PROGMEM const struct usb_string_descriptor_struct usb_string_mtp = {
    2 + 3 * 2,
    3,
    {'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    char buf[11];
    uint32_t i, num;

    num = HW_OCOTP_MAC0 & 0xFFFFFF;
    // add extra zero to work around OS-X CDC-ACM driver bug
    if (num < 10000000) num = num * 10;
    ultoa(num, buf, 10);
    for (i=0; i<10; i++) {
        char c = buf[i];
        if (!c) break;
        usb_string_serial_number_default.wString[i] = c;
    }
    usb_string_serial_number_default.bLength = i * 2 + 2;
}


// **************************************************************
//   Descriptors List
// **************************************************************

// This table provides access to all the descriptor data above.

const usb_descriptor_list_t usb_descriptor_list[] = {
    //wValue, wIndex, address,          length
    {0x0100, 0x0000, device_descriptor, sizeof(device_descriptor)},
    {0x0600, 0x0000, qualifier_descriptor, sizeof(qualifier_descriptor)},
    {0x0200, 0x0000, usb_config_descriptor_480, CONFIG_DESC_SIZE},
    {0x0700, 0x0000, usb_config_descriptor_12, CONFIG_DESC_SIZE},
#ifdef SEREMU_INTERFACE
    {0x2200, SEREMU_INTERFACE, seremu_report_desc, sizeof(seremu_report_desc)},
    {0x2100, SEREMU_INTERFACE, usb_config_descriptor_480+SEREMU_HID_DESC_OFFSET, 9},
#endif
#ifdef KEYBOARD_INTERFACE
        {0x2200, KEYBOARD_INTERFACE, keyboard_report_desc, sizeof(keyboard_report_desc)},
        {0x2100, KEYBOARD_INTERFACE, usb_config_descriptor_480+KEYBOARD_HID_DESC_OFFSET, 9},
#endif
#ifdef MOUSE_INTERFACE
        {0x2200, MOUSE_INTERFACE, mouse_report_desc, sizeof(mouse_report_desc)},
        {0x2100, MOUSE_INTERFACE, usb_config_descriptor_480+MOUSE_HID_DESC_OFFSET, 9},
#endif
#ifdef JOYSTICK_INTERFACE
        {0x2200, JOYSTICK_INTERFACE, joystick_report_desc, sizeof(joystick_report_desc)},
        {0x2100, JOYSTICK_INTERFACE, usb_config_descriptor_480+JOYSTICK_HID_DESC_OFFSET, 9},
#endif
#ifdef RAWHID_INTERFACE
    {0x2200, RAWHID_INTERFACE, rawhid_report_desc, sizeof(rawhid_report_desc)},
    {0x2100, RAWHID_INTERFACE, usb_config_descriptor_480+RAWHID_HID_DESC_OFFSET, 9},
#endif
#ifdef FLIGHTSIM_INTERFACE
    {0x2200, FLIGHTSIM_INTERFACE, flightsim_report_desc, sizeof(flightsim_report_desc)},
    {0x2100, FLIGHTSIM_INTERFACE, usb_config_descriptor_480+FLIGHTSIM_HID_DESC_OFFSET, 9},
#endif
#ifdef KEYMEDIA_INTERFACE
        {0x2200, KEYMEDIA_INTERFACE, keymedia_report_desc, sizeof(keymedia_report_desc)},
        {0x2100, KEYMEDIA_INTERFACE, usb_config_descriptor_480+KEYMEDIA_HID_DESC_OFFSET, 9},
#endif
#ifdef MULTITOUCH_INTERFACE
        {0x2200, MULTITOUCH_INTERFACE, multitouch_report_desc, sizeof(multitouch_report_desc)},
        {0x2100, MULTITOUCH_INTERFACE, usb_config_descriptor_480+MULTITOUCH_HID_DESC_OFFSET, 9},
#endif
#ifdef MTP_INTERFACE
    {0x0304, 0x0409, (const uint8_t *)&usb_string_mtp, 0},
#endif
        {0x0300, 0x0000, (const uint8_t *)&string0, 0},
        {0x0301, 0x0409, (const uint8_t *)&usb_string_manufacturer_name, 0},
        {0x0302, 0x0409, (const uint8_t *)&usb_string_product_name, 0},
        {0x0303, 0x0409, (const uint8_t *)&usb_string_serial_number, 0},
    {0, 0, NULL, 0}
};





#endif // NUM_ENDPOINTS
//#endif // F_CPU >= 20 MHz

[@file: to_replace/usb_desc.h]
/* Teensyduino Core Library
 * http://www.pjrc.com/teensy/
 * Copyright (c) 2017 PJRC.COM, LLC.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * 1. The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * 2. If the Software is incorporated into a build system that allows
 * selection among a list of target devices, then similar target
 * devices manufactured by PJRC.COM must be included in the list of
 * target devices and selectable in the same manner.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#pragma once

// This header is NOT meant to be included when compiling
// user sketches in Arduino.  The low-level functions
// provided by usb_dev.c are meant to be called only by
// code which provides higher-level interfaces to the user.

#include <stdint.h>
#include <stddef.h>

#define ENDPOINT_TRANSMIT_UNUSED        0x00020000
#define ENDPOINT_TRANSMIT_ISOCHRONOUS   0x00C40000
#define ENDPOINT_TRANSMIT_BULK          0x00C80000
#define ENDPOINT_TRANSMIT_INTERRUPT     0x00CC0000
#define ENDPOINT_RECEIVE_UNUSED         0x00000002
#define ENDPOINT_RECEIVE_ISOCHRONOUS    0x000000C4
#define ENDPOINT_RECEIVE_BULK           0x000000C8
#define ENDPOINT_RECEIVE_INTERRUPT      0x000000CC

/*
Each group of #define lines below corresponds to one of the
settings in the Tools > USB Type menu.  This file defines what
type of USB device is actually created for each of those menu
options.

Each "interface" is a set of functionality your PC or Mac will
use and treat as if it is a unique device.  Within each interface,
the "endpoints" are the actual communication channels.  Most
interfaces use 1, 2 or 3 endpoints.  By editing only this file,
you can customize the USB Types to be any collection of interfaces.

To modify a USB Type, delete the XYZ_INTERFACE lines for any
interfaces you wish to remove, and copy them from another USB Type
for any you want to add.

Give each interface a unique number, and edit NUM_INTERFACE to
reflect the total number of interfaces.

Next, assign unique endpoint numbers to all the endpoints across
all the interfaces your device has.  You can reuse an endpoint
number for transmit and receive, but the same endpoint number must
not be used twice to transmit, or twice to receive.

Most endpoints also require their maximum size, and some also
need an interval specification (the number of milliseconds the
PC will check for data from that endpoint).  For existing
interfaces, usually these other settings should not be changed.

Edit NUM_ENDPOINTS to be at least the largest endpoint number used.

Edit the ENDPOINT*_CONFIG lines so each endpoint is configured
the proper way (transmit, receive, or both).

If you are using existing interfaces (making your own device with
a different set of interfaces) the code in all other files should
automatically adapt to the new endpoints you specify here.

If you need to create a new type of interface, you'll need to write
the code which sends and receives packets, and presents an API to
the user.  Usually, a pair of files are added for the actual code,
and code is also added in usb_dev.c for any control transfers,
interrupt-level code, or other very low-level stuff not possible
from the packet send/receive functons.  Code also is added in
usb_inst.c to create an instance of your C++ object.  This message
gives a quick summary of things you will need to know:
https://forum.pjrc.com/threads/49045?p=164512&viewfull=1#post164512

You may edit the Vendor and Product ID numbers, and strings.  If
the numbers are changed, Teensyduino may not be able to automatically
find and reboot your board when you click the Upload button in
the Arduino IDE.  You will need to press the Program button on
Teensy to initiate programming.

Some operating systems, especially Windows, may cache USB device
info.  Changes to the device name may not update on the same
computer unless the vendor or product ID numbers change, or the
"bcdDevice" revision code is increased.

If these instructions are missing steps or could be improved, please
let me know?  http://forum.pjrc.com/forums/4-Suggestions-amp-Bug-Reports
*/


#if defined(USB_SERIAL)
  #define VENDOR_ID                 0x16C0
  #define PRODUCT_ID                0x0483
  #define MANUFACTURER_NAME         {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN     11
  #define PRODUCT_NAME              {'U','S','B',' ','S','e','r','i','a','l'}
  #define PRODUCT_NAME_LEN          10
  #define EP0_SIZE                  64
  #define NUM_ENDPOINTS             4
  #define NUM_USB_BUFFERS           12
  #define NUM_INTERFACE             2
  #define CDC_IAD_DESCRIPTOR        1       // Serial
  #define CDC_STATUS_INTERFACE      0
  #define CDC_DATA_INTERFACE        1
  #define CDC_ACM_ENDPOINT          2
  #define CDC_RX_ENDPOINT           3
  #define CDC_TX_ENDPOINT           4
  #define CDC_ACM_SIZE              16
  #define CDC_RX_SIZE_480           512
  #define CDC_TX_SIZE_480           512
  #define CDC_RX_SIZE_12            64
  #define CDC_TX_SIZE_12            64
  //#define EXPERIMENTAL_INTERFACE 2
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_UNUSED
  #define ENDPOINT4_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_BULK

#elif defined(USB_DUAL_SERIAL)
  #define VENDOR_ID             0x16C0
  #define PRODUCT_ID            0x048B
  #define MANUFACTURER_NAME     {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN 11
  #define PRODUCT_NAME          {'D','u','a','l',' ','S','e','r','i','a','l'}
  #define PRODUCT_NAME_LEN      11
  #define EP0_SIZE              64
  #define NUM_ENDPOINTS         5
  #define NUM_INTERFACE         4
  #define CDC_IAD_DESCRIPTOR    1       // Serial
  #define CDC_STATUS_INTERFACE  0
  #define CDC_DATA_INTERFACE    1
  #define CDC_ACM_ENDPOINT      2
  #define CDC_RX_ENDPOINT       3
  #define CDC_TX_ENDPOINT       3
  #define CDC_ACM_SIZE          16
  #define CDC_RX_SIZE_480       512
  #define CDC_TX_SIZE_480       512
  #define CDC_RX_SIZE_12        64
  #define CDC_TX_SIZE_12        64
  #define CDC2_STATUS_INTERFACE 2       // SerialUSB1
  #define CDC2_DATA_INTERFACE   3
  #define CDC2_ACM_ENDPOINT     4
  #define CDC2_RX_ENDPOINT      5
  #define CDC2_TX_ENDPOINT      5
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK
  #define ENDPOINT4_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT5_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK

#elif defined(USB_TRIPLE_SERIAL)
  #define VENDOR_ID             0x16C0
  #define PRODUCT_ID            0x048C
  #define MANUFACTURER_NAME     {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN 11
  #define PRODUCT_NAME          {'T','r','i','p','l','e',' ','S','e','r','i','a','l'}
  #define PRODUCT_NAME_LEN      13
  #define EP0_SIZE              64
  #define NUM_ENDPOINTS         7
  #define NUM_INTERFACE         6
  #define CDC_IAD_DESCRIPTOR    1       // Serial
  #define CDC_STATUS_INTERFACE  0
  #define CDC_DATA_INTERFACE    1
  #define CDC_ACM_ENDPOINT      2
  #define CDC_RX_ENDPOINT       3
  #define CDC_TX_ENDPOINT       3
  #define CDC_ACM_SIZE          16
  #define CDC_RX_SIZE_480       512
  #define CDC_TX_SIZE_480       512
  #define CDC_RX_SIZE_12        64
  #define CDC_TX_SIZE_12        64
  #define CDC2_STATUS_INTERFACE 2       // SerialUSB1
  #define CDC2_DATA_INTERFACE   3
  #define CDC2_ACM_ENDPOINT     4
  #define CDC2_RX_ENDPOINT      5
  #define CDC2_TX_ENDPOINT      5
  #define CDC3_STATUS_INTERFACE 4       // SerialUSB2
  #define CDC3_DATA_INTERFACE   5
  #define CDC3_ACM_ENDPOINT     6
  #define CDC3_RX_ENDPOINT      7
  #define CDC3_TX_ENDPOINT      7
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK
  #define ENDPOINT4_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT5_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK
  #define ENDPOINT6_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT7_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK

#elif defined(USB_KEYBOARDONLY)
  #define VENDOR_ID             0x16C0
  #define PRODUCT_ID            0x04D0
  #define MANUFACTURER_NAME     {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN 11
  #define PRODUCT_NAME          {'K','e','y','b','o','a','r','d'}
  #define PRODUCT_NAME_LEN      8
  #define EP0_SIZE              64
  #define NUM_ENDPOINTS         4
  #define NUM_USB_BUFFERS       4
  #define NUM_INTERFACE         3
  #define SEREMU_INTERFACE      1    // Serial emulation
  #define SEREMU_TX_ENDPOINT    2
  #define SEREMU_TX_SIZE        64
  #define SEREMU_TX_INTERVAL    1    // TODO: is this ok for 480 Mbit speed
  #define SEREMU_RX_ENDPOINT    2
  #define SEREMU_RX_SIZE        32
  #define SEREMU_RX_INTERVAL    2    // TODO: is this ok for 480 Mbit speed
  #define KEYBOARD_INTERFACE    0    // Keyboard
  #define KEYBOARD_ENDPOINT     3
  #define KEYBOARD_SIZE         64
  #define KEYBOARD_INTERVAL     1    // TODO: is this ok for 480 Mbit speed
  #define KEYMEDIA_INTERFACE    2    // Keyboard Media Keys
  #define KEYMEDIA_ENDPOINT     4
  #define KEYMEDIA_SIZE         8
  #define KEYMEDIA_INTERVAL     4    // TODO: is this ok for 480 Mbit speed
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_INTERRUPT + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT4_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT

#elif defined(USB_HID)
  #define VENDOR_ID             0x16C0
  #define PRODUCT_ID            0x0482
  #define MANUFACTURER_NAME     {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN 11
  #define PRODUCT_NAME          {'K','e','y','b','o','a','r','d','/','M','o','u','s','e','/','J','o','y','s','t','i','c','k'}
  #define PRODUCT_NAME_LEN      23
  #define EP0_SIZE              64
  #define NUM_ENDPOINTS         6
  #define NUM_USB_BUFFERS       24
  #define NUM_INTERFACE         5
  #define SEREMU_INTERFACE      2    // Serial emulation
  #define SEREMU_TX_ENDPOINT    2
  #define SEREMU_TX_SIZE        64
  #define SEREMU_TX_INTERVAL    1
  #define SEREMU_RX_ENDPOINT    2
  #define SEREMU_RX_SIZE        32
  #define SEREMU_RX_INTERVAL    2
  #define KEYBOARD_INTERFACE    0    // Keyboard
  #define KEYBOARD_ENDPOINT     3
  #define KEYBOARD_SIZE         8
  #define KEYBOARD_INTERVAL     1
  #define KEYMEDIA_INTERFACE    4    // Keyboard Media Keys
  #define KEYMEDIA_ENDPOINT     4
  #define KEYMEDIA_SIZE         8
  #define KEYMEDIA_INTERVAL     4
  #define MOUSE_INTERFACE       1    // Mouse
  #define MOUSE_ENDPOINT        5
  #define MOUSE_SIZE            8
  #define MOUSE_INTERVAL        1
  #define JOYSTICK_INTERFACE    3    // Joystick
  #define JOYSTICK_ENDPOINT     6
  #define JOYSTICK_SIZE         12    //  12 = normal, 64 = extreme joystick
  #define JOYSTICK_INTERVAL     2
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_INTERRUPT + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT4_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT5_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT6_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT

#elif defined(USB_SERIAL_HID)
  #define VENDOR_ID             0x16C0
  #define PRODUCT_ID            0x0487
  #define DEVICE_CLASS          0xEF
  #define DEVICE_SUBCLASS       0x02
  #define DEVICE_PROTOCOL       0x01
  #define MANUFACTURER_NAME     {'D','e','w','e','\'','s',' ','N','u','t','s'}
  #define MANUFACTURER_NAME_LEN 11
  #define PRODUCT_NAME          {'D', 'e', 'w', 'e', ' ', 'U', 'S', 'B', '-', 'H', 'S', ' ', 'K', 'e', 'y', 'b', 'o', 'a', 'r', 'd', }
  #define PRODUCT_NAME_LEN      20
  #define EP0_SIZE              64
  #define NUM_ENDPOINTS         7
  #define NUM_INTERFACE         6
  #define CDC_IAD_DESCRIPTOR    1
  #define CDC_STATUS_INTERFACE  0
  #define CDC_DATA_INTERFACE    1    // Serial
  #define CDC_ACM_ENDPOINT      2
  #define CDC_RX_ENDPOINT       3
  #define CDC_TX_ENDPOINT       3
  #define CDC_ACM_SIZE          0xFFU
  #define CDC_RX_SIZE_480       1024U
  #define CDC_TX_SIZE_480       1024U
  #define CDC_RX_SIZE_12        64
  #define CDC_TX_SIZE_12        64
  #define KEYBOARD_INTERFACE    2    // Keyboard
  #define KEYBOARD_ENDPOINT     4
  #define KEYBOARD_SIZE         64
  #define KEYBOARD_INTERVAL     1
  #define KEYMEDIA_INTERFACE    5    // Keyboard Media Keys
  #define KEYMEDIA_ENDPOINT     5
  #define KEYMEDIA_SIZE         8
  #define KEYMEDIA_INTERVAL     4
  #define MOUSE_INTERFACE       3    // Mouse
  #define MOUSE_ENDPOINT        6
  #define MOUSE_SIZE            8
  #define MOUSE_INTERVAL        2
  #define JOYSTICK_INTERFACE    4    // Joystick
  #define JOYSTICK_ENDPOINT     7
  #define JOYSTICK_SIZE         12    //  12 = normal, 64 = extreme joystick
  #define JOYSTICK_INTERVAL     1
  #define ENDPOINT2_CONFIG      ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG      ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK
  #define ENDPOINT4_CONFIG      ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT5_CONFIG      ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT6_CONFIG      ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT7_CONFIG      ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT

#elif defined(USB_TOUCHSCREEN)
  #define VENDOR_ID             0x16C0
  #define PRODUCT_ID            0x04D3
  #define MANUFACTURER_NAME     {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN 11
  #define PRODUCT_NAME          {'K','e','y','b','o','a','r','d','/','T','o','u','c','h','s','c','r','e','e','n'}
  #define PRODUCT_NAME_LEN      20
  #define EP0_SIZE              64
  #define NUM_ENDPOINTS         5
  #define NUM_INTERFACE         4
  #define SEREMU_INTERFACE      1    // Serial emulation
  #define SEREMU_TX_ENDPOINT    2
  #define SEREMU_TX_SIZE        64
  #define SEREMU_TX_INTERVAL    1
  #define SEREMU_RX_ENDPOINT    2
  #define SEREMU_RX_SIZE        32
  #define SEREMU_RX_INTERVAL    2
  #define KEYBOARD_INTERFACE    0    // Keyboard
  #define KEYBOARD_ENDPOINT     3
  #define KEYBOARD_SIZE         8
  #define KEYBOARD_INTERVAL     1
  #define KEYMEDIA_INTERFACE    2    // Keyboard Media Keys
  #define KEYMEDIA_ENDPOINT     4
  #define KEYMEDIA_SIZE         8
  #define KEYMEDIA_INTERVAL     4
  #define MULTITOUCH_INTERFACE  3    // Touchscreen
  #define MULTITOUCH_ENDPOINT   5
  #define MULTITOUCH_SIZE       9
  #define MULTITOUCH_FINGERS    10
  #define ENDPOINT2_CONFIG      ENDPOINT_RECEIVE_INTERRUPT + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG      ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT4_CONFIG      ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT5_CONFIG      ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT

#elif defined(USB_HID_TOUCHSCREEN)
  #define VENDOR_ID        0x16C0
  #define PRODUCT_ID        0x04D4
  #define MANUFACTURER_NAME    {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN    11
  #define PRODUCT_NAME        {'K','e','y','b','o','a','r','d','/','M','o','u','s','e','/','T','o','u','c','h','s','c','r','e','e','n'}
  #define PRODUCT_NAME_LEN    26
  #define EP0_SIZE        64
  #define NUM_ENDPOINTS         6
  #define NUM_INTERFACE        5
  #define SEREMU_INTERFACE      2    // Serial emulation
  #define SEREMU_TX_ENDPOINT    2
  #define SEREMU_TX_SIZE        64
  #define SEREMU_TX_INTERVAL    1
  #define SEREMU_RX_ENDPOINT    2
  #define SEREMU_RX_SIZE        32
  #define SEREMU_RX_INTERVAL    2
  #define KEYBOARD_INTERFACE    0    // Keyboard
  #define KEYBOARD_ENDPOINT     3
  #define KEYBOARD_SIZE         8
  #define KEYBOARD_INTERVAL     1
  #define KEYMEDIA_INTERFACE    3    // Keyboard Media Keys
  #define KEYMEDIA_ENDPOINT     4
  #define KEYMEDIA_SIZE         8
  #define KEYMEDIA_INTERVAL     4
  #define MOUSE_INTERFACE       1    // Mouse
  #define MOUSE_ENDPOINT        6
  #define MOUSE_SIZE            8
  #define MOUSE_INTERVAL        2
  #define MULTITOUCH_INTERFACE  4    // Touchscreen
  #define MULTITOUCH_ENDPOINT   5
  #define MULTITOUCH_SIZE       9
  #define MULTITOUCH_FINGERS    10
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_INTERRUPT + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG      ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT4_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT5_CONFIG      ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT6_CONFIG      ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT

#elif defined(USB_MIDI)
  #define VENDOR_ID        0x16C0
  #define PRODUCT_ID        0x0485
  #define MANUFACTURER_NAME    {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN    11
  #define PRODUCT_NAME        {'T','e','e','n','s','y',' ','M','I','D','I'}
  #define PRODUCT_NAME_LEN    11
  #define EP0_SIZE        64
  #define NUM_ENDPOINTS         4
  #define NUM_INTERFACE        2
  #define SEREMU_INTERFACE      1    // Serial emulation
  #define SEREMU_TX_ENDPOINT    2
  #define SEREMU_TX_SIZE        64
  #define SEREMU_TX_INTERVAL    1
  #define SEREMU_RX_ENDPOINT    2
  #define SEREMU_RX_SIZE        32
  #define SEREMU_RX_INTERVAL    2
  #define MIDI_INTERFACE        0    // MIDI
  #define MIDI_NUM_CABLES       1
  #define MIDI_TX_ENDPOINT      3
  #define MIDI_TX_SIZE_12       64
  #define MIDI_TX_SIZE_480      512
  #define MIDI_RX_ENDPOINT      3
  #define MIDI_RX_SIZE_12       64
  #define MIDI_RX_SIZE_480      512
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_INTERRUPT + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK

#elif defined(USB_MIDI4)
  #define VENDOR_ID        0x16C0
  #define PRODUCT_ID        0x0485
  #define BCD_DEVICE        0x0211
  #define MANUFACTURER_NAME    {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN    11
  #define PRODUCT_NAME        {'T','e','e','n','s','y',' ','M','I','D','I','x','4'}
  #define PRODUCT_NAME_LEN    13
  #define EP0_SIZE        64
  #define NUM_ENDPOINTS         3
  #define NUM_INTERFACE        2
  #define SEREMU_INTERFACE      1    // Serial emulation
  #define SEREMU_TX_ENDPOINT    2
  #define SEREMU_TX_SIZE        64
  #define SEREMU_TX_INTERVAL    1
  #define SEREMU_RX_ENDPOINT    2
  #define SEREMU_RX_SIZE        32
  #define SEREMU_RX_INTERVAL    2
  #define MIDI_INTERFACE        0    // MIDI
  #define MIDI_NUM_CABLES       4
  #define MIDI_TX_ENDPOINT      3
  #define MIDI_TX_SIZE_12       64
  #define MIDI_TX_SIZE_480      512
  #define MIDI_RX_ENDPOINT      3
  #define MIDI_RX_SIZE_12       64
  #define MIDI_RX_SIZE_480      512
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_INTERRUPT + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK

#elif defined(USB_MIDI16)
  #define VENDOR_ID        0x16C0
  #define PRODUCT_ID        0x0485
  #define BCD_DEVICE        0x0212
  #define MANUFACTURER_NAME    {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN    11
  #define PRODUCT_NAME        {'T','e','e','n','s','y',' ','M','I','D','I','x','1','6'}
  #define PRODUCT_NAME_LEN    14
  #define EP0_SIZE        64
  #define NUM_ENDPOINTS         3
  #define NUM_INTERFACE        2
  #define SEREMU_INTERFACE      1    // Serial emulation
  #define SEREMU_TX_ENDPOINT    2
  #define SEREMU_TX_SIZE        64
  #define SEREMU_TX_INTERVAL    1
  #define SEREMU_RX_ENDPOINT    2
  #define SEREMU_RX_SIZE        32
  #define SEREMU_RX_INTERVAL    2
  #define MIDI_INTERFACE        0    // MIDI
  #define MIDI_NUM_CABLES       16
  #define MIDI_TX_ENDPOINT      3
  #define MIDI_TX_SIZE_12       64
  #define MIDI_TX_SIZE_480      512
  #define MIDI_RX_ENDPOINT      3
  #define MIDI_RX_SIZE_12       64
  #define MIDI_RX_SIZE_480      512
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_INTERRUPT + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK

#elif defined(USB_MIDI_SERIAL)
  #define VENDOR_ID        0x16C0
  #define PRODUCT_ID        0x0489
  #define MANUFACTURER_NAME    {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN    11
  #define PRODUCT_NAME        {'T','e','e','n','s','y',' ','M','I','D','I'}
  #define PRODUCT_NAME_LEN    11
  #define EP0_SIZE        64
  #define NUM_ENDPOINTS         4
  #define NUM_INTERFACE        3
  #define CDC_IAD_DESCRIPTOR    1
  #define CDC_STATUS_INTERFACE    0
  #define CDC_DATA_INTERFACE    1    // Serial
  #define CDC_ACM_ENDPOINT    2
  #define CDC_RX_ENDPOINT       3
  #define CDC_TX_ENDPOINT       3
  #define CDC_ACM_SIZE          16
  #define CDC_RX_SIZE_480       512
  #define CDC_TX_SIZE_480       512
  #define CDC_RX_SIZE_12        64
  #define CDC_TX_SIZE_12        64
  #define MIDI_INTERFACE        2    // MIDI
  #define MIDI_NUM_CABLES       1
  #define MIDI_TX_ENDPOINT      4
  #define MIDI_TX_SIZE_12       64
  #define MIDI_TX_SIZE_480      512
  #define MIDI_RX_ENDPOINT      4
  #define MIDI_RX_SIZE_12       64
  #define MIDI_RX_SIZE_480      512
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK
  #define ENDPOINT4_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK

#elif defined(USB_MIDI4_SERIAL)
  #define VENDOR_ID        0x16C0
  #define PRODUCT_ID        0x0489
  #define BCD_DEVICE        0x0211
  #define MANUFACTURER_NAME    {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN    11
  #define PRODUCT_NAME        {'T','e','e','n','s','y',' ','M','I','D','I','x','4'}
  #define PRODUCT_NAME_LEN    13
  #define EP0_SIZE        64
  #define NUM_ENDPOINTS         4
  #define NUM_INTERFACE        3
  #define CDC_IAD_DESCRIPTOR    1
  #define CDC_STATUS_INTERFACE    0
  #define CDC_DATA_INTERFACE    1    // Serial
  #define CDC_ACM_ENDPOINT    2
  #define CDC_RX_ENDPOINT       3
  #define CDC_TX_ENDPOINT       3
  #define CDC_ACM_SIZE          16
  #define CDC_RX_SIZE_480       512
  #define CDC_TX_SIZE_480       512
  #define CDC_RX_SIZE_12        64
  #define CDC_TX_SIZE_12        64
  #define MIDI_INTERFACE        2    // MIDI
  #define MIDI_NUM_CABLES       4
  #define MIDI_TX_ENDPOINT      4
  #define MIDI_TX_SIZE_12       64
  #define MIDI_TX_SIZE_480      512
  #define MIDI_RX_ENDPOINT      4
  #define MIDI_RX_SIZE_12       64
  #define MIDI_RX_SIZE_480      512
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK
  #define ENDPOINT4_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK

#elif defined(USB_MIDI16_SERIAL)
  #define VENDOR_ID        0x16C0
  #define PRODUCT_ID        0x0489
  #define BCD_DEVICE        0x0212
  #define MANUFACTURER_NAME    {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN    11
  #define PRODUCT_NAME        {'T','e','e','n','s','y',' ','M','I','D','I','x','1','6'}
  #define PRODUCT_NAME_LEN    14
  #define EP0_SIZE        64
  #define NUM_ENDPOINTS         4
  #define NUM_INTERFACE        3
  #define CDC_IAD_DESCRIPTOR    1
  #define CDC_STATUS_INTERFACE    0
  #define CDC_DATA_INTERFACE    1    // Serial
  #define CDC_ACM_ENDPOINT    2
  #define CDC_RX_ENDPOINT       3
  #define CDC_TX_ENDPOINT       3
  #define CDC_ACM_SIZE          16
  #define CDC_RX_SIZE_480       512
  #define CDC_TX_SIZE_480       512
  #define CDC_RX_SIZE_12        64
  #define CDC_TX_SIZE_12        64
  #define MIDI_INTERFACE        2    // MIDI
  #define MIDI_NUM_CABLES       16
  #define MIDI_TX_ENDPOINT      4
  #define MIDI_TX_SIZE_12       64
  #define MIDI_TX_SIZE_480      512
  #define MIDI_RX_ENDPOINT      4
  #define MIDI_RX_SIZE_12       64
  #define MIDI_RX_SIZE_480      512
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK
  #define ENDPOINT4_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK

#elif defined(USB_RAWHID)
  #define VENDOR_ID        0x16C0
  #define PRODUCT_ID        0x0486
  #define RAWHID_USAGE_PAGE    0xFFAB  // recommended: 0xFF00 to 0xFFFF
  #define RAWHID_USAGE        0x0200  // recommended: 0x0100 to 0xFFFF
  #define MANUFACTURER_NAME    {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN    11
  #define PRODUCT_NAME        {'T','e','e','n','s','y','d','u','i','n','o',' ','R','a','w','H','I','D'}
  #define PRODUCT_NAME_LEN    18
  #define EP0_SIZE        64
  #define NUM_ENDPOINTS         4
  #define NUM_INTERFACE        2
  #define RAWHID_INTERFACE      0    // RawHID
  #define RAWHID_TX_ENDPOINT    3
  #define RAWHID_TX_SIZE        64
  #define RAWHID_TX_INTERVAL    1     // TODO: is this ok for 480 Mbit speed
  #define RAWHID_RX_ENDPOINT    4
  #define RAWHID_RX_SIZE        64
  #define RAWHID_RX_INTERVAL    1     // TODO: is this ok for 480 Mbit speed
  #define SEREMU_INTERFACE      1    // Serial emulation
  #define SEREMU_TX_ENDPOINT    2
  #define SEREMU_TX_SIZE        64
  #define SEREMU_TX_INTERVAL    1     // TODO: is this ok for 480 Mbit speed
  #define SEREMU_RX_ENDPOINT    2
  #define SEREMU_RX_SIZE        32
  #define SEREMU_RX_INTERVAL    2     // TODO: is this ok for 480 Mbit speed
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_INTERRUPT + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT4_CONFIG    ENDPOINT_RECEIVE_INTERRUPT + ENDPOINT_TRANSMIT_UNUSED

#elif defined(USB_FLIGHTSIM)
  #define VENDOR_ID        0x16C0
  #define PRODUCT_ID        0x0488
  #define MANUFACTURER_NAME    {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN    11
  #define PRODUCT_NAME        {'T','e','e','n','s','y',' ','F','l','i','g','h','t',' ','S','i','m',' ','C','o','n','t','r','o','l','s'}
  #define PRODUCT_NAME_LEN    26
  #define EP0_SIZE        64
  #define NUM_ENDPOINTS         3
  #define NUM_INTERFACE        2
  #define FLIGHTSIM_INTERFACE    0    // Flight Sim Control
  #define FLIGHTSIM_TX_ENDPOINT    3
  #define FLIGHTSIM_TX_SIZE    64
  #define FLIGHTSIM_TX_INTERVAL    1
  #define FLIGHTSIM_RX_ENDPOINT    3
  #define FLIGHTSIM_RX_SIZE    64
  #define FLIGHTSIM_RX_INTERVAL    1
  #define SEREMU_INTERFACE      1    // Serial emulation
  #define SEREMU_TX_ENDPOINT    2
  #define SEREMU_TX_SIZE        64
  #define SEREMU_TX_INTERVAL    1
  #define SEREMU_RX_ENDPOINT    2
  #define SEREMU_RX_SIZE        32
  #define SEREMU_RX_INTERVAL    2
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_INTERRUPT + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK

#elif defined(USB_FLIGHTSIM_JOYSTICK)
  #define VENDOR_ID        0x16C0
  #define PRODUCT_ID        0x0488
  #define BCD_DEVICE        0x0211
  #define MANUFACTURER_NAME    {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN    11
  #define PRODUCT_NAME        {'T','e','e','n','s','y',' ','F','l','i','g','h','t',' ','S','i','m',' ','C','o','n','t','r','o','l','s'}
  #define PRODUCT_NAME_LEN    26
  #define EP0_SIZE        64
  #define NUM_ENDPOINTS         4
  #define NUM_INTERFACE        3
  #define FLIGHTSIM_INTERFACE    0    // Flight Sim Control
  #define FLIGHTSIM_TX_ENDPOINT    3
  #define FLIGHTSIM_TX_SIZE    64
  #define FLIGHTSIM_TX_INTERVAL    1
  #define FLIGHTSIM_RX_ENDPOINT    3
  #define FLIGHTSIM_RX_SIZE    64
  #define FLIGHTSIM_RX_INTERVAL    1
  #define SEREMU_INTERFACE      1    // Serial emulation
  #define SEREMU_TX_ENDPOINT    2
  #define SEREMU_TX_SIZE        64
  #define SEREMU_TX_INTERVAL    1
  #define SEREMU_RX_ENDPOINT    2
  #define SEREMU_RX_SIZE        32
  #define SEREMU_RX_INTERVAL    2
  #define JOYSTICK_INTERFACE    2    // Joystick
  #define JOYSTICK_ENDPOINT     4
  #define JOYSTICK_SIZE         12    //  12 = normal, 64 = extreme joystick
  #define JOYSTICK_INTERVAL     1
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_INTERRUPT + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK
  #define ENDPOINT4_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT

#elif defined(USB_MTPDISK)
  #define VENDOR_ID        0x16C0
  #define PRODUCT_ID        0x04D1
  #define MANUFACTURER_NAME    {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN    11
  #define PRODUCT_NAME        {'T','e','e','n','s','y',' ','M','T','P',' ','D','i','s','k'}
  #define PRODUCT_NAME_LEN    15
  #define EP0_SIZE        64
  #define NUM_ENDPOINTS         4
  #define NUM_INTERFACE        2
  #define MTP_INTERFACE        1    // MTP Disk
  #define MTP_TX_ENDPOINT    3
  #define MTP_TX_SIZE_12    64
  #define MTP_TX_SIZE_480    512
  #define MTP_RX_ENDPOINT    3
  #define MTP_RX_SIZE_12    64
  #define MTP_RX_SIZE_480    512
  #define MTP_EVENT_ENDPOINT    4
  #define MTP_EVENT_SIZE    32
  #define MTP_EVENT_INTERVAL_12    10    // 10 = 10 ms
  #define MTP_EVENT_INTERVAL_480 7    // 7 = 8 ms
  #define SEREMU_INTERFACE      0    // Serial emulation
  #define SEREMU_TX_ENDPOINT    2
  #define SEREMU_TX_SIZE        64
  #define SEREMU_TX_INTERVAL    1
  #define SEREMU_RX_ENDPOINT    2
  #define SEREMU_RX_SIZE        32
  #define SEREMU_RX_INTERVAL    2
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_INTERRUPT + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK
  #define ENDPOINT4_CONFIG  ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT

#elif defined(USB_AUDIO)
  #define VENDOR_ID        0x16C0
  #define PRODUCT_ID        0x04D2
  #define MANUFACTURER_NAME    {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN    11
  #define PRODUCT_NAME        {'T','e','e','n','s','y',' ','A','u','d','i','o'}
  #define PRODUCT_NAME_LEN    12
  #define EP0_SIZE        64
  #define NUM_ENDPOINTS         4
  #define NUM_INTERFACE        4
  #define SEREMU_INTERFACE      0    // Serial emulation
  #define SEREMU_TX_ENDPOINT    2
  #define SEREMU_TX_SIZE        64
  #define SEREMU_TX_INTERVAL    1
  #define SEREMU_RX_ENDPOINT    2
  #define SEREMU_RX_SIZE        32
  #define SEREMU_RX_INTERVAL    2
  #define AUDIO_INTERFACE    1    // Audio (uses 3 consecutive interfaces)
  #define AUDIO_TX_ENDPOINT     3
  #define AUDIO_TX_SIZE         180
  #define AUDIO_RX_ENDPOINT     3
  #define AUDIO_RX_SIZE         180
  #define AUDIO_SYNC_ENDPOINT    4
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_INTERRUPT + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_ISOCHRONOUS + ENDPOINT_TRANSMIT_ISOCHRONOUS
  #define ENDPOINT4_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_ISOCHRONOUS

#elif defined(USB_MIDI_AUDIO_SERIAL)
  #define VENDOR_ID        0x16C0
  #define PRODUCT_ID        0x048A
  #define MANUFACTURER_NAME    {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN    11
  #define PRODUCT_NAME        {'T','e','e','n','s','y',' ','M','I','D','I','/','A','u','d','i','o'}
  #define PRODUCT_NAME_LEN    17
  #define EP0_SIZE        64
  #define NUM_ENDPOINTS         6
  #define NUM_INTERFACE        6
  #define CDC_IAD_DESCRIPTOR    1
  #define CDC_STATUS_INTERFACE    0
  #define CDC_DATA_INTERFACE    1    // Serial
  #define CDC_ACM_ENDPOINT    2
  #define CDC_RX_ENDPOINT       3
  #define CDC_TX_ENDPOINT       3
  #define CDC_ACM_SIZE          16
  #define CDC_RX_SIZE_480       512
  #define CDC_TX_SIZE_480       512
  #define CDC_RX_SIZE_12        64
  #define CDC_TX_SIZE_12        64
  #define MIDI_INTERFACE        2    // MIDI
  #define MIDI_NUM_CABLES       1
  #define MIDI_TX_ENDPOINT      4
  #define MIDI_TX_SIZE_12       64
  #define MIDI_TX_SIZE_480      512
  #define MIDI_RX_ENDPOINT      4
  #define MIDI_RX_SIZE_12       64
  #define MIDI_RX_SIZE_480      512
  #define AUDIO_INTERFACE    3    // Audio (uses 3 consecutive interfaces)
  #define AUDIO_TX_ENDPOINT     5
  #define AUDIO_TX_SIZE         180
  #define AUDIO_RX_ENDPOINT     5
  #define AUDIO_RX_SIZE         180
  #define AUDIO_SYNC_ENDPOINT    6
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK
  #define ENDPOINT4_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK
  #define ENDPOINT5_CONFIG    ENDPOINT_RECEIVE_ISOCHRONOUS + ENDPOINT_TRANSMIT_ISOCHRONOUS
  #define ENDPOINT6_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_ISOCHRONOUS

#elif defined(USB_MIDI16_AUDIO_SERIAL)
  #define VENDOR_ID        0x16C0
  #define PRODUCT_ID        0x048A
  #define BCD_DEVICE        0x0212
  #define MANUFACTURER_NAME    {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN    11
  #define PRODUCT_NAME        {'T','e','e','n','s','y',' ','M','I','D','I','x','1','6','/','A','u','d','i','o'}
  #define PRODUCT_NAME_LEN    20
  #define EP0_SIZE        64
  #define NUM_ENDPOINTS         8
  #define NUM_INTERFACE        6
  #define CDC_IAD_DESCRIPTOR    1
  #define CDC_STATUS_INTERFACE    0
  #define CDC_DATA_INTERFACE    1    // Serial
  #define CDC_ACM_ENDPOINT    2
  #define CDC_RX_ENDPOINT       3
  #define CDC_TX_ENDPOINT       3
  #define CDC_ACM_SIZE          16
  #define CDC_RX_SIZE_480       512
  #define CDC_TX_SIZE_480       512
  #define CDC_RX_SIZE_12        64
  #define CDC_TX_SIZE_12        64
  #define MIDI_INTERFACE        2    // MIDI
  #define MIDI_NUM_CABLES       16
  #define MIDI_TX_ENDPOINT      4
  #define MIDI_TX_SIZE_12       64
  #define MIDI_TX_SIZE_480      512
  #define MIDI_RX_ENDPOINT      4
  #define MIDI_RX_SIZE_12       64
  #define MIDI_RX_SIZE_480      512
  #define AUDIO_INTERFACE    3    // Audio (uses 3 consecutive interfaces)
  #define AUDIO_TX_ENDPOINT     5
  #define AUDIO_TX_SIZE         180
  #define AUDIO_RX_ENDPOINT     5
  #define AUDIO_RX_SIZE         180
  #define AUDIO_SYNC_ENDPOINT    6
  #define ENDPOINT2_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
  #define ENDPOINT3_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK
  #define ENDPOINT4_CONFIG    ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK
  #define ENDPOINT5_CONFIG    ENDPOINT_RECEIVE_ISOCHRONOUS + ENDPOINT_TRANSMIT_ISOCHRONOUS
  #define ENDPOINT6_CONFIG    ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_ISOCHRONOUS

#elif defined(USB_EVERYTHING)
  #define VENDOR_ID        0x16C0
  #define PRODUCT_ID        0x0476
  #define RAWHID_USAGE_PAGE    0xFFAB  // recommended: 0xFF00 to 0xFFFF
  #define RAWHID_USAGE        0x0200  // recommended: 0x0100 to 0xFFFF
  #define DEVICE_CLASS        0xEF
  #define DEVICE_SUBCLASS    0x02
  #define DEVICE_PROTOCOL    0x01
  #define MANUFACTURER_NAME    {'T','e','e','n','s','y','d','u','i','n','o'}
  #define MANUFACTURER_NAME_LEN    11
  #define PRODUCT_NAME        {'A','l','l',' ','T','h','e',' ','T','h','i','n','g','s'}
  #define PRODUCT_NAME_LEN    14
  #define EP0_SIZE        64
  #define NUM_ENDPOINTS         15
  #define NUM_INTERFACE        13
  #define CDC_IAD_DESCRIPTOR    1
  #define CDC_STATUS_INTERFACE    0
  #define CDC_DATA_INTERFACE    1    // Serial
  #define CDC_ACM_ENDPOINT    1
  #define CDC_RX_ENDPOINT       2
  #define CDC_TX_ENDPOINT       2
  #define CDC_ACM_SIZE          16
  #define CDC_RX_SIZE           64
  #define CDC_TX_SIZE           64
  #define MIDI_INTERFACE        2    // MIDI
  #define MIDI_NUM_CABLES       16
  #define MIDI_TX_ENDPOINT      3
  #define MIDI_TX_SIZE          64
  #define MIDI_RX_ENDPOINT      3
  #define MIDI_RX_SIZE          64
  #define KEYBOARD_INTERFACE    3    // Keyboard
  #define KEYBOARD_ENDPOINT     4
  #define KEYBOARD_SIZE         8
  #define KEYBOARD_INTERVAL     1
  #define MOUSE_INTERFACE       4    // Mouse
  #define MOUSE_ENDPOINT        5
  #define MOUSE_SIZE            8
  #define MOUSE_INTERVAL        2
  #define RAWHID_INTERFACE      5    // RawHID
  #define RAWHID_TX_ENDPOINT    6
  #define RAWHID_TX_SIZE        64
  #define RAWHID_TX_INTERVAL    1
  #define RAWHID_RX_ENDPOINT    6
  #define RAWHID_RX_SIZE        64
  #define RAWHID_RX_INTERVAL    1
  #define FLIGHTSIM_INTERFACE    6    // Flight Sim Control
  #define FLIGHTSIM_TX_ENDPOINT    9
  #define FLIGHTSIM_TX_SIZE    64
  #define FLIGHTSIM_TX_INTERVAL    1
  #define FLIGHTSIM_RX_ENDPOINT    9
  #define FLIGHTSIM_RX_SIZE    64
  #define FLIGHTSIM_RX_INTERVAL    1
  #define JOYSTICK_INTERFACE    7    // Joystick
  #define JOYSTICK_ENDPOINT     10
  #define JOYSTICK_SIZE         12    //  12 = normal, 64 = extreme joystick
  #define JOYSTICK_INTERVAL     1
/*
  #define MTP_INTERFACE        8    // MTP Disk
  #define MTP_TX_ENDPOINT    11
  #define MTP_TX_SIZE        64
  #define MTP_RX_ENDPOINT    3
  #define MTP_RX_SIZE        64
  #define MTP_EVENT_ENDPOINT    11
  #define MTP_EVENT_SIZE    16
  #define MTP_EVENT_INTERVAL    10
*/
  #define KEYMEDIA_INTERFACE    8    // Keyboard Media Keys
  #define KEYMEDIA_ENDPOINT     12
  #define KEYMEDIA_SIZE         8
  #define KEYMEDIA_INTERVAL     4
  #define AUDIO_INTERFACE    9    // Audio (uses 3 consecutive interfaces)
  #define AUDIO_TX_ENDPOINT     13
  #define AUDIO_TX_SIZE         180
  #define AUDIO_RX_ENDPOINT     13
  #define AUDIO_RX_SIZE         180
  #define AUDIO_SYNC_ENDPOINT    14
  #define MULTITOUCH_INTERFACE  12    // Touchscreen
  #define MULTITOUCH_ENDPOINT   15
  #define MULTITOUCH_SIZE       9
  #define MULTITOUCH_FINGERS    10
  #define ENDPOINT1_CONFIG    ENDPOINT_TRANSMIT_ONLY
  #define ENDPOINT2_CONFIG    ENDPOINT_TRANSMIT_AND_RECEIVE
  #define ENDPOINT3_CONFIG    ENDPOINT_TRANSMIT_AND_RECEIVE
  #define ENDPOINT4_CONFIG    ENDPOINT_TRANSMIT_ONLY
  #define ENDPOINT5_CONFIG    ENDPOINT_TRANSMIT_ONLY
  #define ENDPOINT6_CONFIG    ENDPOINT_TRANSMIT_AND_RECEIVE
  #define ENDPOINT7_CONFIG    ENDPOINT_TRANSMIT_AND_RECEIVE
  #define ENDPOINT8_CONFIG    ENDPOINT_TRANSMIT_ONLY
  #define ENDPOINT9_CONFIG    ENDPOINT_TRANSMIT_AND_RECEIVE
  #define ENDPOINT10_CONFIG    ENDPOINT_TRANSMIT_ONLY
  #define ENDPOINT11_CONFIG    ENDPOINT_TRANSMIT_AND_RECEIVE
  #define ENDPOINT12_CONFIG    ENDPOINT_TRANSMIT_ONLY
  #define ENDPOINT13_CONFIG    (ENDPOINT_RECEIVE_ISOCHRONOUS|ENDPOINT_TRANSMIT_ISOCHRONOUS)
  #define ENDPOINT14_CONFIG    ENDPOINT_TRANSMIT_ISOCHRONOUS
  #define ENDPOINT15_CONFIG    ENDPOINT_TRANSMIT_ONLY

#endif

#ifdef USB_DESC_LIST_DEFINE
#if defined(NUM_ENDPOINTS) && NUM_ENDPOINTS > 0
// NUM_ENDPOINTS = number of non-zero endpoints (0 to 7)
extern const uint32_t usb_endpoint_config_table[NUM_ENDPOINTS];

typedef struct {
    uint16_t    wValue;
    uint16_t    wIndex;
    const uint8_t    *addr;
    uint16_t    length;
} usb_descriptor_list_t;

extern const usb_descriptor_list_t usb_descriptor_list[];
#endif // NUM_ENDPOINTS
#endif // USB_DESC_LIST_DEFINE


[@file: to_replace/usb_keyboard.c]
/* Teensyduino Core Library
 * http://www.pjrc.com/teensy/
 * Copyright (c) 2017 PJRC.COM, LLC.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * 1. The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * 2. If the Software is incorporated into a build system that allows
 * selection among a list of target devices, then similar target
 * devices manufactured by PJRC.COM must be included in the list of
 * target devices and selectable in the same manner.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include "usb_dev.h"
#include "usb_keyboard.h"
#include "core_pins.h" // for yield()
#include "keylayouts.h"
#include <string.h> // for memcpy()
#include "avr/pgmspace.h" // for PROGMEM, DMAMEM, FASTRUN
#include "debug/printf.h"
#include "core_pins.h"

#ifdef KEYBOARD_INTERFACE // defined by usb_dev.h -> usb_desc.h

// which modifier keys are currently pressed
// 1=left ctrl,       2=left shift,   4=left alt,      8=left gui
// 16=right ctrl, 32=right shift, 64=right alt, 128=right gui
uint8_t keyboard_modifier_keys=0;

// which keys are currently pressed, up to 6 keys may be down at once
uint8_t keyboard_keys[KEYBOARD_SIZE-2] = {0};

#ifdef KEYMEDIA_INTERFACE
uint16_t keymedia_consumer_keys[4];
uint8_t keymedia_system_keys[3];
#endif

// protocol setting from the host.  We use exactly the same report
// either way, so this variable only stores the setting since we
// are required to be able to report which setting is in use.
uint8_t keyboard_protocol=1;

// the idle configuration, how often we send the report to the
// host (ms * 4) even when it hasn't changed
uint8_t keyboard_idle_config=125;

// count until idle timeout
uint8_t keyboard_idle_count=0;

// 1=num lock, 2=caps lock, 4=scroll lock, 8=compose, 16=kana
volatile uint8_t keyboard_leds=0;



static KEYCODE_TYPE unicode_to_keycode(uint16_t cpoint);
static void write_key(KEYCODE_TYPE keycode);
static uint8_t keycode_to_modifier(KEYCODE_TYPE keycode);
static uint8_t keycode_to_key(KEYCODE_TYPE keycode);
static void usb_keyboard_press_key(uint8_t key, uint8_t modifier);
static void usb_keyboard_release_key(uint8_t key, uint8_t modifier);
#ifdef DEADKEYS_MASK
static KEYCODE_TYPE deadkey_to_keycode(KEYCODE_TYPE keycode);
#endif
#ifdef KEYMEDIA_INTERFACE
static void usb_keymedia_press_consumer_key(uint16_t key);
static void usb_keymedia_release_consumer_key(uint16_t key);
static void usb_keymedia_press_system_key(uint8_t key);
static void usb_keymedia_release_system_key(uint8_t key);
static int usb_keymedia_send(void);
#endif


#define TX_NUM     12
#define TX_BUFSIZE 64
static transfer_t tx_transfer[TX_NUM] __attribute__ ((used, aligned(32)));
DMAMEM static uint8_t txbuffer[TX_NUM * TX_BUFSIZE] __attribute__ ((aligned(32)));
static uint8_t tx_head=0;
#if KEYBOARD_SIZE > TX_BUFSIZE
#error "Internal error, transmit buffer size is too small for keyboard endpoint"
#endif
#if defined(KEYMEDIA_INTERFACE) && KEYMEDIA_SIZE > TX_BUFSIZE
#error "Internal error, transmit buffer size is too small for media keys endpoint"
#endif


void usb_keyboard_configure(void)
{
    memset(tx_transfer, 0, sizeof(tx_transfer));
    tx_head = 0;
    usb_config_tx(KEYBOARD_ENDPOINT, KEYBOARD_SIZE, 0, NULL);  // normal keys use 8 byte packet
#ifdef KEYMEDIA_INTERFACE
    usb_config_tx(KEYMEDIA_ENDPOINT, KEYMEDIA_SIZE, 0, NULL);  // media keys use 8 byte packet
#endif
}


// Step #1, decode UTF8 to Unicode code points
//
void usb_keyboard_write(uint8_t c)
{
    static int utf8_state=0;
    static uint16_t unicode_wchar=0;

    if (c < 0x80) {
        // single byte encoded, 0x00 to 0x7F
        utf8_state = 0;
        usb_keyboard_write_unicode(c);
    } else if (c < 0xC0) {
        // 2nd, 3rd or 4th byte, 0x80 to 0xBF
        c &= 0x3F;
        if (utf8_state == 1) {
            utf8_state = 0;
            usb_keyboard_write_unicode(unicode_wchar | c);
        } else if (utf8_state == 2) {
            unicode_wchar |= ((uint16_t)c << 6);
            utf8_state = 1;
        }
    } else if (c < 0xE0) {
        // begin 2 byte sequence, 0xC2 to 0xDF
        // or illegal 2 byte sequence, 0xC0 to 0xC1
        unicode_wchar = (uint16_t)(c & 0x1F) << 6;
        utf8_state = 1;
    } else if (c < 0xF0) {
        // begin 3 byte sequence, 0xE0 to 0xEF
        unicode_wchar = (uint16_t)(c & 0x0F) << 12;
        utf8_state = 2;
    } else {
        // begin 4 byte sequence (not supported), 0xF0 to 0xF4
        // or illegal, 0xF5 to 0xFF
        utf8_state = 255;
    }
}


// Step #2: translate Unicode code point to keystroke sequence
//
static KEYCODE_TYPE unicode_to_keycode(uint16_t cpoint)
{
    // Unicode code points beyond U+FFFF are not supported
    // technically this input should probably be called UCS-2
    if (cpoint < 32) {
        if (cpoint == 10) return KEY_ENTER & KEYCODE_MASK;
        if (cpoint == 11) return KEY_TAB & KEYCODE_MASK;
        return 0;
    }
    if (cpoint < 128) {
        return keycodes_ascii[cpoint - 0x20];
    }
    #ifdef ISO_8859_1_A0
    if (cpoint >= 0xA0 && cpoint < 0x100) {
        return keycodes_iso_8859_1[cpoint - 0xA0];
    }
    #endif
    //#ifdef UNICODE_20AC
    //if (cpoint == 0x20AC) return UNICODE_20AC & 0x3FFF;
    //#endif
    #ifdef KEYCODE_EXTRA00
    if (cpoint == UNICODE_EXTRA00) return (KEYCODE_EXTRA00) & 0x3FFF;
    #endif
    #ifdef KEYCODE_EXTRA01
    if (cpoint == UNICODE_EXTRA01) return (KEYCODE_EXTRA01) & 0x3FFF;
    #endif
    #ifdef KEYCODE_EXTRA02
    if (cpoint == UNICODE_EXTRA02) return (KEYCODE_EXTRA02) & 0x3FFF;
    #endif
    #ifdef KEYCODE_EXTRA03
    if (cpoint == UNICODE_EXTRA03) return (KEYCODE_EXTRA03) & 0x3FFF;
    #endif
    #ifdef KEYCODE_EXTRA04
    if (cpoint == UNICODE_EXTRA04) return (KEYCODE_EXTRA04) & 0x3FFF;
    #endif
    #ifdef KEYCODE_EXTRA05
    if (cpoint == UNICODE_EXTRA05) return (KEYCODE_EXTRA05) & 0x3FFF;
    #endif
    #ifdef KEYCODE_EXTRA06
    if (cpoint == UNICODE_EXTRA06) return (KEYCODE_EXTRA06) & 0x3FFF;
    #endif
    #ifdef KEYCODE_EXTRA07
    if (cpoint == UNICODE_EXTRA07) return (KEYCODE_EXTRA07) & 0x3FFF;
    #endif
    #ifdef KEYCODE_EXTRA08
    if (cpoint == UNICODE_EXTRA08) return (KEYCODE_EXTRA08) & 0x3FFF;
    #endif
    #ifdef KEYCODE_EXTRA09
    if (cpoint == UNICODE_EXTRA09) return (KEYCODE_EXTRA09) & 0x3FFF;
    #endif
    #ifdef KEYCODE_EXTRA0A
    if (cpoint == UNICODE_EXTRA0A) return (KEYCODE_EXTRA0A) & 0x3FFF;
    #endif
    return 0;
}

// Step #3: execute keystroke sequence
//
#ifdef DEADKEYS_MASK
static KEYCODE_TYPE deadkey_to_keycode(KEYCODE_TYPE keycode)
{
    keycode &= DEADKEYS_MASK;
    if (keycode == 0) return 0;
    #ifdef ACUTE_ACCENT_BITS
    if (keycode == ACUTE_ACCENT_BITS) return DEADKEY_ACUTE_ACCENT;
    #endif
    #ifdef CEDILLA_BITS
    if (keycode == CEDILLA_BITS) return DEADKEY_CEDILLA;
    #endif
    #ifdef CIRCUMFLEX_BITS
    if (keycode == CIRCUMFLEX_BITS) return DEADKEY_CIRCUMFLEX;
    #endif
    #ifdef DIAERESIS_BITS
    if (keycode == DIAERESIS_BITS) return DEADKEY_DIAERESIS;
    #endif
    #ifdef GRAVE_ACCENT_BITS
    if (keycode == GRAVE_ACCENT_BITS) return DEADKEY_GRAVE_ACCENT;
    #endif
    #ifdef TILDE_BITS
    if (keycode == TILDE_BITS) return DEADKEY_TILDE;
    #endif
    #ifdef RING_ABOVE_BITS
    if (keycode == RING_ABOVE_BITS) return DEADKEY_RING_ABOVE;
    #endif
    #ifdef DEGREE_SIGN_BITS
    if (keycode == DEGREE_SIGN_BITS) return DEADKEY_DEGREE_SIGN;
    #endif
    #ifdef CARON_BITS
    if (keycode == CARON_BITS) return DEADKEY_CARON;
    #endif
    #ifdef BREVE_BITS
    if (keycode == BREVE_BITS) return DEADKEY_BREVE;
    #endif
    #ifdef OGONEK_BITS
    if (keycode == OGONEK_BITS) return DEADKEY_OGONEK;
    #endif
    #ifdef DOT_ABOVE_BITS
    if (keycode == DOT_ABOVE_BITS) return DEADKEY_DOT_ABOVE;
    #endif
    #ifdef DOUBLE_ACUTE_BITS
    if (keycode == DOUBLE_ACUTE_BITS) return DEADKEY_DOUBLE_ACUTE;
    #endif
    return 0;
}
#endif

void usb_keyboard_write_unicode(uint16_t cpoint)
{
    KEYCODE_TYPE keycode;

    keycode = unicode_to_keycode(cpoint);
    if (keycode) {
        #ifdef DEADKEYS_MASK
        KEYCODE_TYPE deadkeycode = deadkey_to_keycode(keycode);
        if (deadkeycode) write_key(deadkeycode);
        #endif
        write_key(keycode);
    }
}


// Step #4: do each keystroke
//
static void write_key(KEYCODE_TYPE keycode)
{
/*
    uint8_t key, modifier=0;

    #ifdef SHIFT_MASK
    if (keycode & SHIFT_MASK) modifier |= MODIFIERKEY_SHIFT;
    #endif
    #ifdef ALTGR_MASK
    if (keycode & ALTGR_MASK) modifier |= MODIFIERKEY_RIGHT_ALT;
    #endif
    #ifdef RCTRL_MASK
    if (keycode & RCTRL_MASK) modifier |= MODIFIERKEY_RIGHT_CTRL;
    #endif
    key = keycode & 0x3F;
    #ifdef KEY_NON_US_100
    if (key == KEY_NON_US_100) key = 100;
    #endif
    usb_keyboard_press(key, modifier);
*/
    usb_keyboard_press(keycode_to_key(keycode), keycode_to_modifier(keycode));
}

static uint8_t keycode_to_modifier(KEYCODE_TYPE keycode)
{
    uint8_t modifier=0;

    #ifdef SHIFT_MASK
    if (keycode & SHIFT_MASK) modifier |= MODIFIERKEY_SHIFT;
    #endif
    #ifdef ALTGR_MASK
    if (keycode & ALTGR_MASK) modifier |= MODIFIERKEY_RIGHT_ALT;
    #endif
    #ifdef RCTRL_MASK
    if (keycode & RCTRL_MASK) modifier |= MODIFIERKEY_RIGHT_CTRL;
    #endif
    return modifier;
}

static uint8_t keycode_to_key(KEYCODE_TYPE keycode)
{
    uint8_t key = keycode & 0x3F;
    #ifdef KEY_NON_US_100
    if (key == KEY_NON_US_100) key = 100;
    #endif
    return key;
}


// Input can be:
//     32 - 127     ASCII direct (U+0020 to U+007F) <-- uses layout
//    128 - 0xC1FF  Unicode direct (U+0080 to U+C1FF) <-- uses layout
// 0xC200 - 0xDFFF  Unicode UTF8 packed (U+0080 to U+07FF) <-- uses layout
// 0xE000 - 0xE0FF  Modifier key (bitmap, 8 keys, shift/ctrl/alt/gui)
// 0xE200 - 0xE2FF  System key (HID usage code, within usage page 1)
// 0xE400 - 0xE7FF  Media/Consumer key (HID usage code, within usage page 12)
// 0xF000 - 0xFFFF  Normal key (HID usage code, within usage page 7)

void usb_keyboard_press_keycode(uint16_t n)
{
    uint8_t key, mod, msb, modrestore=0;
    KEYCODE_TYPE keycode;
    #ifdef DEADKEYS_MASK
    KEYCODE_TYPE deadkeycode;
    #endif

    msb = n >> 8;

    if (msb >= 0xC2) {
        if (msb <= 0xDF) {
            n = (n & 0x3F) | ((uint16_t)(msb & 0x1F) << 6);
        } else if (msb == 0xF0) {
            usb_keyboard_press_key(n, 0);
            return;
        } else if (msb == 0xE0) {
            usb_keyboard_press_key(0, n);
            return;
#ifdef KEYMEDIA_INTERFACE
        } else if (msb == 0xE2) {
            usb_keymedia_press_system_key(n);
            return;
        } else if (msb >= 0xE4 && msb <= 0xE7) {
            usb_keymedia_press_consumer_key(n & 0x3FF);
            return;
#endif
        } else {
            return;
        }
    }
    keycode = unicode_to_keycode(n);
    if (!keycode) return;
#ifdef DEADKEYS_MASK
    deadkeycode = deadkey_to_keycode(keycode);
    if (deadkeycode) {
        modrestore = keyboard_modifier_keys;
        if (modrestore) {
            keyboard_modifier_keys = 0;
            usb_keyboard_send();
        }
        // TODO: test if operating systems recognize
        // deadkey sequences when other keys are held
        mod = keycode_to_modifier(deadkeycode);
        key = keycode_to_key(deadkeycode);
        usb_keyboard_press_key(key, mod);
        usb_keyboard_release_key(key, mod);
    }
#endif
    mod = keycode_to_modifier(keycode);
    key = keycode_to_key(keycode);
    usb_keyboard_press_key(key, mod | modrestore);
}


void usb_keyboard_release_keycode(uint16_t n)
{
    uint8_t key, mod, msb;

    msb = n >> 8;
    if (msb >= 0xC2) {
        if (msb <= 0xDF) {
            n = (n & 0x3F) | ((uint16_t)(msb & 0x1F) << 6);
        } else if (msb == 0xF0) {
            usb_keyboard_release_key(n, 0);
            return;
        } else if (msb == 0xE0) {
            usb_keyboard_release_key(0, n);
            return;
#ifdef KEYMEDIA_INTERFACE
        } else if (msb == 0xE2) {
            usb_keymedia_release_system_key(n);
            return;
        } else if (msb >= 0xE4 && msb <= 0xE7) {
            usb_keymedia_release_consumer_key(n & 0x3FF);
            return;
#endif
        } else {
            return;
        }
    }
    KEYCODE_TYPE keycode = unicode_to_keycode(n);
    if (!keycode) return;
    mod = keycode_to_modifier(keycode);
    key = keycode_to_key(keycode);
    usb_keyboard_release_key(key, mod);
}


static void usb_keyboard_press_key(uint8_t key, uint8_t modifier)
{
    int i, send_required = 0;

    if (modifier) {
        if ((keyboard_modifier_keys & modifier) != modifier) {
            keyboard_modifier_keys |= modifier;
            send_required = 1;
        }
    }
    if (key) {
        for (i=0; i < sizeof(keyboard_keys); i++) {
            if (keyboard_keys[i] == key) goto end;
        }
        for (i=0; i < sizeof(keyboard_keys); i++) {
            if (keyboard_keys[i] == 0) {
                keyboard_keys[i] = key;
                send_required = 1;
                goto end;
            }
        }
    }
    end:
    if (send_required) usb_keyboard_send();
}


static void usb_keyboard_release_key(uint8_t key, uint8_t modifier)
{
    int i, send_required = 0;

    if (modifier) {
        if ((keyboard_modifier_keys & modifier) != 0) {
            keyboard_modifier_keys &= ~modifier;
            send_required = 1;
        }
    }
    if (key) {
        for (i=0; i < sizeof(keyboard_keys); i++) {
            if (keyboard_keys[i] == key) {
                keyboard_keys[i] = 0;
                send_required = 1;
            }
        }
    }
    if (send_required) usb_keyboard_send();
}

void usb_keyboard_release_all(void)
{
    uint8_t i, anybits;

    anybits = keyboard_modifier_keys;
    keyboard_modifier_keys = 0;
    for (i=0; i < sizeof(keyboard_keys); i++) {
        anybits |= keyboard_keys[i];
        keyboard_keys[i] = 0;
    }
    if (anybits) usb_keyboard_send();
#ifdef KEYMEDIA_INTERFACE
    anybits = 0;
    for (i=0; i < 4; i++) {
        if (keymedia_consumer_keys[i] != 0) anybits = 1;
        keymedia_consumer_keys[i] = 0;
    }
    for (i=0; i < 3; i++) {
        if (keymedia_system_keys[i] != 0) anybits = 1;
        keymedia_system_keys[i] = 0;
    }
    if (anybits) usb_keymedia_send();
#endif
}


int usb_keyboard_press(uint8_t key, uint8_t modifier)
{
    int r;
    keyboard_modifier_keys = modifier;
    memset(keyboard_keys, 0, sizeof(keyboard_keys));
    keyboard_keys[0] = key;
    r = usb_keyboard_send();
    if (r) return r;
    keyboard_modifier_keys = 0;
    keyboard_keys[0] = 0;
    return usb_keyboard_send();
}


static uint8_t transmit_previous_timeout=0;

// When the PC isn't listening, how long do we wait before discarding data?
#define TX_TIMEOUT_MSEC 50

int usb_keyboard_transmit(int endpoint, const uint8_t *data, uint32_t len)
{
    if (!usb_configuration) return -1;
    uint32_t head = tx_head;
    transfer_t *xfer = tx_transfer + head;
    uint32_t wait_begin_at = systick_millis_count;
    while (1) {
        uint32_t status = usb_transfer_status(xfer);
        if (!(status & 0x80)) {
            if (status & 0x68) {
                // TODO: what if status has errors???
                printf("ERROR status = %x, i=%d, ms=%u\n",
                    status, tx_head, systick_millis_count);
            }
            transmit_previous_timeout = 0;
            break;
        }
        if (transmit_previous_timeout) return -1;
        if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
            // waited too long, assume the USB host isn't listening
            transmit_previous_timeout = 1;
            return -1;
        }
        if (!usb_configuration) return -1;
        yield();
    }
    delayNanoseconds(30); // min req'd 11 ns, TODO: why is status ready too soon?
    uint8_t *buffer = txbuffer + head * TX_BUFSIZE;
    memcpy(buffer, data, len);
    usb_prepare_transfer(xfer, buffer, len, 0);
    arm_dcache_flush_delete(buffer, TX_BUFSIZE);
    usb_transmit(endpoint, xfer);
    if (++head >= TX_NUM) head = 0;
    tx_head = head;
    return 0;
}


// send the contents of keyboard_keys and keyboard_modifier_keys
int usb_keyboard_send(void)
{
    uint8_t buffer[KEYBOARD_SIZE];
    memcpy(buffer + 2, keyboard_keys, KEYBOARD_SIZE-2);
    buffer[0] = keyboard_modifier_keys;
    buffer[1] = 0;
    // buffer[2] = keyboard_keys[0];
    // buffer[3] = keyboard_keys[1];
    // buffer[4] = keyboard_keys[2];
    // buffer[5] = keyboard_keys[3];
    // buffer[6] = keyboard_keys[4];
    // buffer[7] = keyboard_keys[5];
    return usb_keyboard_transmit(KEYBOARD_ENDPOINT, buffer, KEYBOARD_SIZE);
}


#ifdef KEYMEDIA_INTERFACE

static void usb_keymedia_press_consumer_key(uint16_t key)
{
    int i;

    if (key == 0) return;
    for (i=0; i < 4; i++) {
        if (keymedia_consumer_keys[i] == key) return;
    }
    for (i=0; i < 4; i++) {
        if (keymedia_consumer_keys[i] == 0) {
            keymedia_consumer_keys[i] = key;
            usb_keymedia_send();
            return;
        }
    }
}

static void usb_keymedia_release_consumer_key(uint16_t key)
{
    int i;

    if (key == 0) return;
    for (i=0; i < 4; i++) {
        if (keymedia_consumer_keys[i] == key) {
            keymedia_consumer_keys[i] = 0;
            usb_keymedia_send();
            return;
        }
    }
}

static void usb_keymedia_press_system_key(uint8_t key)
{
    int i;

    if (key == 0) return;
    for (i=0; i < 3; i++) {
        if (keymedia_system_keys[i] == key) return;
    }
    for (i=0; i < 3; i++) {
        if (keymedia_system_keys[i] == 0) {
            keymedia_system_keys[i] = key;
            usb_keymedia_send();
            return;
        }
    }
}

static void usb_keymedia_release_system_key(uint8_t key)
{
    int i;

    if (key == 0) return;
    for (i=0; i < 3; i++) {
        if (keymedia_system_keys[i] == key) {
            keymedia_system_keys[i] = 0;
            usb_keymedia_send();
            return;
        }
    }
}

void usb_keymedia_release_all(void)
{
    uint8_t i, anybits;

    anybits = 0;
    for (i=0; i < 4; i++) {
        if (keymedia_consumer_keys[i] != 0) anybits = 1;
        keymedia_consumer_keys[i] = 0;
    }
    for (i=0; i < 3; i++) {
        if (keymedia_system_keys[i] != 0) anybits = 1;
        keymedia_system_keys[i] = 0;
    }
    if (anybits) usb_keymedia_send();
}

// send the contents of keyboard_keys and keyboard_modifier_keys
static int usb_keymedia_send(void)
{
    uint8_t buffer[8];
    const uint16_t *consumer = keymedia_consumer_keys;
    // 44444444 44333333 33332222 22222211 11111111
    // 98765432 10987654 32109876 54321098 76543210
    buffer[0] = consumer[0];
    buffer[1] = (consumer[1] << 2) | ((consumer[0] >> 8) & 0x03);
    buffer[2] = (consumer[2] << 4) | ((consumer[1] >> 6) & 0x0F);
    buffer[3] = (consumer[3] << 6) | ((consumer[2] >> 4) & 0x3F);
    buffer[4] = consumer[3] >> 2;
    buffer[5] = keymedia_system_keys[0];
    buffer[6] = keymedia_system_keys[1];
    buffer[7] = keymedia_system_keys[2];
    return usb_keyboard_transmit(KEYMEDIA_ENDPOINT, buffer, KEYMEDIA_SIZE);
}

#endif // KEYMEDIA_INTERFACE

#endif // KEYBOARD_INTERFACE

[@file: to_replace/usb_keyboard.h]
/* Teensyduino Core Library
 * http://www.pjrc.com/teensy/
 * Copyright (c) 2017 PJRC.COM, LLC.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * 1. The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * 2. If the Software is incorporated into a build system that allows
 * selection among a list of target devices, then similar target
 * devices manufactured by PJRC.COM must be included in the list of
 * target devices and selectable in the same manner.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#pragma once

#include "usb_desc.h"

#include "keylayouts.h"

#if defined(KEYBOARD_INTERFACE)

#include <inttypes.h>

// C language implementation
#ifdef __cplusplus
extern "C" {
#endif
void usb_keyboard_configure(void);
void usb_keyboard_write(uint8_t c);
void usb_keyboard_write_unicode(uint16_t cpoint);
void usb_keyboard_press_keycode(uint16_t n);
void usb_keyboard_release_keycode(uint16_t n);
void usb_keyboard_release_all(void);
int usb_keyboard_press(uint8_t key, uint8_t modifier);
int usb_keyboard_send(void);
int usb_keyboard_transmit(int endpoint, const uint8_t *data, uint32_t len);
#ifdef KEYMEDIA_INTERFACE
void usb_keymedia_release_all(void);
#endif
extern uint8_t keyboard_modifier_keys;
extern uint8_t keyboard_keys[KEYBOARD_SIZE - 2];
extern uint8_t keyboard_protocol;
extern uint8_t keyboard_idle_config;
extern uint8_t keyboard_idle_count;
extern volatile uint8_t keyboard_leds;
extern volatile uint8_t usb_configuration;
#ifdef __cplusplus
}
#endif

// C++ interface
#ifdef __cplusplus
#include "Stream.h"
class usb_keyboard_class : public Print {
public:
    void begin(void) {}
    void end(void) {}
    virtual size_t write(uint8_t c) {
        usb_keyboard_write(c);
        return 1;
    }
    size_t write(unsigned long n) { return write((uint8_t)n); }
    size_t write(long n) { return write((uint8_t)n); }
    size_t write(unsigned int n) { return write((uint8_t)n); }
    size_t write(int n) { return write((uint8_t)n); }
    using Print::write;
    void write_unicode(uint16_t n) { usb_keyboard_write_unicode(n); }
    void set_modifier(uint16_t c) { keyboard_modifier_keys = (uint8_t)c; }
    void set_key1(uint8_t c) { keyboard_keys[0] = c; }
    void set_key2(uint8_t c) { keyboard_keys[1] = c; }
    void set_key3(uint8_t c) { keyboard_keys[2] = c; }
    void set_key4(uint8_t c) { keyboard_keys[3] = c; }
    void set_key5(uint8_t c) { keyboard_keys[4] = c; }
    void set_key6(uint8_t c) { keyboard_keys[5] = c; }
    void set_keyx(uint8_t c, int n) { keyboard_keys[n] = c; }
#ifdef KEYMEDIA_INTERFACE
    void set_media(uint16_t c) {
        if (c == 0) {
            usb_keymedia_release_all();
        } else if (c >= 0xE400 && c <= 0xE7FF) {
            press(c);
        }
    }
#endif
    void send_now(void) { usb_keyboard_send(); }
    void press(uint16_t n) { usb_keyboard_press_keycode(n); }
    void release(uint16_t n) { usb_keyboard_release_keycode(n); }
    void releaseAll(void) { usb_keyboard_release_all(); }
};

extern usb_keyboard_class Keyboard;

#endif // __cplusplus

#endif // KEYBOARD_INTERFACE

